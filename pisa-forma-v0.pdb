// Copyright (C) 2011 ASIP Solutions, Inc. All rights reserved. 
// Generated by ASIP Meister 2.3 on 2014/07/09 12:55:15 
Version{
 2.3
}
FileType{
 Design
}
Database{
 path{
  ./peas3
 }
 sufix{
  pdb
 }
 type{
  PEAS3 DataFile
 }

}
Preference{
 Version{
  2.3
 }

}
AbsLevelArch{
 Complete{
  ON
 }
 CPUtype{
  midTitle{
   CPU_type
  }
  label{
   CPU type
  }
  method{
   radiobutton  Pipeline
  }
  select{
   Pipeline
  }
  Pipeline{
   midTitle{
    Pipeline_architecture
   }
   StageNum{
    midTitle{
     Number_of_stages
    }
    label{
     Num. of Stages
    }
    method{
     factor stage
    }
    unit{
     
    }
    select{
     6
    }

   }
   CommonStageNum{
    midTitle{
     Number_of_common_stages
    }
    label{
     Num. of Common Stages
    }
    method{
     integer
    }
    unit{
     
    }
    select{
     0
    }
    enable{
     false
    }

   }
   DecodeStage{
    midTitle{
     
    }
    label{
     Decode Stage
    }
    method{
     integer
    }
    unit{
     [-th]
    }
    select{
     2
    }

   }
   StageDef{
    midTitle{
     Stage_Definition
    }
    method{
     dylist stage
    }
    stage{
     midTitle{
      stage
     }
     1{
      midTitle{
       stage1
      }
      label{
       1
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       IF,1,fetch
      }

     }
     2{
      midTitle{
       stage2
      }
      label{
       2
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       ID,1,decode & register_read
      }

     }
     3{
      midTitle{
       stage3
      }
      label{
       3
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       EX,1,register_read & exec
      }

     }
     4{
      midTitle{
       stage4
      }
      label{
       4
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       MEM1,1,memory_read & memory_write
      }

     }
     5{
      midTitle{
       stage5
      }
      label{
       5
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       MEM2,1,memory_read & memory_write
      }

     }
     6{
      midTitle{
       stage6
      }
      label{
       6
      }
      method{
       specified
      }
      unit{
       [cycle]
      }
      select{
       WB,1,register_write
      }

     }

    }

   }
   MultiscInterlock{
    midTitle{
     Multi_cycle_interlock
    }
    label{
     Multi cycle interlock
    }
    method{
     radiobutton Yes No
    }
    select{
     Yes
    }
    enable{
     false
    }

   }
   DataHazInterlock{
    midTitle{
     Data_hazard_interlock
    }
    label{
     Data hazard interlock
    }
    method{
     radiobutton Yes No
    }
    select{
     No
    }
    enable{
     false
    }

   }
   RegBypass{
    midTitle{
     Register_bypass
    }
    label{
     Register bypass
    }
    method{
     radiobutton Yes No
    }
    select{
     No
    }
    enable{
     false
    }

   }
   DlydBranch{
    midTitle{
     Delayed_branch
    }
    label{
     Delayed branch
    }
    method{
     radiobutton Yes No
    }
    select{
     No
    }
    Yes{
     midTitle{
      Number_of_exec_delayed_slot
     }
     DelaySlot{
      midTitle{
       number
      }
      label{
       Num. of delayed slot
      }
      method{
       integer
      }
      unit{
       [instruction]
      }
      select{
       1
      }

     }

    }

   }

  }

 }
 MAXInstBitWidth{
  midTitle{
   MAX_instruction_bit_width
  }
  label{
   Max inst. bit width
  }
  method{
   integer
  }
  unit{
   [bit]
  }
  select{
   64
  }

 }
 Projectname{
  midTitle{
   
  }
  label{
   Project name
  }
  method{
   entry
  }
  select{
   Resil
  }

 }
 FhmWorkname{
  midTitle{
   Fhm_workname
  }
  label{
   Fhm workname
  }
  method{
   entry
  }
  select{
   FHM_work
  }
  enable{
   false
  }

 }
 Revision{
  midTitle{
   
  }
  label{
   Revision No.
  }
  method{
   message
  }
  select{
   Resil_0907
  }

 }
 DesignConst{
  midTitle{
   
  }
  method{
   list Design_Goal
  }
  Design_Goal{
   midTitle{
    construciton
   }
   Area{
    midTitle{
     Goal_area
    }
    label{
     Goal Area
    }
    method{
     integer
    }
    unit{
     [gates]
    }
    select{
     5000000
    }

   }
   Delay{
    midTitle{
     Goal_delay
    }
    label{
     Goal Delay
    }
    method{
     integer
    }
    unit{
     [ns]
    }
    select{
     100
    }

   }
   PowerS{
    midTitle{
     Goal_power_S
    }
    label{
     Goal Power S
    }
    method{
     integer
    }
    unit{
     [uW/MHz]
    }
    select{
     10000
    }

   }

  }

 }
 Priority{
  midTitle{
   Priority
  }
  label{
   Design Priority
  }
  method{
   radiobutton Area Performance Power
  }
  select{
   Performance
  }

 }
 MAXDataBitWidth{
  midTitle{
   MAX_data_width
  }
  label{
   Max data bit width
  }
  method{
   integer
  }
  unit{
   [bit]
  }
  select{
   32
  }

 }
 ProcessorDesign{
  midTitle{
   Processor_design
  }
  label{
   Processor design
  }
  method{
   radiobuttonDesign \"New Design\" \"New Design with Base Processor\" \"Base Processor Design\"
  }
  select{
   New Design
  }

 }
 UseCompiler{
  midTitle{
   Use_compiler
  }
  label{
   Use compiler
  }
  method{
   radiobuttonCom Yes No
  }
  select{
   No
  }
  enable{
   false
  }

 }

}
EntityDecl{
 Complete{
  ON
 }
 ComponentName{
  ssCPU_2_3_0
 }
 Entity{
  1{
   valid{
    true
   }
   name{
    CLK
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    clock
   }

  }
  2{
   valid{
    true
   }
   name{
    Reset
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    reset
   }

  }
  3{
   valid{
    true
   }
   name{
    imaddr
   }
   type{
    out
   }
   entity{
    32
   }
   attribute{
    instruction_memory_address_bus
   }

  }
  4{
   valid{
    true
   }
   name{
    imdat_in
   }
   type{
    in
   }
   entity{
    64
   }
   attribute{
    instruction_memory_data_in_bus
   }

  }
  5{
   valid{
    true
   }
   name{
    imdat_out
   }
   type{
    out
   }
   entity{
    64
   }
   attribute{
    instruction_memory_data_out_bus
   }

  }
  6{
   valid{
    false
   }
   name{
    ireq
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    instruction_memory_request_bus
   }

  }
  7{
   valid{
    false
   }
   name{
    iack
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    instruction_memory_acknowledge_bus
   }

  }
  8{
   valid{
    true
   }
   name{
    imrw
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    instruction_memory_rw_bus
   }

  }
  9{
   valid{
    false
   }
   name{
    imwr_mod
   }
   type{
    out
   }
   entity{
    2
   }
   attribute{
    instruction_memory_write_mode_bus
   }

  }
  10{
   valid{
    false
   }
   name{
    imext_mod
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    instruction_memory_ext_mode_bus
   }

  }
  11{
   valid{
    true
   }
   name{
    imaddr_err
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    instruction_memory_address_error_bus
   }

  }
  12{
   valid{
    false
   }
   name{
    imcacl
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    instruction_memory_cancel_bus
   }

  }
  13{
   valid{
    true
   }
   name{
    DataAB
   }
   type{
    out
   }
   entity{
    32
   }
   attribute{
    data_memory_address_bus
   }

  }
  14{
   valid{
    true
   }
   name{
    DataDIB
   }
   type{
    in
   }
   entity{
    32
   }
   attribute{
    data_memory_data_in_bus
   }

  }
  15{
   valid{
    true
   }
   name{
    DataDOB
   }
   type{
    out
   }
   entity{
    32
   }
   attribute{
    data_memory_data_out_bus
   }

  }
  16{
   valid{
    true
   }
   name{
    DataReq
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    data_memory_request_bus
   }

  }
  17{
   valid{
    true
   }
   name{
    DataAck
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    data_memory_acknowledge_bus
   }

  }
  18{
   valid{
    true
   }
   name{
    DataRW
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    data_memory_rw_bus
   }

  }
  19{
   valid{
    true
   }
   name{
    DataMode
   }
   type{
    out
   }
   entity{
    2
   }
   attribute{
    data_memory_write_mode_bus
   }

  }
  20{
   valid{
    true
   }
   name{
    DataExt
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    data_memory_ext_mode_bus
   }

  }
  21{
   valid{
    true
   }
   name{
    DataAdrerr
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    data_memory_address_error_bus
   }

  }
  22{
   valid{
    true
   }
   name{
    DataCancel
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    data_memory_cancel_bus
   }

  }
  23{
   valid{
    false
   }
   name{
    int
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    interrupt
   }

  }
  24{
   valid{
    false
   }
   name{
    data2buf
   }
   type{
    out
   }
   entity{
    64
   }
   attribute{
    unspecified
   }

  }
  25{
   valid{
    false
   }
   name{
    addr2buf
   }
   type{
    out
   }
   entity{
    32
   }
   attribute{
    unspecified
   }

  }
  26{
   valid{
    false
   }
   name{
    req2buf
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    unspecified
   }

  }
  27{
   valid{
    false
   }
   name{
    rw2buf
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    unspecified
   }

  }
  28{
   valid{
    false
   }
   name{
    data2mem
   }
   type{
    in
   }
   entity{
    64
   }
   attribute{
    unspecified
   }

  }
  29{
   valid{
    false
   }
   name{
    RFRAMaddr
   }
   type{
    out
   }
   entity{
    32
   }
   attribute{
    unspecified
   }

  }
  30{
   valid{
    false
   }
   name{
    RFRAMdin
   }
   type{
    in
   }
   entity{
    64
   }
   attribute{
    unspecified
   }

  }
  31{
   valid{
    false
   }
   name{
    RFRAMdout
   }
   type{
    out
   }
   entity{
    64
   }
   attribute{
    unspecified
   }

  }
  32{
   valid{
    false
   }
   name{
    RFRAMrw
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    unspecified
   }

  }
  33{
   valid{
    false
   }
   name{
    RFRAMreq
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    unspecified
   }

  }
  34{
   valid{
    false
   }
   name{
    int_im
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    interrupt
   }

  }
  35{
   valid{
    false
   }
   name{
    end_im
   }
   type{
    in
   }
   entity{
    1
   }
   attribute{
    interrupt
   }

  }
  36{
   valid{
    false
   }
   name{
    EOI_OUT
   }
   type{
    out
   }
   entity{
    1
   }
   attribute{
    unspecified
   }

  }

 }

}
ResourceDecl{
 Complete{
  ON
 }
 Instance{
  ALU1{
   valid{
    true
   }
   class{
    name{
     alu
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  ADD1{
   valid{
    true
   }
   class{
    name{
     adder
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  DIV1{
   valid{
    true
   }
   class{
    name{
     divider
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     algorithm{
      array
     }
     adder_algorithm{
      default
     }
     data_type{
      two_complement
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  EXT1{
   valid{
    true
   }
   class{
    name{
     extender
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      16
     }
     bit_width_out{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MUL1{
   valid{
    true
   }
   class{
    name{
     multiplier
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     algorithm{
      array
     }
     adder_algorithm{
      default
     }
     data_type{
      two_complement
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  HI{
   valid{
    true
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     Plain Register
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  LO{
   valid{
    true
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     Plain Register
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  GPR{
   valid{
    true
   }
   class{
    name{
     registerfile
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     Register File
    }
    parameter{
     bit_width{
      32
     }
     num_register{
      32
     }
     num_read_port{
      4
     }
     num_write_port{
      2
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  IReg{
   valid{
    true
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     Inst. Register
    }
    parameter{
     bit_width{
      64
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  Dmem{
   valid{
    true
   }
   class{
    name{
     mifu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     Data Memory
    }
    parameter{
     bit_width{
      32
     }
     address_space{
      32
     }
     access_width{
      8
     }
     access_mode{
      multi_cycle
     }
     type{
      read_write
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  CPC{
   valid{
    true
   }
   class{
    name{
     pcu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     Prog. Counter
    }
    parameter{
     bit_width{
      32
     }
     increment_step{
      8
     }
     adder_algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  SFT1{
   valid{
    true
   }
   class{
    name{
     shifter
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     amount{
      variable
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  ADD2{
   valid{
    false
   }
   class{
    name{
     adder
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      30
     }
     algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  SYSREG{
   valid{
    true
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  ireq{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  iack{
   valid{
    false
   }
   class{
    name{
     wire_in
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWU0{
   valid{
    true
   }
   class{
    name{
     fwu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      8
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWU1{
   valid{
    true
   }
   class{
    name{
     fwu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      8
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWU2{
   valid{
    true
   }
   class{
    name{
     fwu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      8
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWU3{
   valid{
    true
   }
   class{
    name{
     fwu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      8
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  ADDER2{
   valid{
    true
   }
   class{
    name{
     adder
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  Imem{
   valid{
    true
   }
   class{
    name{
     mifu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     Inst. Memory
    }
    parameter{
     bit_width{
      64
     }
     address_space{
      32
     }
     access_width{
      64
     }
     access_mode{
      single_cycle
     }
     type{
      read_write
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  hashedReg{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  IncHashedReg{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  CheckedBB{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  COMP32{
   valid{
    false
   }
   class{
    name{
     comparator
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     algorithm{
      rca
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  testbuffer{
   valid{
    false
   }
   class{
    name{
     registerfile
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     Register File
    }
    parameter{
     bit_width{
      32
     }
     num_register{
      32
     }
     num_read_port{
      4
     }
     num_write_port{
      2
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    This is used like a buffer  for backup of states.
   }

  }
  bufflag{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MUX0{
   valid{
    false
   }
   class{
    name{
     multiplexor
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      2
     }
     number_of_ports{
      16
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  data2buf{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  addr2buf{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  req2buf{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  rw2buf{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  data2mem{
   valid{
    false
   }
   class{
    name{
     wire_in
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  crc{
   valid{
    false
   }
   class{
    name{
     pcu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     increment_step{
      8
     }
     adder_algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  cpc_bak{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  HI_bak{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  LO_bak{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  HI_flag{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  LO_flag{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  PC_bot{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  BBC{
   valid{
    false
   }
   class{
    name{
     pcu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     increment_step{
      8
     }
     adder_algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  IROM_data{
   valid{
    false
   }
   class{
    name{
     wire_in
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  IROM_addr{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RFC{
   valid{
    false
   }
   class{
    name{
     pcu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     increment_step{
      8
     }
     adder_algorithm{
      default
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RFRAMaddr{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RFRAMdout{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RFRAMdin{
   valid{
    false
   }
   class{
    name{
     wire_in
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RFRAMrw{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RFRAMreq{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  int_im{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  end_im{
   valid{
    false
   }
   class{
    name{
     wire_in
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MASKREG0{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     Mask Register
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  IReg0{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    used in pipeline Stage 1, 2, 3 to simplify fetch operation. working with IReg 1, IReg
   }

  }
  IReg1{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    used in pipeline Stage 1, 2, 3 to simplify fetch operation. Working with IReg0, IReg.
   }

  }
  if_irom{
   valid{
    false
   }
   class{
    name{
     mifu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }
     address_space{
      32
     }
     access_width{
      64
     }
     access_mode{
      single_cycle
     }
     type{
      read_only
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  EOI_OUT{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  if_irom1{
   valid{
    false
   }
   class{
    name{
     mifu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }
     address_space{
      32
     }
     access_width{
      64
     }
     access_mode{
      single_cycle
     }
     type{
      read_only
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  if_iram1{
   valid{
    false
   }
   class{
    name{
     mifu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      64
     }
     address_space{
      32
     }
     access_width{
      64
     }
     access_mode{
      single_cycle
     }
     type{
      read_write
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  chkflag{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemReadFlag0{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  Record_rt0{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  COMP50{
   valid{
    false
   }
   class{
    name{
     comparator
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     algorithm{
      rca
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  COMP51{
   valid{
    false
   }
   class{
    name{
     comparator
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     algorithm{
      rca
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  STALL_EN{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  COMP52{
   valid{
    false
   }
   class{
    name{
     comparator
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     algorithm{
      rca
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  COMP53{
   valid{
    false
   }
   class{
    name{
     comparator
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     algorithm{
      rca
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemReadFlag1{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  COMP54{
   valid{
    false
   }
   class{
    name{
     comparator
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     algorithm{
      rca
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  COMP55{
   valid{
    false
   }
   class{
    name{
     comparator
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     algorithm{
      rca
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  COMP56{
   valid{
    false
   }
   class{
    name{
     comparator
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     algorithm{
      rca
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  COMP57{
   valid{
    false
   }
   class{
    name{
     comparator
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     algorithm{
      rca
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  WIRE_STALL_EN{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RecordRt0{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RecordRt1{
   valid{
    false
   }
   class{
    name{
     wire_in
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemLoadFlag00{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemLoadFlag01{
   valid{
    false
   }
   class{
    name{
     wire_in
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemLoadFlag10{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemLoadFlag11{
   valid{
    false
   }
   class{
    name{
     wire_in
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RecordRt0s{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RecordRt0r{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  RecordRt0d{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      5
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemLoadFlag10s{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemLoadFlag10r{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemLoadFlag00s{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MemLoadFlag00r{
   valid{
    false
   }
   class{
    name{
     wire_out
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      1
     }
     default_output{
      fix_to_0
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  PC_head{
   valid{
    false
   }
   class{
    name{
     register
    }
    modelpath{
     /basicfhmdb/storage/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWU4{
   valid{
    true
   }
   class{
    name{
     fwu
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      8
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    Deployed for transferring GPR data
   }

  }
  FWUL0{
   valid{
    true
   }
   class{
    name{
     fwu_lock
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      8
     }
     lockstage_number{
      6
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWUL1{
   valid{
    true
   }
   class{
    name{
     fwu_lock
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      8
     }
     lockstage_number{
      6
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWUL2{
   valid{
    true
   }
   class{
    name{
     fwu_lock
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      8
     }
     lockstage_number{
      6
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  FWUL3{
   valid{
    true
   }
   class{
    name{
     fwu_lock
    }
    modelpath{
     /workdb/FHM_work/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     addr_width{
      5
     }
     stage_number{
      8
     }
     lockstage_number{
      6
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    
   }

  }
  MUXw32p4{
   valid{
    true
   }
   class{
    name{
     multiplexor
    }
    modelpath{
     /basicfhmdb/computational/
    }
    use{
     (unspecified)
    }
    parameter{
     bit_width{
      32
     }
     number_of_ports{
      4
     }

    }

   }
   Simulation{
    Behavior
   }
   Synthesis{
    Gate
   }
   Comment{
    Un-Aligned Memory Access
   }

  }

 }

}
StorageSpec{
 Complete{
  ON
 }
 RegisterFile{
  Before{
   0{
    Name{
     GPR[asc]
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     [bin-asc]
    }

   }

  }
  After{
   0{
    Name{
     GPR0
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     0
    }
    Usage{
     zero-reg
    }
    Location{
     original
    }
    Binary{
     00000
    }

   }
   1{
    Name{
     GPR1
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     1
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     00001
    }

   }
   2{
    Name{
     GPR2
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     2
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     00010
    }

   }
   3{
    Name{
     GPR3
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     3
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     00011
    }

   }
   4{
    Name{
     GPR4
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     4
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     00100
    }

   }
   5{
    Name{
     GPR5
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     5
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     00101
    }

   }
   6{
    Name{
     GPR6
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     6
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     00110
    }

   }
   7{
    Name{
     GPR7
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     7
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     00111
    }

   }
   8{
    Name{
     GPR8
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     8
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01000
    }

   }
   9{
    Name{
     GPR9
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     9
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01001
    }

   }
   10{
    Name{
     GPR10
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     10
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01010
    }

   }
   11{
    Name{
     GPR11
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     11
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01011
    }

   }
   12{
    Name{
     GPR12
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     12
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01100
    }

   }
   13{
    Name{
     GPR13
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     13
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01101
    }

   }
   14{
    Name{
     GPR14
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     14
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01110
    }

   }
   15{
    Name{
     GPR15
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     15
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     01111
    }

   }
   16{
    Name{
     GPR16
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     16
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10000
    }

   }
   17{
    Name{
     GPR17
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     17
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10001
    }

   }
   18{
    Name{
     GPR18
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     18
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10010
    }

   }
   19{
    Name{
     GPR19
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     19
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10011
    }

   }
   20{
    Name{
     GPR20
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     20
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10100
    }

   }
   21{
    Name{
     GPR21
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     21
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10101
    }

   }
   22{
    Name{
     GPR22
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     22
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10110
    }

   }
   23{
    Name{
     GPR23
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     23
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     10111
    }

   }
   24{
    Name{
     GPR24
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     24
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11000
    }

   }
   25{
    Name{
     GPR25
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     25
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11001
    }

   }
   26{
    Name{
     GPR26
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     26
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11010
    }

   }
   27{
    Name{
     GPR27
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     27
    }
    Usage{
     reg
    }
    Location{
     original
    }
    Binary{
     11011
    }

   }
   28{
    Name{
     GPR28
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     28
    }
    Usage{
     sp
    }
    Location{
     original
    }
    Binary{
     11100
    }

   }
   29{
    Name{
     GPR29
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     29
    }
    Usage{
     fp
    }
    Location{
     original
    }
    Binary{
     11101
    }

   }
   30{
    Name{
     GPR30
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     30
    }
    Usage{
     link
    }
    Location{
     original
    }
    Binary{
     11110
    }

   }
   31{
    Name{
     GPR31
    }
    Class{
     GPR
    }
    Resource{
     GPR
    }
    Width{
     32
    }
    Num{
     31
    }
    Usage{
     return
    }
    Location{
     original
    }
    Binary{
     11111
    }

   }

  }

 }
 Register{
  0{
   Name{
    HI
   }
   Resource{
    HI
   }
   Width{
    32
   }
   Usage{
    reg
   }
   Location{
    original
   }

  }
  1{
   Name{
    LO
   }
   Resource{
    LO
   }
   Width{
    32
   }
   Usage{
    reg
   }
   Location{
    original
   }

  }
  2{
   Name{
    IReg
   }
   Resource{
    IReg
   }
   Width{
    64
   }
   Usage{
    ireg
   }
   Location{
    original
   }

  }
  3{
   Name{
    CPC
   }
   Resource{
    CPC
   }
   Width{
    32
   }
   Usage{
    pc
   }
   Location{
    original
   }

  }

 }
 Memory{
  0{
   Name{
    Dmem
   }
   Resource{
    Dmem
   }
   Width{
    32
   }
   Usage{
    d-memory
   }
   Access{
    8
   }

  }
  1{
   Name{
    Imem
   }
   Resource{
    Imem
   }
   Width{
    64
   }
   Usage{
    i-memory
   }
   Access{
    64
   }

  }

 }

}
InstructionDecl{
 Complete{
  ON
 }
 MaxInstId{
  183
 }
 InstructionType{
  R  #1{
   Valid{
    true
   }
   Name{
    R
   }
   Entity{
    1{
     MSB{
      63
     }
     LSB{
      48
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      0000000000000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      47
     }
     LSB{
      32
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      opcode
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    3{
     MSB{
      31
     }
     LSB{
      29
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    4{
     MSB{
      28
     }
     LSB{
      24
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    5{
     MSB{
      23
     }
     LSB{
      21
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    6{
     MSB{
      20
     }
     LSB{
      16
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rt
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rt
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    7{
     MSB{
      15
     }
     LSB{
      13
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    8{
     MSB{
      12
     }
     LSB{
      8
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rd
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rd
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    9{
     MSB{
      7
     }
     LSB{
      0
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      shamt
     }
     Addr_mode{
      Immediate_data
     }
     Operand_Name{
      shamt
     }
     Element{
      Immediate
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    false
   }

  }
  I  #1{
   Valid{
    true
   }
   Name{
    I
   }
   Entity{
    1{
     MSB{
      63
     }
     LSB{
      48
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      0000000000000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      47
     }
     LSB{
      32
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      opcode
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    3{
     MSB{
      31
     }
     LSB{
      29
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    4{
     MSB{
      28
     }
     LSB{
      24
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    5{
     MSB{
      23
     }
     LSB{
      21
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    6{
     MSB{
      20
     }
     LSB{
      16
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rt
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rt
     }
     Element{
      Resource
     }
     Reg_class{
      GPR
     }

    }
    7{
     MSB{
      15
     }
     LSB{
      0
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      imm
     }
     Addr_mode{
      Immediate_data
     }
     Operand_Name{
      imm
     }
     Element{
      Immediate
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    false
   }

  }
  J  #1{
   Valid{
    true
   }
   Name{
    J
   }
   Entity{
    1{
     MSB{
      63
     }
     LSB{
      48
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      0000000000000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      47
     }
     LSB{
      32
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      opcode
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    3{
     MSB{
      31
     }
     LSB{
      26
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    4{
     MSB{
      25
     }
     LSB{
      0
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      targ
     }
     Addr_mode{
      PCrelative_address
     }
     Operand_Name{
      targ
     }
     Element{
      Symbol
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    false
   }

  }
  INH  #1{
   Valid{
    true
   }
   Name{
    INH
   }
   Entity{
    1{
     MSB{
      63
     }
     LSB{
      48
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      0000000000000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      47
     }
     LSB{
      32
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      opcode
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    3{
     MSB{
      31
     }
     LSB{
      0
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      00000000000000000000000000000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    false
   }

  }
  buf2reg  #1{
   Valid{
    false
   }
   Name{
    buf2reg
   }
   Entity{
    1{
     MSB{
      63
     }
     LSB{
      48
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      0000000000000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    2{
     MSB{
      47
     }
     LSB{
      32
     }
     FieldType{
      OP-code
     }
     FieldAttr{
      name
     }
     Value{
      opcode
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    3{
     MSB{
      31
     }
     LSB{
      29
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    4{
     MSB{
      28
     }
     LSB{
      24
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rs
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rs
     }
     Element{
      Resource
     }
     Reg_class{
      BUFF
     }

    }
    5{
     MSB{
      23
     }
     LSB{
      21
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    6{
     MSB{
      20
     }
     LSB{
      16
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      rt
     }
     Addr_mode{
      RDirect
     }
     Operand_Name{
      rt
     }
     Element{
      Resource
     }
     Reg_class{
      BUFF
     }

    }
    7{
     MSB{
      15
     }
     LSB{
      4
     }
     FieldType{
      Reserved
     }
     FieldAttr{
      binary
     }
     Value{
      000000000000
     }
     Addr_mode{
      
     }
     Operand_Name{
      
     }
     Element{
      
     }
     Reg_class{
      
     }

    }
    8{
     MSB{
      3
     }
     LSB{
      0
     }
     FieldType{
      Operand
     }
     FieldAttr{
      name
     }
     Value{
      imm
     }
     Addr_mode{
      Immediate_data
     }
     Operand_Name{
      imm
     }
     Element{
      Immediate
     }
     Reg_class{
      
     }

    }

   }
   BaseProcessor{
    false
   }

  }

 }
 Instruction{
  LB  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    LB
   }
   Id{
    159
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000100000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    LB rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  LBU  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    LBU
   }
   Id{
    83
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000100010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    LBU rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  LH  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    LH
   }
   Id{
    84
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000100100
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    LH rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  LHU  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    LHU
   }
   Id{
    85
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000100110
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    LHU rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  LW  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    LW
   }
   Id{
    86
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000101000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    LW rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  DLW  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    DLW
   }
   Id{
    87
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000101001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    DLW rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  L_S  #1{
   Type{
    I  #1
   }
   Valid{
    false
   }
   Name{
    L_S
   }
   Id{
    88
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000101010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    L_S rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  L_D  #1{
   Type{
    I  #1
   }
   Valid{
    false
   }
   Name{
    L_D
   }
   Id{
    89
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000101011
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    L_D rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  LWL  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    LWL
   }
   Id{
    90
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000101100
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    LWL rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  LWR  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    LWR
   }
   Id{
    91
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000101101
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    LWR rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  SB  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    SB
   }
   Id{
    92
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000110000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    SB rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  SH  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    SH
   }
   Id{
    93
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000110010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    SH rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  SW  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    SW
   }
   Id{
    156
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000110100
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    SW rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  DSW  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    DSW
   }
   Id{
    94
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000110101
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    DSW rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  S_S  #1{
   Type{
    I  #1
   }
   Valid{
    false
   }
   Name{
    S_S
   }
   Id{
    95
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000110110
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    S_S rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  S_D  #1{
   Type{
    I  #1
   }
   Valid{
    false
   }
   Name{
    S_D
   }
   Id{
    96
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000110111
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    S_D rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  DSZ  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    DSZ
   }
   Id{
    97
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000111000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    DSZ rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  SWL  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    SWL
   }
   Id{
    98
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000111001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    SWL rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  SWR  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    SWR
   }
   Id{
    99
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000111010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    SWR rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  LB_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    LB_RR
   }
   Id{
    100
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011000000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    LB_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  LBU_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    LBU_RR
   }
   Id{
    101
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011000001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    LBU_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  LH_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    LH_RR
   }
   Id{
    102
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011000010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    LH_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  LHU_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    LHU_RR
   }
   Id{
    105
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011000011
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    LHU_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  LW_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    LW_RR
   }
   Id{
    104
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011000100
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    LW_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  DLW_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    DLW_RR
   }
   Id{
    103
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011001110
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    DLW_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  L_S_RR  #1{
   Type{
    R  #1
   }
   Valid{
    false
   }
   Name{
    L_S_RR
   }
   Id{
    107
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011000101
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    L_S_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  L_D_RR  #1{
   Type{
    R  #1
   }
   Valid{
    false
   }
   Name{
    L_D_RR
   }
   Id{
    106
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011001111
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    L_D_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SB_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SB_RR
   }
   Id{
    108
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011000110
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SB_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SH_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SH_RR
   }
   Id{
    109
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011000111
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SH_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SW_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SW_RR
   }
   Id{
    110
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011001000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SW_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  DSW_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    DSW_RR
   }
   Id{
    111
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011010000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    DSW_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  DSZ_RR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    DSZ_RR
   }
   Id{
    112
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011010001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    DSZ_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  S_S_RR  #1{
   Type{
    R  #1
   }
   Valid{
    false
   }
   Name{
    S_S_RR
   }
   Id{
    113
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011001001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    S_S_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  S_D_RR  #1{
   Type{
    R  #1
   }
   Valid{
    false
   }
   Name{
    S_D_RR
   }
   Id{
    114
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011010010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    S_D_RR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  JUMP  #1{
   Type{
    J  #1
   }
   Valid{
    true
   }
   Name{
    JUMP
   }
   Id{
    115
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000000001
    }
    3{
     000000
    }
    4{
     targ
    }

   }
   Format{
    JUMP targ
   }
   BaseProcessor{
    false
   }

  }
  JAL  #1{
   Type{
    J  #1
   }
   Valid{
    true
   }
   Name{
    JAL
   }
   Id{
    116
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000000010
    }
    3{
     000000
    }
    4{
     targ
    }

   }
   Format{
    JAL targ
   }
   BaseProcessor{
    false
   }

  }
  JR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    JR
   }
   Id{
    117
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000000011
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    JR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  JALR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    JALR
   }
   Id{
    118
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000000100
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    JALR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  BEQ  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    BEQ
   }
   Id{
    119
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000000101
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    BEQ rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  BNE  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    BNE
   }
   Id{
    120
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000000110
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    BNE rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  BLEZ  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    BLEZ
   }
   Id{
    121
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000000111
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    BLEZ rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  BGTZ  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    BGTZ
   }
   Id{
    122
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000001000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    BGTZ rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  BLTZ  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    BLTZ
   }
   Id{
    158
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000001001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    BLTZ rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  BGEZ  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    BGEZ
   }
   Id{
    123
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000001010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    BGEZ rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  ADD  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    ADD
   }
   Id{
    124
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001000000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    ADD rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  ADDI  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    ADDI
   }
   Id{
    125
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001000001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    ADDI rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  ADDU  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    ADDU
   }
   Id{
    126
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001000010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    ADDU rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  ADDIU  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    ADDIU
   }
   Id{
    127
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001000011
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    ADDIU rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  SUB  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SUB
   }
   Id{
    128
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001000100
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SUB rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SUBU  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SUBU
   }
   Id{
    129
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001000101
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SUBU rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  MULT  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    MULT
   }
   Id{
    130
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001000110
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    MULT rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  MULTU  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    MULTU
   }
   Id{
    131
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001000111
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    MULTU rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  DIV  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    DIV
   }
   Id{
    132
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001001000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    DIV rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  DIVU  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    DIVU
   }
   Id{
    133
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001001001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    DIVU rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  MFHI  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    MFHI
   }
   Id{
    134
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001001010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    MFHI rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  MTHI  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    MTHI
   }
   Id{
    135
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001001011
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    MTHI rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  MFLO  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    MFLO
   }
   Id{
    136
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001001100
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    MFLO rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  MTLO  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    MTLO
   }
   Id{
    137
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001001101
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    MTLO rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  AND  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    AND
   }
   Id{
    138
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001001110
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    AND rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  ANDI  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    ANDI
   }
   Id{
    139
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001001111
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    ANDI rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  OR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    OR
   }
   Id{
    140
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001010000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    OR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  ORI  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    ORI
   }
   Id{
    141
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001010001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    ORI rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  XOR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    XOR
   }
   Id{
    142
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001010010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    XOR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  XORI  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    XORI
   }
   Id{
    143
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001010011
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    XORI rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  NOR  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    NOR
   }
   Id{
    144
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001010100
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    NOR rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SLL  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SLL
   }
   Id{
    145
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001010101
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SLL rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SLLV  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SLLV
   }
   Id{
    146
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001010110
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SLLV rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SRL  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SRL
   }
   Id{
    147
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001010111
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SRL rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SRLV  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SRLV
   }
   Id{
    157
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001011000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SRLV rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SRA  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SRA
   }
   Id{
    148
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001011001
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SRA rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SRAV  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SRAV
   }
   Id{
    149
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001011010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SRAV rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SLT  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SLT
   }
   Id{
    150
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001011011
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SLT rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SLTI  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    SLTI
   }
   Id{
    153
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001011100
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    SLTI rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  SLTU  #1{
   Type{
    R  #1
   }
   Valid{
    true
   }
   Name{
    SLTU
   }
   Id{
    151
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001011101
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     000
    }
    8{
     rd
    }
    9{
     shamt
    }

   }
   Format{
    SLTU rs rt rd shamt
   }
   BaseProcessor{
    false
   }

  }
  SLTIU  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    SLTIU
   }
   Id{
    152
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000001011110
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    SLTIU rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  NOP  #1{
   Type{
    INH  #1
   }
   Valid{
    true
   }
   Name{
    NOP
   }
   Id{
    76
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000000000000
    }
    3{
     00000000000000000000000000000000
    }

   }
   Format{
    NOP
   }
   BaseProcessor{
    false
   }

  }
  LUI  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    LUI
   }
   Id{
    154
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000010100010
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    LUI rs rt imm
   }
   BaseProcessor{
    false
   }

  }
  SYSCALL  #1{
   Type{
    INH  #1
   }
   Valid{
    true
   }
   Name{
    SYSCALL
   }
   Id{
    78
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000010100000
    }
    3{
     00000000000000000000000000000000
    }

   }
   Format{
    SYSCALL
   }
   BaseProcessor{
    false
   }

  }
  BREAK  #1{
   Type{
    INH  #1
   }
   Valid{
    true
   }
   Name{
    BREAK
   }
   Id{
    79
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000010100001
    }
    3{
     00000000000000000000000000000000
    }

   }
   Format{
    BREAK
   }
   BaseProcessor{
    false
   }

  }
  SYSRET  #1{
   Type{
    INH  #1
   }
   Valid{
    true
   }
   Name{
    SYSRET
   }
   Id{
    80
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0000000011111111
    }
    3{
     00000000000000000000000000000000
    }

   }
   Format{
    SYSRET
   }
   BaseProcessor{
    false
   }

  }
  LBm  #1{
   Type{
    I  #1
   }
   Valid{
    true
   }
   Name{
    LBm
   }
   Id{
    183
   }
   EditField{
    1{
     0000000000000000
    }
    2{
     0101000000100000
    }
    3{
     000
    }
    4{
     rs
    }
    5{
     000
    }
    6{
     rt
    }
    7{
     imm
    }

   }
   Format{
    LBm rs rt imm
   }
   BaseProcessor{
    false
   }

  }

 }

}
OperationDesc{
 Complete{
  OFF
 }
 InstBehavior{
  
 }
 ExceptionBehavior{
  reset{
   valid{
    true
   }
   type{
    Reset
   }
   cycle{
    1
   }
   description{
    
   }
   assertion{
    
   }
   comment{
    
   }
   condition{
    condition_type{
     Unselected
    }
    Reset{
     valid{
      true
     }
     active_value{
      1
     }

    }

   }
   mask{
    maskable{
     NO
    }
    register_name{
     Unselected
    }
    position{
     
    }
    register_value{
     
    }

   }

  }
  int_recovery{
   valid{
    false
   }
   type{
    Internal
   }
   cycle{
    1
   }
   description{
    
   }
   assertion{
    
   }
   comment{
    
   }
   condition{
    condition_type{
     instr_specific
    }

   }
   mask{
    maskable{
     NO
    }
    register_name{
     Unselected
    }
    position{
     
    }
    register_value{
     
    }

   }

  }

 }

}
CdefinitionDecl{
 Complete{
  OFF
 }
 C_data_type{
  0{
   type{
    char
   }
   alignment{
    8
   }
   size{
    8
   }

  }
  1{
   type{
    short
   }
   alignment{
    16
   }
   size{
    16
   }

  }
  2{
   type{
    int
   }
   alignment{
    32
   }
   size{
    32
   }

  }
  3{
   type{
    long
   }
   alignment{
    32
   }
   size{
    32
   }

  }
  4{
   type{
    float
   }
   alignment{
    32
   }
   size{
    32
   }

  }
  5{
   type{
    double
   }
   alignment{
    64
   }
   size{
    64
   }

  }
  6{
   type{
    pointer
   }
   alignment{
    32
   }
   size{
    32
   }

  }
  7{
   type{
    struct
   }
   alignment{
    8
   }
   size{
    none
   }

  }
  8{
   type{
    stack
   }
   alignment{
    32
   }
   size{
    none
   }

  }
  9{
   type{
    data
   }
   alignment{
    8
   }
   size{
    none
   }

  }

 }
 Data_macro{
  
 }
 C_ckf_prototype{
  
 }

}
MOD{
 Complete{
  ON
 }
 Common{
  COMMON{
   
  }

 }
 Instruction{
  LB  #1{
   id{
    159
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DEST(rs,imm)
   }
   3{
    xLOAD(ld_8)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LBU  #1{
   id{
    83
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DEST(rs,imm)
   }
   3{
    xLOAD(ldu_8)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LH  #1{
   id{
    84
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DEST(rs,imm)
   }
   3{
    xLOAD(ld_16)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LHU  #1{
   id{
    85
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DEST(rs,imm)
   }
   3{
    xLOAD(ldu_16)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LW  #1{
   id{
    86
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DEST(rs,imm)
   }
   3{
    xLOAD(ld_32)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  DLW  #1{
   id{
    87
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DEST(rs,imm)
   }
   3{
    xLOAD2(ld_32)
   }
   4{
    
   }
   5{
    
   }
   6{
    null = GPR.write0(rt,bigE_word0);
null = GPR.write1(nextRT,bigE_word1);
   }

  }
  L_S  #1{
   id{
    88
   }
   variable{
    
   }
   1{
    
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  L_D  #1{
   id{
    89
   }
   variable{
    
   }
   1{
    
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LWL  #1{
   id{
    90
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READEXT1DEST(rs,rt,imm)
   }
   3{
    xLOADL()
   }
   4{
    
   }
   5{
    
   }
   6{
    xWRITEBACK(rt, result)
FW1WB(rt,result)
   }

  }
  LWR  #1{
   id{
    91
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READEXT1DEST(rs,rt,imm)
   }
   3{
    xLOADR()
   }
   4{
    
   }
   5{
    
   }
   6{
    xWRITEBACK(rt, result)
FW1WB(rt, result)
   }

  }
  SB  #1{
   id{
    92
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READEXT(rs,rt,imm)
   }
   3{
    xstore(s_8)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  SH  #1{
   id{
    93
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READEXT(rs,rt,imm)
   }
   3{
    xstore(s_16)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  SW  #1{
   id{
    156
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READEXT(rs,rt,imm)
   }
   3{
    xstore(s_32)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  DSW  #1{
   id{
    94
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR3READEXT(rs,rt,imm)
   }
   3{
    xstore2(s_32)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  S_S  #1{
   id{
    95
   }
   variable{
    
   }
   1{
    
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  S_D  #1{
   id{
    96
   }
   variable{
    
   }
   1{
    
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  DSZ  #1{
   id{
    97
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READEXTZ(rs,imm)
   }
   3{
    xstore2z()
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  SWL  #1{
   id{
    98
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READEXT(rs,rt,imm)
   }
   3{
    storeL()
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  SWR  #1{
   id{
    99
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READEXT(rs,rt,imm)
   }
   3{
    storeR()
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LB_RR  #1{
   id{
    100
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ2xDEST(rs,rd)
   }
   3{
    xLOAD(ld_8)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LBU_RR  #1{
   id{
    101
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ2xDEST(rs,rd)
   }
   3{
    xLOAD(ldu_8)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LH_RR  #1{
   id{
    102
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ2xDEST(rs,rd)
   }
   3{
    xLOAD(ld_16)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LHU_RR  #1{
   id{
    105
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ2xDEST(rs,rd)
   }
   3{
    xLOAD(ldu_16)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LW_RR  #1{
   id{
    104
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ2xDEST(rs,rd)
   }
   3{
    xLOAD(ld_32)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  DLW_RR  #1{
   id{
    103
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ2xDEST(rs,rd)
   }
   3{
    xLOAD2(ld_32)
   }
   4{
    
   }
   5{
    
   }
   6{
    null = GPR.write0(rt,bigE_word0);
null = GPR.write1(nextRT,bigE_word1);
   }

  }
  L_S_RR  #1{
   id{
    107
   }
   variable{
    
   }
   1{
    
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  L_D_RR  #1{
   id{
    106
   }
   variable{
    
   }
   1{
    
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  SB_RR  #1{
   id{
    108
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR3READ(rs,rt,rd)
   }
   3{
    xstore(s_8)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  SH_RR  #1{
   id{
    109
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR3READ(rs,rt,rd)
   }
   3{
    xstore(s_16)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  SW_RR  #1{
   id{
    110
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR3READ(rs,rt,rd)
   }
   3{
    xstore(s_32)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  DSW_RR  #1{
   id{
    111
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR4READ(rs,rt,rd)
   }
   3{
    xstore2(s_32)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  DSZ_RR  #1{
   id{
    112
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR3READZ(rs,rd)
   }
   3{
    xstore2z()
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  S_S_RR  #1{
   id{
    113
   }
   variable{
    
   }
   1{
    
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  S_D_RR  #1{
   id{
    114
   }
   variable{
    
   }
   1{
    
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  JUMP  #1{
   id{
    115
   }
   variable{
    wire [31:0] result;
   }
   1{
    FETCH()
   }
   2{
    wire [31:0] tmp_cpc;
wire [1:0] const;
wire [3:0] cpc_top;
wire zero1b0;
wire one1b0;

one1b0 = '1';
zero1b0 = '0';
const = \"00\";
tmp_cpc = CPC.read();
cpc_top = tmp_cpc[31:28];
result = <cpc_top,targ,const>;
   }
   3{
    null = CPC.write(result);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  JAL  #1{
   id{
    116
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xJUMPADDRLNK()
   }
   3{
    FW1EXE(linkReg,link)
   }
   4{
    FW1MEM1(linkReg,link)
   }
   5{
    FW1MEM2(linkReg,link)
   }
   6{
    xWRITEBACK(linkReg,link)
FW1WB(linkReg,link)
   }

  }
  JR  #1{
   id{
    117
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xJUMPREG(rs)
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  JALR  #1{
   id{
    118
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xJUMPREGLNK(rs)
   }
   3{
    FW1EXE(linkReg,link)
   }
   4{
    FW1MEM1(linkReg,link)
   }
   5{
    FW1MEM2(linkReg,link)
   }
   6{
    xWRITEBACK(linkReg,link)
FW1WB(linkReg,link)
   }

  }
  BEQ  #1{
   id{
    119
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ(rs,rt)
   }
   3{
    xEQ(==)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  BNE  #1{
   id{
    120
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ(rs,rt)
   }
   3{
    xEQ(!=)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  BLEZ  #1{
   id{
    121
   }
   variable{
    wire [31:0] target;
wire [31:0] src0;
   }
   1{
    FETCH()
   }
   2{
    wire [31:0] tmp_source0;
wire [31:0] tmp_cpc;
wire cout;
wire [31:0] offset;
wire [31:0] ext_imm;
wire [29:0] tmp;
wire [1:0] zero2;
wire cin;


tmp_source0 = GPR.read0(rs);
src0 = FWU0.forward(rs,tmp_source0);
cin = '0';
zero2 = \"00\";
ext_imm = EXT1.sign(imm);
tmp = ext_imm[29:0];
offset = <tmp,zero2>;
tmp_cpc = CPC.read();
<target,cout> = ADD1.adc(tmp_cpc,offset,cin);
   }
   3{
    wire cond_tmp;
wire cond;
wire [3:0] flag;
wire N;
wire Z;

flag = ALU1.cmpz(src0);
N = flag[1];
Z = flag[2];
cond_tmp = N|Z;
cond = cond_tmp == '1';
null = [cond] CPC.write(target);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  BGTZ  #1{
   id{
    122
   }
   variable{
    wire [31:0] src0;
wire [31:0] target;
   }
   1{
    FETCH()
   }
   2{
    wire [31:0] tmp_source0;
wire [31:0] tmp_cpc;
wire cout;
wire [31:0] offset;
wire [31:0] ext_imm;
wire [29:0] tmp;
wire [1:0] zero2;
wire cin;



tmp_source0 = GPR.read0(rs);
src0 = FWU0.forward(rs,tmp_source0);
cin = '0';
zero2 = \"00\";
ext_imm = EXT1.sign(imm);
tmp = ext_imm[29:0];
offset = <tmp,zero2>;
tmp_cpc = CPC.read();
<target,cout> = ADD1.adc(tmp_cpc,offset,cin);
   }
   3{
    wire cond_tmp;
wire cond;
wire [3:0] flag;
wire N;
wire Z;

flag = ALU1.cmpz(src0);
N = flag[1];
Z = flag[2];
cond_tmp = N|Z;
cond = cond_tmp != '1';
null = [cond] CPC.write(target);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  BLTZ  #1{
   id{
    158
   }
   variable{
    wire [31:0] src0;
wire [31:0] target;
   }
   1{
    FETCH()
   }
   2{
    wire [31:0] tmp_source0;
wire [31:0] tmp_cpc;
wire cout;
wire [31:0] offset;
wire [31:0] ext_imm;
wire [29:0] tmp;
wire [1:0] zero2;
wire cin;



tmp_source0 = GPR.read0(rs);
src0 = FWU0.forward(rs,tmp_source0);
cin = '0';
zero2 = \"00\";
ext_imm = EXT1.sign(imm);
tmp = ext_imm[29:0];
offset = <tmp,zero2>;
tmp_cpc = CPC.read();
<target,cout> = ADD1.adc(tmp_cpc,offset,cin);
   }
   3{
    xCMPN(==)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  BGEZ  #1{
   id{
    123
   }
   variable{
    wire [31:0] src0;
wire [31:0] target;
   }
   1{
    FETCH()
   }
   2{
    wire [31:0] tmp_source0;
wire [31:0] tmp_cpc;
wire cout;
wire [31:0] offset;
wire [31:0] ext_imm;
wire [29:0] tmp;
wire [1:0] zero2;
wire cin;



tmp_source0 = GPR.read0(rs);
src0 = FWU0.forward(rs,tmp_source0);
cin = '0';
zero2 = \"00\";
ext_imm = EXT1.sign(imm);
tmp = ext_imm[29:0];
offset = <tmp,zero2>;
tmp_cpc = CPC.read();
<target,cout> = ADD1.adc(tmp_cpc,offset,cin);
   }
   3{
    xCMPN(!=)
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  ADD  #1{
   id{
    124
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xALUEXEC(add,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  ADDI  #1{
   id{
    125
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DEST(rs,imm)
   }
   3{
    xALUEXEC(add,source0,source1)
FW1EXE(rt,result)
   }
   4{
    FW1MEM1(rt,result)
   }
   5{
    FW1MEM2(rt,result)
   }
   6{
    xWRITEBACK(rt,result)
FW1WB(rt,result)
   }

  }
  ADDU  #1{
   id{
    126
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xALUEXEC(addu,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  ADDIU  #1{
   id{
    127
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DEST(rs,imm)
   }
   3{
    xALUEXEC(addu,source0,source1)
FW1EXE(rt,result)
   }
   4{
    FW1MEM1(rt,result)
   }
   5{
    FW1MEM2(rt,result)
   }
   6{
    xWRITEBACK(rt,result)
FW1WB(rt,result)
   }

  }
  SUB  #1{
   id{
    128
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xALUEXEC(sub,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SUBU  #1{
   id{
    129
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xALUEXEC(subu,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  MULT  #1{
   id{
    130
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READHILODEST(rs,rt)
   }
   3{
    xMULTEXEC(mul,source0,source1)
null = LO.write(resultlo);
null = HI.write(resulthi);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  MULTU  #1{
   id{
    131
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READHILODEST(rs,rt)
   }
   3{
    xMULTEXEC(mulu,source0,source1)
null = LO.write(resultlo);
null = HI.write(resulthi);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  DIV  #1{
   id{
    132
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READHILODEST(rs,rt)
   }
   3{
    xDIVEXEC(div,source0,source1)

null = LO.write(resultlo);
null = HI.write(resulthi);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  DIVU  #1{
   id{
    133
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READHILODEST(rs,rt)
   }
   3{
    xDIVEXEC(divu,source0,source1)

null = LO.write(resultlo);
null = HI.write(resulthi);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  MFHI  #1{
   id{
    134
   }
   variable{
    wire [31:0] result;
   }
   1{
    FETCH()
   }
   2{
    wire zero1b;
wire one1b0;

one1b0 = '1';
zero1b = '0';
result = HI.read();
   }
   3{
    FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  MTHI  #1{
   id{
    135
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READ1DEST(rs)
   }
   3{
    null = HI.write(source0);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  MFLO  #1{
   id{
    136
   }
   variable{
    wire [31:0] result;
   }
   1{
    FETCH()
   }
   2{
    wire zero1b;
wire one1b0;

one1b0 = '1';
zero1b = '0';
result = LO.read();
   }
   3{
    FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  MTLO  #1{
   id{
    137
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READ1DEST(rs)
   }
   3{
    null = LO.write(source0);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  AND  #1{
   id{
    138
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xALUEXEC(and,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  ANDI  #1{
   id{
    139
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DESTU(rs,imm)
   }
   3{
    xALUEXEC(and,source0,source1)
FW1EXE(rt,result)
   }
   4{
    FW1MEM1(rt,result)
   }
   5{
    FW1MEM2(rt,result)
   }
   6{
    xWRITEBACK(rt,result)
FW1WB(rt,result)
   }

  }
  OR  #1{
   id{
    140
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xALUEXEC(or,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  ORI  #1{
   id{
    141
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DESTU(rs,imm)
   }
   3{
    xALUEXEC(or,source0,source1)
FW1EXE(rt,result)
   }
   4{
    FW1MEM1(rt,result)
   }
   5{
    FW1MEM2(rt,result)
   }
   6{
    xWRITEBACK(rt,result)
FW1WB(rt,result)
   }

  }
  XOR  #1{
   id{
    142
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xALUEXEC(xor,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  XORI  #1{
   id{
    143
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DESTU(rs,imm)
   }
   3{
    xALUEXEC(xor,source0,source1)
FW1EXE(rt,result)
   }
   4{
    FW1MEM1(rt,result)
   }
   5{
    FW1MEM2(rt,result)
   }
   6{
    xWRITEBACK(rt,result)
FW1WB(rt,result)
   }

  }
  NOR  #1{
   id{
    144
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xALUEXEC(nor,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SLL  #1{
   id{
    145
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READ21DEST(rt,shamt)
   }
   3{
    xSFTEXEC(sll,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SLLV  #1{
   id{
    146
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xSFTEXEC(sll,source1,source0) /*rs has the shamt*/
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SRL  #1{
   id{
    147
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READ21DEST(rt,shamt)
   }
   3{
    xSFTEXEC(srl,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SRLV  #1{
   id{
    157
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xSFTEXEC(srl,source1,source0)/*rs -> source1 has the shamt*/
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SRA  #1{
   id{
    148
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READ21DEST(rt,shamt)
   }
   3{
    xSFTEXEC(sra,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SRAV  #1{
   id{
    149
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)

/*GPR2READ1DEST(rs,rt,rd,\"01\")*/
   }
   3{
    xSFTEXEC(sra,source1,source0)/*rs -> source1 has the shamt*/
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SLT  #1{
   id{
    150
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xLT(cmp,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SLTI  #1{
   id{
    153
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DEST(rs,imm)
   }
   3{
    xLT(cmp,source0,source1)
FW1EXE(rt,result)
   }
   4{
    FW1MEM1(rt,result)
   }
   5{
    FW1MEM2(rt,result)
   }
   6{
    xWRITEBACK(rt,result)
FW1WB(rt,result)
   }

  }
  SLTU  #1{
   id{
    151
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR2READ1DEST(rs,rt)
   }
   3{
    xLTU(cmpu,source0,source1)
FW1EXE(rd,result)
   }
   4{
    FW1MEM1(rd,result)
   }
   5{
    FW1MEM2(rd,result)
   }
   6{
    xWRITEBACK(rd,result)
FW1WB(rd,result)
   }

  }
  SLTIU  #1{
   id{
    152
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    xGPR1READEXT1DESTU(rs,imm)
   }
   3{
    xLTU(cmpu,source0,source1)
FW1EXE(rt,result)
   }
   4{
    FW1MEM1(rt,result)
   }
   5{
    FW1MEM2(rt,result)
   }
   6{
    xWRITEBACK(rt,result)
FW1WB(rt,result)
   }

  }
  NOP  #1{
   id{
    76
   }
   variable{
    
   }
   1{
    FETCH()
   }
   2{
    
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LUI  #1{
   id{
    154
   }
   variable{
    wire [31:0] result;
   }
   1{
    FETCH()
   }
   2{
    wire [15:0] zero16;

zero16 = \"0000000000000000\";
result = <imm,zero16>;
   }
   3{
    FW1EXE(rt,result)
   }
   4{
    FW1MEM1(rt,result)
   }
   5{
    FW1MEM2(rt,result)
   }
   6{
    xWRITEBACK(rt,result)
FW1WB(rt,result)
   }

  }
  SYSCALL  #1{
   id{
    78
   }
   variable{
    wire [31:0] tmp_cpc;
   }
   1{
    FETCH()
   }
   2{
    tmp_cpc = CPC.read();
   }
   3{
    wire [31:0] result;

result = \"00000000000000000000000001100000\";
null = SYSREG.write(tmp_cpc);
null = CPC.write(result);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  BREAK  #1{
   id{
    79
   }
   variable{
    wire[31:0] tmp_cpc;
   }
   1{
    FETCH()
   }
   2{
    tmp_cpc = CPC.read();
   }
   3{
    wire [31:0] result;

null = SYSREG.write(tmp_cpc);
result = \"00000000000000000000000000110000\";
null = CPC.write(result);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  SYSRET  #1{
   id{
    80
   }
   variable{
    wire[31:0] result;
   }
   1{
    FETCH()
   }
   2{
    result = SYSREG.read();
   }
   3{
    null = CPC.write(result);
   }
   4{
    
   }
   5{
    
   }
   6{
    
   }

  }
  LBm  #1{
   id{
    183
   }
   variable{
    wire[31:0] source0;
wire[31:0] source1;
wire[31:0] addr;
wire[31:0] bigE_word;
wire [31:0] tmp_pc;
   }
   1{
    wire[31:0] current_pc;
wire iramaddr_err; 
wire[63:0] inst0;

current_pc = CPC.read();
tmp_pc=current_pc;
<inst0,iramaddr_err> = Imem.ld_64(current_pc);
null = IReg.write(inst0);
null = CPC.inc();
   }
   2{
    wire[31:0] tmp_source0;

tmp_source0 = GPR.read0(rs);
source0 = FWUL0.forward(rs,tmp_source0);
//collect event regf read
source1 = EXT1.sign(imm);
   }
   3{
    wire[3:0] flag;

<addr,flag> = ALU1.add(source0,source1);
null = FWUL0.lock1(rt);
null = FWUL1.lock1(rt);
null = FWUL2.lock1(rt);
null = FWUL3.lock1(rt);
   }
   4{
    wire addr_err;
wire[31:0] result;
wire [7:0] byte0;
wire [7:0] byte1;
wire [7:0] byte2;
wire [7:0] byte3;

<result,addr_err> = Dmem.ld_8(addr);
byte0 = result[31:24];
byte1 = result[23:16];
byte2 = result[15:8];
byte3 = result[7:0];
bigE_word = <byte3, byte2, byte1, byte0>;
//collect event mem read
null = FWUL0.forward3(rt,bigE_word);
null = FWUL1.forward3(rt,bigE_word);
null = FWUL2.forward3(rt,bigE_word);
null = FWUL3.forward3(rt,bigE_word);
null = FWUL0.lock3(rt);
null = FWUL1.lock3(rt);
null = FWUL2.lock3(rt);
null = FWUL3.lock3(rt);
   }
   5{
    null = FWUL0.forward5(rt,bigE_word);
null = FWUL1.forward5(rt,bigE_word);
null = FWUL2.forward5(rt,bigE_word);
null = FWUL3.forward5(rt,bigE_word);
   }
   6{
    null = GPR.write0(rt,bigE_word);
//collect event regf write
null = FWUL0.forward7(rt,bigE_word);
null = FWUL1.forward7(rt,bigE_word);
null = FWUL2.forward7(rt,bigE_word);
   }

  }

 }
 Exception{
  reset{
   variable{
    
   }
   1{
    null = IReg.reset();
null = CPC.reset();
null = GPR.reset();
   }

  }
  int_recovery{
   variable{
    wire [31:0] addr;
wire one1b;
   }
   1{
    addr = \"00000000001000000000000000011000\"; //recovery segment address
one1b = '1';
null  = CPC.write(addr);
null = MASKREG0.write(one1b);
   }

  }

 }
 Macro{
  xGPR1READEXT1DEST(arg1,arg2){
   variable{
    wire[31:0] source0;
wire[31:0] source1;
   }
   1{
    wire[31:0] tmp_source0;

tmp_source0 = GPR.read0(arg1);
source0 = FWUL0.forward(arg1,tmp_source0);
source1 = EXT1.sign(arg2);
   }
   BaseProcessor{
    false
   }

  }
  xLOAD(ope){
   variable{
    wire[31:0] addr;
wire[31:0] bigE_word;
   }
   1{
    wire[3:0] flag;

<addr,flag> = ALU1.add(source0,source1);
null = FWUL0.lock1(rt);
null = FWUL1.lock1(rt);
null = FWUL2.lock1(rt);
null = FWUL3.lock1(rt);
   }
   2{
    wire addr_err;
wire[31:0] result;

<result,addr_err> = Dmem.ope(addr);
CONVERT0(result, bigE_word)

FW1MEM1(rt,bigE_word)
null = FWUL0.lock3(rt);
null = FWUL1.lock3(rt);
null = FWUL2.lock3(rt);
null = FWUL3.lock3(rt);
   }
   3{
    FW1MEM2(rt,bigE_word)
   }
   4{
    null = GPR.write0(rt,bigE_word);
FW1WB(rt,bigE_word)
   }
   BaseProcessor{
    false
   }

  }
  xLOAD2(ope){
   variable{
    wire [31:0] addr1;
wire [31:0] addr2;
wire [31:0] bigE_word0;
wire [31:0] bigE_word1;
wire [4:0] nextRT;
   }
   1{
    wire [3:0] flag;
wire [3:0] tmpRT;
wire one;

<addr1,flag> = ALU1.add(source0,source1);

one ='1';
tmpRT = rt[4:1];
nextRT = <tmpRT,one>;
null = FWUL0.lock1(rt);
null = FWUL1.lock1(rt);
null = FWUL2.lock1(rt);
null = FWUL3.lock1(rt);
null = FWUL0.lock2(nextRT);
null = FWUL1.lock2(nextRT);
null = FWUL2.lock2(nextRT);
null = FWUL3.lock2(nextRT);
   }
   2{
    wire cout;
wire cin;
wire [31:0] four32bit;
wire addr_err;
wire [31:0] result1;

cin = '0';
four32bit = \"00000000000000000000000000000100\";

<result1,addr_err> = Dmem.ope(addr1);
CONVERT0(result1,bigE_word0)
FW1MEM1(rt,bigE_word0)
<addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
null = FWUL0.lock3(rt);
null = FWUL1.lock3(rt);
null = FWUL2.lock3(rt);
null = FWUL3.lock3(rt);
null = FWUL0.lock4(nextRT);
null = FWUL1.lock4(nextRT);
null = FWUL2.lock4(nextRT);
null = FWUL3.lock4(nextRT);
   }
   3{
    wire addr_err;
wire [31:0] result2;


<result2,addr_err> = Dmem.ope(addr2);
CONVERT0(result2,bigE_word1)
FW2MEM2(rt,nextRT,bigE_word0,bigE_word1)
null = FWUL0.lock5(nextRT);
null = FWUL1.lock5(nextRT);
null = FWUL2.lock5(nextRT);
null = FWUL3.lock5(nextRT);
   }
   4{
    FW2WB(rt,nextRT,bigE_word0,bigE_word1)
   }
   BaseProcessor{
    false
   }

  }
  FW1EXE(reg,result){
   variable{
    
   }
   1{
    null = FWUL0.forward1(reg,result);
null = FWUL1.forward1(reg,result);
null = FWUL2.forward1(reg,result);
null = FWUL3.forward1(reg,result);
   }
   BaseProcessor{
    false
   }

  }
  FW2EXE(reg1,reg2,result1,result2){
   variable{
    
   }
   1{
    null = FWUL0.forward1(reg1,result1);
null = FWUL1.forward1(reg1,result1);
null = FWUL2.forward1(reg1,result1);
null = FWUL3.forward1(reg1,result1);

null = FWUL0.forward2(reg2,result2);
null = FWUL1.forward2(reg2,result2);
null = FWUL2.forward2(reg2,result2);
null = FWUL3.forward2(reg2,result2);
   }
   BaseProcessor{
    false
   }

  }
  FW1MEM1(reg,result){
   variable{
    
   }
   1{
    null = FWUL0.forward3(reg,result);
null = FWUL1.forward3(reg,result);
null = FWUL2.forward3(reg,result);
null = FWUL3.forward3(reg,result);
   }
   BaseProcessor{
    false
   }

  }
  FW2MEM1(reg1,reg2,result1,result2){
   variable{
    
   }
   1{
    null = FWUL0.forward3(reg1,result1);
null = FWUL1.forward3(reg1,result1);
null = FWUL2.forward3(reg1,result1);
null = FWUL3.forward3(reg1,result1);

null = FWUL0.forward4(reg2,result2);
null = FWUL1.forward4(reg2,result2);
null = FWUL2.forward4(reg2,result2);
null = FWUL3.forward4(reg2,result2);
   }
   BaseProcessor{
    false
   }

  }
  FW1MEM2(reg,result){
   variable{
    
   }
   1{
    null = FWUL0.forward5(reg,result);
null = FWUL1.forward5(reg,result);
null = FWUL2.forward5(reg,result);
null = FWUL3.forward5(reg,result);
   }
   BaseProcessor{
    false
   }

  }
  FW2MEM2(reg1,reg2,result1,result2){
   variable{
    
   }
   1{
    null = FWUL0.forward5(reg1,result1);
null = FWUL1.forward5(reg1,result1);
null = FWUL2.forward5(reg1,result1);
null = FWUL3.forward5(reg1,result1);
null = FWUL0.forward6(reg2,result2);
null = FWUL1.forward6(reg2,result2);
null = FWUL2.forward6(reg2,result2);
null = FWUL3.forward6(reg2,result2);
   }
   BaseProcessor{
    false
   }

  }
  FW1WB(reg,result){
   variable{
    
   }
   1{
    null = FWUL0.forward7(reg,result);
null = FWUL1.forward7(reg,result);
null = FWUL2.forward7(reg,result);
null = FWUL3.forward7(reg,result);
   }
   BaseProcessor{
    false
   }

  }
  FW2WB(reg1,reg2,result1,result2){
   variable{
    
   }
   1{
    null = FWUL0.forward7(reg1,result1);
null = FWUL1.forward7(reg1,result1);
null = FWUL2.forward7(reg1,result1);
null = FWUL3.forward7(reg1,result1);
null = FWUL0.forward8(reg2,result2);
null = FWUL1.forward8(reg2,result2);
null = FWUL2.forward8(reg2,result2);
null = FWUL3.forward8(reg2,result2);
   }
   BaseProcessor{
    false
   }

  }
  xGPR2READEXT1DEST(arg1,arg2,arg3){
   variable{
    wire[31:0] source0;
wire[31:0] source1;
wire[31:0] source2;
   }
   1{
    wire[31:0] tmp_source0;
wire[31:0] tmp_source1;

tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(arg2);
source2 = EXT1.sign(arg3);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(arg2,tmp_source1);
   }
   BaseProcessor{
    false
   }

  }
  xLOADL(){
   variable{
    wire[31:0] addr;
wire[31:0] result;
   }
   1{
    wire[3:0] flag;

<addr,flag> = ALU1.add(source0, source2);
null = FWUL0.lock1(rt);
null = FWUL1.lock1(rt);
null = FWUL2.lock1(rt);
null = FWUL3.lock1(rt);
   }
   2{
    wire[29:0] addr_mask;
wire[1:0] zero2;
wire[31:0] target;
wire[31:0] data;
wire addr_err;
wire[1:0] vAddr10;
wire[7:0] data2;
wire[7:0] data1;
wire[7:0] data0;
wire[7:0] reg2;
wire[7:0] reg1;
wire[7:0] reg0;
wire[31:0] result3;
wire[31:0] result2;
wire[31:0] result1;
wire[31:0] result0;
wire[31:0] bigE_data;
wire [7:0] byte0;
wire [7:0] byte1;
wire [7:0] byte2;
wire [7:0] byte3;


addr_mask = addr[31:2];
vAddr10 = addr[1:0];
zero2 = \"00\";
target = <addr_mask,zero2>;

<data,addr_err> = Dmem.ld_32(target);

byte0 = data[31:24];
byte1 = data[23:16];
byte2 = data[15:8];
byte3 = data[7:0];
bigE_data = <byte3, byte2, byte1, byte0>;

data2 = bigE_data[23:16];
data1 = bigE_data[15:8];
data0 = bigE_data[7:0];
reg2 = source1[23:16];
reg1 = source1[15:8];
reg0 = source1[7:0];

result0 = <data0, reg2, reg1, reg0>;
result1 = <data1, data0, reg1, reg0>;
result2 = <data2, data1, data0, reg0>;
result3 = bigE_data;
result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);

null = FWUL0.forward3(rt,result);
null = FWUL1.forward3(rt,result);
null = FWUL2.forward3(rt,result);
null = FWUL3.forward3(rt,result);
null = FWUL0.lock3(rt);
null = FWUL1.lock3(rt);
null = FWUL2.lock3(rt);
null = FWUL3.lock3(rt);
   }
   3{
    null = FWUL0.forward5(rt,result);
null = FWUL1.forward5(rt,result);
null = FWUL2.forward5(rt,result);
null = FWUL3.forward5(rt,result);
   }
   BaseProcessor{
    false
   }

  }
  xWRITEBACK(arg1,arg2){
   variable{
    
   }
   1{
    null = GPR.write0(arg1,arg2);
   }
   BaseProcessor{
    false
   }

  }
  xLOADR(){
   variable{
    wire[31:0] addr;
wire[31:0] result;
   }
   1{
    wire[3:0] flag;

<addr,flag> = ALU1.add(source0, source2);
null = FWUL0.lock1(rt);
null = FWUL1.lock1(rt);
null = FWUL2.lock1(rt);
null = FWUL3.lock1(rt);
   }
   2{
    wire[29:0] addr_mask;
wire[1:0] zero2;
wire[31:0] target;
wire[31:0] data;
wire addr_err;
wire[1:0] vAddr10;
wire[7:0] data3;
wire[7:0] data2;
wire[7:0] data1;
wire[7:0] reg3;
wire[7:0] reg2;
wire[7:0] reg1;
wire[31:0] result3;
wire[31:0] result2;
wire[31:0] result1;
wire[31:0] result0;
wire[31:0] bigE_data;


addr_mask = addr[31:2];
vAddr10 = addr[1:0];
zero2 = \"00\";
target = <addr_mask,zero2>;

<data,addr_err> = Dmem.ld_32(target);
CONVERT0(data, bigE_data)
data3 = bigE_data[31:24];
data2 = bigE_data[23:16];
data1 = bigE_data[15:8];
reg3 = source1[31:24];
reg2 = source1[23:16];
reg1 = source1[15:8];

result3 = <reg3, reg2, reg1, data3>;
result2 = <reg3, reg2, data3, data2>;
result1 = <reg3, data3, data2, data1>;
result0 = bigE_data;
result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);

null = FWUL0.forward3(rt,result);
null = FWUL1.forward3(rt,result);
null = FWUL2.forward3(rt,result);
null = FWUL3.forward3(rt,result);
null = FWUL0.lock3(rt);
null = FWUL1.lock3(rt);
null = FWUL2.lock3(rt);
null = FWUL3.lock3(rt);
   }
   3{
    null = FWUL0.forward5(rt,result);
null = FWUL1.forward5(rt,result);
null = FWUL2.forward5(rt,result);
null = FWUL3.forward5(rt,result);
   }
   BaseProcessor{
    false
   }

  }
  xGPR2READEXT(arg1,arg2,arg3){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
wire [31:0] source2;
   }
   1{
    wire [31:0] tmp_source0;
wire [31:0] tmp_source1;

tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(arg2);
source2 = EXT1.sign(arg3);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(arg2,tmp_source1);
   }
   BaseProcessor{
    false
   }

  }
  xSTORE(ope){
   variable{
    wire [31:0] addr;
   }
   1{
    wire [3:0] flag;

<addr,flag> = ALU1.add(source0,source2);
   }
   2{
    wire addr_err;

addr_err = Dmem.ope(addr,source1);
   }
   BaseProcessor{
    false
   }

  }
  xGPR3READEXT(arg1,arg2,arg3){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
wire [31:0] source2;
wire [31:0] source3;
   }
   1{
    wire [31:0] tmp_source0;
wire [31:0] tmp_source1;
wire [31:0] tmp_source3;
wire [4:0] rt2;
wire [3:0] oldrt;
wire one;

one = '1';
oldrt = arg2[4:1];
rt2 = <oldrt,one>;
tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(arg2);
tmp_source3 = GPR.read2(rt2);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(arg2,tmp_source1);
source2 = EXT1.sign(arg3);
source3 = FWUL2.forward(rt2,tmp_source3);
   }
   BaseProcessor{
    false
   }

  }
  xSTORE2(ope){
   variable{
    wire [31:0] addr1;
wire [31:0] addr2;
   }
   1{
    wire [3:0] flag;

<addr1, flag> = ALU1.add(source0,source2);
   }
   2{
    wire addr_err;
wire cin;
wire cout;
wire [31:0] four32bit;
wire [31:0] LE_source1;

cin = '1';
four32bit = \"00000000000000000000000000000100\";
<addr2,cout> = ADDER2.adc(addr1,four32bit,cin);

CONVERT0(source1, LE_source1)
addr_err = Dmem.ope(addr1,LE_source1);
   }
   3{
    wire addr_err;
wire [31:0] LE_source3;

CONVERT0(source3, LE_source3)
addr_err = Dmem.ope(addr2,LE_source3);
   }
   BaseProcessor{
    false
   }

  }
  xGPR2READEXTZ(arg1,arg2){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
wire [31:0] source2;
   }
   1{
    wire [4:0] zero5;
wire [31:0] tmp_source0;
wire [31:0] tmp_source1;

zero5 = \"00000\";
tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(zero5);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(zero5,tmp_source1);
source2 = EXT1.sign(arg2);
   }
   BaseProcessor{
    false
   }

  }
  xSTORE2Z(){
   variable{
    wire [31:0] addr1;
wire [31:0] addr2;
wire [31:0] LE_source1;
   }
   1{
    wire [3:0] flag;

<addr1,flag> = ALU1.add(source0,source2);
   }
   2{
    wire addr_err;
wire cin;
wire cout;
wire [31:0] four32bit;

cin = '1';
four32bit =\"00000000000000000000000000000100\";
<addr2,cout> = ADDER2.adc(addr1,four32bit,cin);

CONVERT0(source1, LE_source1)
addr_err = Dmem.s_32(addr1, LE_source1);
   }
   3{
    wire addr_err;

addr_err = Dmem.s_32(addr2, LE_source1);
   }
   BaseProcessor{
    false
   }

  }
  xSTOREL(){
   variable{
    wire [31:0] addr;
wire [31:0] result;
   }
   1{
    wire [3:0] flag;

<addr,flag> = ALU1.add(source0,source2);
   }
   2{
    wire [29:0] addr_mask;
wire [1:0] zero2;
wire [31:0] target;
wire [31:0] data;
wire addr_err;
wire addr1;
wire addr0;
wire [7:0] data3;
wire [7:0] data2;
wire [7:0] data1;
wire [7:0] reg3;
wire [7:0] reg2;
wire [7:0] reg1;
wire [31:0] result3;
wire [31:0] result2;
wire [31:0] result1;
wire [31:0] result0;
wire [31:0] result01;
wire [31:0] result23;

addr_mask = addr[31:2];
addr1 = addr[1];
addr0 = addr[0];
zero2 = \"00\";
target = <addr_mask, zero2>;

<data,addr_err> = Dmem.ld_32(target);
data3 = data[31:24];
data2 = data[23:16];
data1 = data[15:8];
reg3 = source1[31:24];
reg2 = source1[23:16];
reg1 = source[15:8];

result3 = <data3,reg3,reg2,reg1>;
result2 = <data3,data2,reg3,reg2>;
result1 = <data3,data2,data1,reg3>;
result0 = source1;

result01 = (addr0)?result1:result0;
result23 = (addr0)?result3:result2;
result = (addr1)?result23:result01;
   }
   3{
    wire addr_err;
wire [29:0] addr_mask;
wire [1:0] zero2;
wire [31:0] target;

addr_mask = addr[31:2];
zero2 = \"00\";
target = <addr_mask,zero2>;

addr_err = Dmem.store(target,result);
   }
   BaseProcessor{
    false
   }

  }
  xSTORER(){
   variable{
    wire [31:0] addr;
wire [31:0] result;
   }
   1{
    wire [3:0] flag;

<addr,flag> = ALU1.add(source0,source2);
   }
   2{
    wire [29:0] addr_mask;
wire [1:0] zero2;
wire [31:0] target;
wire [31:0] data;
wire addr_err;
wire addr1;
wire addr0;
wire [7:0] data2;
wire [7:0] data1;
wire [7:0] data0;
wire [7:0] reg2;
wire [7:0] reg1;
wire [7:0] reg0;
wire [31:0] result3;
wire [31:0] result2;
wire [31:0] result1;
wire [31:0] result0;
wire [31:0] result01;
wire [31:0] result23;

addr_mask = addr[31:2];
addr1 = addr[1];
addr0 = addr[0];
zero2 = \"00\";
target = <addr_mask, zero2>;

<data,addr_err> = Dmem.ld_32(target);
data3 = data[23:16];
data2 = data[15:8];
data1 = data[7:0];
reg3 = source1[23:16];
reg2 = source1[15:8];
reg1 = source[7:0];

result3 = source1;
result2 = <reg2,reg1,reg0,data0>;
result1 = <reg1,reg0,data1,data0>;
result0 = <reg0,data2,data1,data0>;

result01 = (addr0)?result1:result0;
result23 = (addr0)?result3:result2;
result = (addr1)?result23:result01;
   }
   3{
    wire addr_err;
wire [29:0] addr_mask;
wire [1:0] zero2;
wire [31:0] target;

addr_mask = addr[31:2];
zero2 = \"00\";
target = <addr_mask,zero2>;

addr_err = Dmem.store(target,result);
   }
   BaseProcessor{
    false
   }

  }
  xGPR2READ2xDEST(arg1,arg2){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
   }
   1{
    wire [31:0] tmp_source0;
wire [31:0] tmp_source1;

tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(arg2);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(arg2,tmp_source1);
   }
   BaseProcessor{
    false
   }

  }
  xGPR3READ(arg1,arg2,arg3){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
wire [31:0] source2;
   }
   1{
    wire [31:0] tmp_source0;
wire [31:0] tmp_source1;
wire [31:0] tmp_source2;

tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(arg2);
tmp_source2 = GPR.read2(arg3);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(arg2,tmp_source1);
source2 = FWUL2.forward(arg3,tmp_source2);
   }
   BaseProcessor{
    false
   }

  }
  xGPR4READ(arg1,arg2,arg3){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
wire [31:0] source2;
wire [31:0] source3;
   }
   1{
    wire [4:0] rt2;
wire [3:0] oldrt;
wire one;
wire [31:0] tmp_source0;
wire [31:0] tmp_source1;
wire [31:0] tmp_source2;
wire [31:0] tmp_source3;

one = '1';
oldrt = arg2[4:1];
rt2 = <oldrt,one>;
tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(arg2);
tmp_source2 = GPR.read2(arg3);
tmp_source3 = GPR.read3(rt2);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(arg2,tmp_source1);
source2 = FWUL2.forward(arg3,tmp_source2);
source3 = FWUL3.forward(rt2,tmp_source3);
   }
   BaseProcessor{
    false
   }

  }
  xGPR3READZ(arg1,arg2){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
wire [31:0] source2;
   }
   1{
    wire [4:0] zero5;
wire [31:0] tmp_source0;
wire [31:0] tmp_source1;
wire [31:0] tmp_source2;

zero5 = \"00000\";
tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(zero5);
tmp_source2 = GPR.read2(arg2);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(zero5,tmp_source1);
source2 = FWUL2.forward(arg2,tmp_source2);
   }
   BaseProcessor{
    false
   }

  }
  xJUMPADDRLNK(){
   variable{
    wire [31:0] link;
wire [4:0] linkReg;
wire [31:0] result;
   }
   1{
    wire [31:0] tmp_cpc;
wire [1:0] const;
wire [3:0] cpc_top;

const = \"00\";
tmp_cpc = CPC.read();
link = tmp_cpc;
cpc_top = tmp_cpc[31:28];
result = <cpc_top,targ,const>;
linkReg = \"11111\";
   }
   2{
    null = CPC.write(result);
   }
   3{
    
   }
   4{
    
   }
   5{
    
   }
   BaseProcessor{
    false
   }

  }
  xJUMPREG(arg){
   variable{
    wire [31:0] target;
   }
   1{
    wire [31:0] tmp_source;

tmp_source = GPR.read0(arg);
target = FWUL0.forward(arg,tmp_source);
   }
   2{
    null =CPC.write(target);
   }
   BaseProcessor{
    false
   }

  }
  xJUMPREGLNK(arg){
   variable{
    wire [31:0] target;
wire [31:0] link;
wire [4:0] linkReg;
   }
   1{
    wire [31:0] tmp_source;

link = CPC.read();
tmp_source = GPR.read0(arg);
target = FWUL0.forward(arg,tmp_source);
   }
   2{
    null = CPC.write(target);
linkReg = \"11111\";
   }
   BaseProcessor{
    false
   }

  }
  xGPR2READ(arg1,arg2){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
wire [31:0] target;
   }
   1{
    wire [31:0] tmp_source0;
wire [31:0] tmp_source1;
wire cin;
wire cout;
wire [1:0] zero2;
wire [31:0] ext_imm;
wire [29:0] tmp;
wire [31:0] offset;
wire [31:0] tmp_cpc;


tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(arg2);
source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(arg2,tmp_source1);
cin = '0';
zero2 = \"00\";
ext_imm = EXT1.sign(imm);
tmp = ext_imm[29:0];
offset = <tmp,zero2>;
tmp_cpc = CPC.read();
<target,cout> = ADD1.adc(tmp_cpc,offset,cin);
   }
   BaseProcessor{
    false
   }

  }
  xEQ(ope){
   variable{
    
   }
   1{
    wire zero;
wire cond;
wire [3:0] flag;

flag = ALU1.cmp(source0,source1);
zero = flag[2];
cond = zero ope'1';
null = [cond] CPC.write(target);
   }
   BaseProcessor{
    false
   }

  }
  xGPR1READ(arg){
   variable{
    wire [31:0] source0;
wire [31:0] target;
   }
   1{
    wire [31:0] tmp_source0;
wire [31:0] tmp_cpc;
wire cout;
wire [31:0] offset;
wire [31:0] ext_imm;
wire [29:0] tmp;
wire [1:0] zero2;
wire cin;


tmp_source0 = GPR.read0(arg);
source0 = FWUL0.forward(arg,tmp_source0);
cin = '0';
zero2 = \"00\";
ext_imm = EXT1.sign(imm);
tmp = ext_imm[29:0];
offset = <tmp,zero2>;
tmp_cpc = CPC.read();
<target,cout> = ADD1.adc(tmp_cpc,offset,cin);
   }
   BaseProcessor{
    false
   }

  }
  xCMPNZ(ope){
   variable{
    
   }
   1{
    wire cond_tmp;
wire cond;
wire [3:0] flag;
wire N;
wire Z;

flag = ALU1.cmpz(source0);
N = flag[1];
Z = flag[2];
cond_tmp = N|Z;
cond = cond_tmp ope '1';
null = [cond] CPC.write(target);
   }
   BaseProcessor{
    false
   }

  }
  xCMPN(ope){
   variable{
    
   }
   1{
    wire cond;
wire [3:0] flag;
wire N;


flag = ALU1.cmpz(src0);
N = flag[1];
cond = N ope '1';
null = [cond] CPC.write(target);
   }
   BaseProcessor{
    false
   }

  }
  xGPR2READ1DEST(arg1,arg2){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
   }
   1{
    wire [31:0] tmp_source0;
wire [31:0] tmp_source1;

tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(arg2);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(arg2,tmp_source1);
   }
   BaseProcessor{
    false
   }

  }
  xALUEXEC(ope,arg1,arg2){
   variable{
    wire [31:0] result;
   }
   1{
    wire [3:0] flag;

<result,flag> = ALU1.ope(arg1,arg2);
   }
   BaseProcessor{
    false
   }

  }
  xGPR2READHILODEST(arg1,arg2){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
   }
   1{
    wire [31:0] tmp_source0;
wire [31:0] tmp_source1;

tmp_source0 = GPR.read0(arg1);
tmp_source1 = GPR.read1(arg2);

source0 = FWUL0.forward(arg1,tmp_source0);
source1 = FWUL1.forward(arg2,tmp_source1);
   }
   BaseProcessor{
    false
   }

  }
  xMULTEXEC(ope,arg1,arg2){
   variable{
    wire [31:0] resulthi;
wire [31:0] resultlo;
wire [63:0] result;
   }
   1{
    result = MUL1.ope(arg1,arg2);
resulthi = result[63:32];
resultlo = result[31:0];
   }
   BaseProcessor{
    false
   }

  }
  xWRITEHILO2(){
   variable{
    
   }
   1{
    null = LO.write(resultlo);
null = HI.write(resulthi);
   }
   BaseProcessor{
    false
   }

  }
  xDIVEXEC(ope,arg1,arg2){
   variable{
    wire [31:0] resulthi;
wire [31:0] resultlo;
   }
   1{
    wire flag;

<resultlo,resulthi,flag> = DIV1.ope(arg1,arg2);
   }
   BaseProcessor{
    false
   }

  }
  xREADHILO(arg1,arg2){
   variable{
    wire [31:0] result;
   }
   1{
    result = arg1.read();
   }
   2{
    
   }
   BaseProcessor{
    false
   }

  }
  xGPR1READ1DEST(arg){
   variable{
    wire [31:0] source0;
   }
   1{
    wire [31:0] tmp_source0;

tmp_source0 = GPR.read0(arg);
source0 = FWUL0.forward(arg,tmp_source0);
   }
   BaseProcessor{
    false
   }

  }
  xGPR1READEXT1DESTU(arg1,arg2){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
   }
   1{
    wire [31:0] tmp_source0;

tmp_source0 = GPR.read0(arg1);
source0 = FWUL0.forward(arg1,tmp_source0);
source1 = EXT1.zero(arg2);
   }
   BaseProcessor{
    false
   }

  }
  xGPR1READ21DEST(arg1,arg2){
   variable{
    wire [31:0] source0;
wire [31:0] source1;
   }
   1{
    wire [31:0] tmp_source0;
wire [23:0] zero24;

zero24 = \"000000000000000000000000\";

tmp_source0 = GPR.read0(arg1);
source0 = FWUL0.forward(arg1,tmp_source0);
source1 = <zero24,arg2>;
   }
   BaseProcessor{
    false
   }

  }
  xSFTEXEC(ope,arg1,arg2){
   variable{
    wire [31:0] result;
   }
   1{
    wire [4:0] shift;

shift = arg2[4:0];
result = SFT1.ope(arg1,shift);
   }
   BaseProcessor{
    false
   }

  }
  xLT(ope,arg1,arg2){
   variable{
    wire [31:0] result;
   }
   1{
    wire [3:0] flag;
wire [1:0] flag2;
wire NnV;
wire VnN;
wire cond;
wire [30:0] zero31;

zero31 = \"0000000000000000000000000000000\";

flag = ALU1.ope(arg1,arg2);
flag2 = flag[1:0];

NnV = flag2 == \"10\";
VnN = flag == \"1001\";
cond = NnV | VnN;
result = <zero31,cond>;
   }
   BaseProcessor{
    false
   }

  }
  xLTU(ope,arg1,arg2){
   variable{
    wire [31:0] result;
   }
   1{
    wire [3:0] flag;
wire [1:0] flag2;
wire cond;
wire [30:0] zero31;

zero31 = \"0000000000000000000000000000000\";

flag = ALU1.ope(arg1,arg2);
flag2 = flag[3:2];
cond = flag2 == \"00\";
result = <zero31,cond>;
   }
   BaseProcessor{
    false
   }

  }
  xJUMPADDR(){
   variable{
    
   }
   1{
    wire [31:0] tmp_cpc;
wire [1:0] const;
wire [31:0] result;
wire [3:0] cpc_top;


const = \"00\";
tmp_cpc = CPC.read();
cpc_top = tmp_cpc[31:28];
result = <cpc_top,targ,const>;
null = /*[chkValid]*/ CPC.write(result);
//if valid then go on elsecall interrupt.
/*[chkInvalid] throw int_recovery;*/
   }
   2{
    
   }
   BaseProcessor{
    false
   }

  }
  nonCFIBBchk(){
   variable{
    wire [31:0] IncHashedReg0;
wire [31:0] IncHashedReg1;
wire [31:0] IncHashedReg2;
   }
   1{
    IncHashedReg0 = IncHashedReg.read();

callXOR0(IncHashedReg0,IncHashedReg1,inst_h)
callXOR1(IncHashedReg1,IncHashedReg2,inst_l)

null = IncHashedReg.write(IncHashedReg2);
   }
   BaseProcessor{
    false
   }

  }
  CFIBBchk(currPC){
   variable{
    /*wire [31:0] IncHashedReg;*/
wire [31:0] hashedReg;
wire valid;
wire one;
wire chkInvalid;//cond_int
wire chkValid;
wire [31:0] IncHashedReg0;
wire [31:0] IncHashedReg1;
wire [31:0] IncHashedReg2;
   }
   1{
    wire chkflag;
wire tmpvar0;
wire tmpvar1;
wire tmpvar2;

//IncHashedReg = IncHashedReg.read();
IncHashedReg0 = IncHashedReg.read();
callXOR0(IncHashedReg0,IncHashedReg1,inst_h)
callXOR1(IncHashedReg1,IncHashedReg2,inst_l)
hashedReg = hashedReg.read();
//valid = COMP32.cmp(IncHashedReg,hashedReg);
chkflag = chkflag.read();
valid = COMP32.cmp(IncHashedReg2,hashedReg);
tmpvar0 = ~valid;
tmpvar1 = '0';
tmpvar2 = '1';
chkInvalid = (chkflag)?tmpvar0:tmpvar1;
chkValid = (chkflag)?valid:tmpvar2;
one = '1';
null = [chkflag]CheckedBB.write(one);
null = [chkflag]PC_bot.write(tmp_pc);
null=chkflag.reset();
   }
   BaseProcessor{
    false
   }

  }
  lblBBchk(){
   variable{
    
   }
   1{
    wire one1b;

null = IncHashedReg.reset();
/*null = hashedReg.write(inst_l); endian stuff*/
null = hashedReg.write(inst_h);
null = CheckedBB.reset();
null = bufflag.reset();
null = crc.reset();
null = RFC.reset();
null = PC_head.write(tmp_pc);
null = PC_bot.reset();
null = HI_flag.reset();
null = LO_flag.reset();
one1b = '1';
null = chkflag.write(one1b);
   }
   BaseProcessor{
    false
   }

  }
  memBoundChk(tgt,currPC){
   variable{
    
   }
   1{
    
   }
   BaseProcessor{
    false
   }

  }
  callXOR0(A,A0,B){
   variable{
    wire [31:0] notA0;
wire [31:0] notB0;
wire [31:0] tmp10;
wire [31:0] tmp20;
   }
   1{
    notA0 = ~A;
notB0 = ~B;

tmp10 = A & notB0;
tmp20 = notA0 & B;

A0 = tmp10|tmp20;
   }
   BaseProcessor{
    false
   }

  }
  callXOR1(A,A0,B){
   variable{
    wire [31:0] notA1;
wire [31:0] notB1;
wire [31:0] tmp11;
wire [31:0] tmp21;
   }
   1{
    notA1 = ~A;
notB1 = ~B;

tmp11 = A & notB1;
tmp21 = notA1 & B;

A0 = tmp11|tmp21;
   }
   BaseProcessor{
    false
   }

  }
  buffinGPR(arg){
   variable{
    wire [31:0] tmp_buffin;
wire [31:0] tmp_flag;
   }
   1{
    wire [31:0] var_flag;
wire [31:0] pre_flag;
wire [4:0] flag_sel;
wire a0;
wire a1;
wire a2;
wire a3;
wire a4;
wire a5;
wire a6;
wire a7;
wire a8;
wire a9;
wire a10;
wire a11;
wire a12;
wire a13;
wire a14;
wire a15;
wire a16;
wire a17;
wire a18;
wire a19;
wire a20;
wire a21;
wire a22;
wire a23;
wire a24;
wire a25;
wire a26;
wire a27;
wire a28;
wire a29;
wire a30;
wire a31;
wire cond0;
wire cond1;

tmp_buffin = GPR.read2(arg);
flag_sel = arg;
pre_flag = bufflag.read();
a0 = flag_sel == \"00000\";
a1 = flag_sel == \"00001\";
a2 = flag_sel == \"00010\";
a3 = flag_sel == \"00011\";
a4 = flag_sel == \"00100\";
a5 = flag_sel == \"00101\";
a6 = flag_sel == \"00110\";
a7 = flag_sel == \"00111\";
a8 = flag_sel == \"01000\";
a9 = flag_sel == \"01001\";
a10 = flag_sel == \"01010\";
a11 = flag_sel == \"01011\";
a12 = flag_sel == \"01100\";
a13 = flag_sel == \"01101\";
a14 = flag_sel == \"01110\";
a15 = flag_sel == \"01111\";
a16 = flag_sel == \"10000\";
a17 = flag_sel == \"10001\";
a18 = flag_sel == \"10010\";
a19 = flag_sel == \"10011\";
a20 = flag_sel == \"10100\";
a21 = flag_sel == \"10101\";
a22 = flag_sel == \"10110\";
a23 = flag_sel == \"10111\";
a24 = flag_sel == \"11000\";
a25 = flag_sel == \"11001\";
a26 = flag_sel == \"11010\";
a27 = flag_sel == \"11011\";
a28 = flag_sel == \"11100\";
a29 = flag_sel == \"11101\";
a30 = flag_sel == \"11110\";
a31 = flag_sel == \"11111\";
var_flag = <a31,a30,a29,a28,a27,a26,a25,a24,a23,a22,a21,a20,a19,a18,a17,a16,a15,a14,a13,a12,a11,a10,a9,a8,a7,a6,a5,a4,a3,a2,a1,a0>;
tmp_flag = var_flag | pre_flag;
cond0 = COMP32.cmp(tmp_flag,pre_flag);
cond1 = ~ cond0;
null = [cond1] bufflag.write(tmp_flag);
null = [cond1] testbuffer.write0(flag_sel,tmp_buffin);
   }
   2{
    
   }
   BaseProcessor{
    false
   }

  }
  bufflagmasking(arg){
   variable{
    wire buf2gpr_con0;
wire buf2gpr_con1;
   }
   1{
    wire [1:0] mux_in0;
wire [1:0] mux_in1;
wire [1:0] mux_in2;
wire [1:0] mux_in3;
wire [1:0] mux_in4;
wire [1:0] mux_in5;
wire [1:0] mux_in6;
wire [1:0] mux_in7;
wire [1:0] mux_in8;
wire [1:0] mux_in9;
wire [1:0] mux_in10;
wire [1:0] mux_in11;
wire [1:0] mux_in12;
wire [1:0] mux_in13;
wire [1:0] mux_in14;
wire [1:0] mux_in15;
wire [1:0] mux_out;
wire [3:0] mux_sel;
wire [31:0] flag_v;

flag_v = bufflag.read();
mux_in0 = flag_v[1:0];
mux_in1 = flag_v[3:2];
mux_in2 = flag_v[5:4];
mux_in3 = flag_v[7:6];
mux_in4 = flag_v[9:8];
mux_in5 = flag_v[11:10];
mux_in6 = flag_v[13:12];
mux_in7 = flag_v[15:14];
mux_in8 = flag_v[17:16];
mux_in9 = flag_v[19:18];
mux_in10 = flag_v[21:20];
mux_in11 = flag_v[23:22];
mux_in12 = flag_v[25:24];
mux_in13 = flag_v[27:26];
mux_in14 = flag_v[29:28];
mux_in15 = flag_v[31:30];
mux_sel = arg;
mux_out = MUX0.sel(mux_in0,mux_in1,mux_in2,mux_in3,mux_in4,mux_in5,mux_in6,mux_in7,mux_in8,mux_in9,mux_in10,mux_in11,mux_in12,mux_in13,mux_in14,mux_in15,mux_sel);

buf2gpr_con0 = mux_out[0];
buf2gpr_con1 = mux_out[1];
   }
   2{
    
   }
   BaseProcessor{
    false
   }

  }
  cpc21(arg){
   variable{
    wire [31:0] real_cpc;
wire cond_cpc;
wire [31:0] rolb_addr;
   }
   1{
    rolb_addr = \"00000000001000000000000000000000\"; 
cond_cpc = ~valid;
real_cpc = (cond_cpc)?rolb_addr:arg;
//this macro is not used any more
   }
   2{
    
   }
   BaseProcessor{
    false
   }

  }
  xstore(ope){
   variable{
    wire [31:0] addr;
   }
   1{
    wire [3:0] flag;

<addr,flag> = ALU1.add(source0,source2);
   }
   2{
    
   }
   3{
    wire addr_err;
wire [31:0] LE_source1;

CONVERT0(source1,LE_source1)
addr_err = Dmem.ope(addr,LE_source1 /*source1*/);
   }
   BaseProcessor{
    false
   }

  }
  dmemckpt(ope){
   variable{
    wire [31:0] ramaddr;
   }
   1{
    null = [chkflag] crc.inc();
ramaddr = [chkflag] crc.read();
   }
   2{
    wire [31:0] data32b;
wire addrerr;
wire one1b;
wire [63:0] data64b;

<data32b,addrerr> = [chkflag] Dmem.ope(addr);
one1b = '1';
data64b = <addr,data32b>;
null = [chkflag] req2buf.write(one1b);
null = [chkflag] rw2buf.write(one1b);
null = [chkflag] data2buf.write(data64b);
null = [chkflag] addr2buf.write(ramaddr);
   }
   BaseProcessor{
    false
   }

  }
  xstore2(ope){
   variable{
    wire [31:0] addr1;
wire [31:0] addr2;
   }
   1{
    wire [3:0] flag;
wire cin;
wire cout;
wire [31:0] four32bit;

<addr1, flag> = ALU1.add(source0,source2);
cin = '1';
four32bit = \"00000000000000000000000000000100\";
<addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
   }
   2{
    
   }
   3{
    wire addr_err;
wire [31:0] LE_source1;

CONVERT0(source1, LE_source1)
addr_err = Dmem.ope(addr1,LE_source1 /*source1*/);
   }
   4{
    wire addr_err;
wire [31:0] LE_source3;

CONVERT0(source3, LE_source3)
addr_err = Dmem.ope(addr2,LE_source3 /*source3*/);
   }
   BaseProcessor{
    false
   }

  }
  dmemckpt2(ope){
   variable{
    
   }
   1{
    wire [31:0] data32b;
wire addrerr;
wire one1b;
wire [63:0] data64b;
wire [31:0] ramaddr;

null = [chkflag] crc.inc();
ramaddr = [chkflag] crc.read();
<data32b,addrerr> = [chkflag] Dmem.ope(addr1);
one1b = '1';
data64b = <addr1,data32b>;
null = [chkflag] req2buf.write(one1b);
null = [chkflag] rw2buf.write(one1b);
null = [chkflag] data2buf.write(data64b);
null = [chkflag] addr2buf.write(ramaddr);
   }
   2{
    wire [31:0] data32b;
wire addrerr;
wire one1b;
wire [63:0] data64b;
wire [31:0] ramaddr;

null = [chkflag] crc.inc();
ramaddr = [chkflag] crc.read();
<data32b,addrerr> = [chkflag] Dmem.ope(addr2);
one1b = '1';
data64b = <addr2,data32b>;
null = [chkflag] req2buf.write(one1b);
null = [chkflag] rw2buf.write(one1b);
null = [chkflag] data2buf.write(data64b);
null = [chkflag] addr2buf.write(ramaddr);
   }
   3{
    
   }
   BaseProcessor{
    false
   }

  }
  xstore2z(ope){
   variable{
    wire [31:0] addr1;
wire [31:0] addr2;
   }
   1{
    wire [3:0] flag;

<addr1,flag> = ALU1.add(source0,source2);
   }
   2{
    wire cin;
wire cout;
wire [31:0] four32bit;

cin = '1';
four32bit =\"00000000000000000000000000000100\";
<addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
   }
   3{
    wire addr_err;

addr_err = Dmem.s_32(addr1,source1);
   }
   4{
    wire addr_err;

addr_err = Dmem.s_32(addr2,source1);
   }
   BaseProcessor{
    false
   }

  }
  xwritehilo2(){
   variable{
    wire [31:0] hi_tmp;
wire [31:0] lo_tmp;
wire cond0;
wire cond1;
   }
   1{
    wire hi_flag;
wire lo_flag;

hi_tmp = HI.read();
lo_tmp = LO.read();
hi_flag = HI_flag.read();
lo_flag = LO_flag.read();
cond0 = ~ hi_flag;
cond1 = ~ lo_flag;
   }
   2{
    wire one1b;

one1b = '1';
null = [cond0] HI_bak.write(hi_tmp);
null = [cond0] HI_flag.write(one1b);
null = [cond1] LO_bak.write(lo_tmp);
null = [cond1] LO_flag.write(one1b);
null = LO.write(resultlo);
null = HI.write(resulthi);
   }
   BaseProcessor{
    false
   }

  }
  RFwrite(arg){
   variable{
    
   }
   1{
    wire [63:0] data64b;
wire [31:0] reg00;
wire [31:0] pre_flag;
wire [31:0] tmp_flag;
wire chk_flag;
/**/
wire [26:0] zero27b;
wire [31:0] reg01;
wire [31:0] reg02;
wire [31:0] var_flag;
wire [4:0] flag_sel;
wire a0;
wire a1;
wire a2;
wire a3;
wire a4;
wire a5;
wire a6;
wire a7;
wire a8;
wire a9;
wire a10;
wire a11;
wire a12;
wire a13;
wire a14;
wire a15;
wire a16;
wire a17;
wire a18;
wire a19;
wire a20;
wire a21;
wire a22;
wire a23;
wire a24;
wire a25;
wire a26;
wire a27;
wire a28;
wire a29;
wire a30;
wire a31;
/**/
wire cond0;
wire cond1;
wire one1b;
wire cond2;

chk_flag = chkflag.read();
zero27b = \"000000000000000000000000000\";
flag_sel = arg;
pre_flag = [chk_flag] bufflag.read();
a0 = flag_sel == \"00000\";
a1 = flag_sel == \"00001\";
a2 = flag_sel == \"00010\";
a3 = flag_sel == \"00011\";
a4 = flag_sel == \"00100\";
a5 = flag_sel == \"00101\";
a6 = flag_sel == \"00110\";
a7 = flag_sel == \"00111\";
a8 = flag_sel == \"01000\";
a9 = flag_sel == \"01001\";
a10 = flag_sel == \"01010\";
a11 = flag_sel == \"01011\";
a12 = flag_sel == \"01100\";
a13 = flag_sel == \"01101\";
a14 = flag_sel == \"01110\";
a15 = flag_sel == \"01111\";
a16 = flag_sel == \"10000\";
a17 = flag_sel == \"10001\";
a18 = flag_sel == \"10010\";
a19 = flag_sel == \"10011\";
a20 = flag_sel == \"10100\";
a21 = flag_sel == \"10101\";
a22 = flag_sel == \"10110\";
a23 = flag_sel == \"10111\";
a24 = flag_sel == \"11000\";
a25 = flag_sel == \"11001\";
a26 = flag_sel == \"11010\";
a27 = flag_sel == \"11011\";
a28 = flag_sel == \"11100\";
a29 = flag_sel == \"11101\";
a30 = flag_sel == \"11110\";
a31 = flag_sel == \"11111\";
var_flag = <a31,a30,a29,a28,a27,a26,a25,a24,a23,a22,a21,a20,a19,a18,a17,a16,a15,a14,a13,a12,a11,a10,a9,a8,a7,a6,a5,a4,a3,a2,a1,a0>;
tmp_flag = var_flag | pre_flag;
one1b = '1'; 
cond0 = [chk_flag]COMP32.cmp(tmp_flag,pre_flag);
cond1 = ~ cond0;
cond2 = cond1 & chk_flag;
//cond2 flags on backup execution

reg00 = [cond2] RFC.read();
null = [cond2] RFC.inc();
reg01 = [cond2] GPR.read2(arg);
//add forwarding here, updated 23/11/10
reg02 = [cond2] FWU4.forward(arg,reg01);
data64b = <arg,zero27b,reg02>;
null = [cond2]RFRAMreq.write(one1b);
null = [cond2]bufflag.write(tmp_flag);
null = [cond2]RFRAMrw.write(one1b);
null = [cond2]RFRAMaddr.write(reg00);
null = [cond2]RFRAMdout.write(data64b);
   }
   2{
    
   }
   BaseProcessor{
    false
   }

  }
  INSTR0(){
   variable{
    wire [31:0] tmp_pc;
wire[63:0] inst0;
wire[63:0] inst1;
   }
   1{
    wire[31:0] current_pc;
wire iramaddr_err; 
wire iromaddr_err;
/*wire[63:0] inst0;*/
/*wire[63:0] inst1;*/

current_pc = CPC.read();
//NORMAL situation, MASK is off
<inst0,iramaddr_err> = Imem.ld_64(current_pc);
//null = IROM_addr.write(current_pc);
//inst1 = IROM_data.read();
//ERROR situation, MASK is on
<inst1,iromaddr_err> = if_irom.ld_64(current_pc);//new added 5.11
/*
null = IReg0.write(inst0);
null = IReg1.write(inst1);
*/
tmp_pc = current_pc;
   }
   BaseProcessor{
    false
   }

  }
  INSTR1(){
   variable{
    wire [31:0] inst_h;
wire [31:0] inst_l;
   }
   1{
    wire[63:0] inst;
wire cond0_instr;
/*wire[63:0] inst2;*/
/*wire[63:0] inst3;*/

cond0_instr = MASKREG0.read();
/*
inst2 = IReg0.read();
inst3 = IReg1.read();
inst = (cond0_instr)?inst2:inst3;
*/
inst = (cond0_instr)?inst1:inst0;//updated 22/11/2010
null = IReg.write(inst);
null = CPC.inc();
inst_h = inst[31:0];
inst_l = inst[63:32];
   }
   BaseProcessor{
    false
   }

  }
  JumpAndLink(){
   variable{
    wire [31:0] link;
wire [4:0] linkReg;
wire [31:0] result;
wire [31:0] ra_pc;/*return address*/
   }
   1{
    ra_pc = CPC.read();
   }
   2{
    wire [1:0] const;
wire [3:0] cpc_top;

const = \"00\";
link = ra_pc;
cpc_top = ra_pc[31:28];
result = <cpc_top,targ,const>;
linkReg = \"11111\";
   }
   3{
    null = /*[chkValid]*/CPC.write(result);
[chkInvalid] throw int_recovery;
   }
   BaseProcessor{
    false
   }

  }
  JumpAndLinkReg(arg){
   variable{
    wire [31:0] target;
wire [31:0] link;
wire [4:0] linkReg;
   }
   1{
    link = CPC.read();
   }
   2{
    wire [31:0] tmp_source;

tmp_source = GPR.read0(arg);
target = FWU0.forward(arg,tmp_source);
   }
   3{
    null = /*[chkValid]*/CPC.write(target);
linkReg = \"11111\";
[chkInvalid] throw int_recovery;//intr
   }
   BaseProcessor{
    false
   }

  }
  JumpAddr(){
   variable{
    
   }
   1{
    wire [1:0] const;
wire [31:0] result;
wire [3:0] cpc_top;

const = \"00\";
cpc_top = tar_pc[31:28];
result = <cpc_top,targ,const>;
null = /*[chkValid]*/ CPC.write(result);
[chkInvalid] throw int_recovery;//if valid then go on elsecall interrupt.
   }
   BaseProcessor{
    false
   }

  }
  checkflag(){
   variable{
    wire chkflag;
   }
   1{
    chkflag = chkflag.read();
   }
   2{
    
   }
   BaseProcessor{
    false
   }

  }
  RESET(){
   variable{
    
   }
   1{
    null = HI.reset();
null = LO.reset();
   }
   BaseProcessor{
    false
   }

  }
  CONVERT0(IN,OUT){
   variable{
    
   }
   1{
    wire [7:0] byte0;
wire [7:0] byte1;
wire [7:0] byte2;
wire [7:0] byte3;


byte0 = IN[31:24];
byte1 = IN[23:16];
byte2 = IN[15:8];
byte3 = IN[7:0];
OUT = <byte3, byte2, byte1, byte0>;
/*OUT is the output of this macro algorithm,
which converts a little-endian word to
big-endian, or vice versa. This macro should be added to
load/store instructions, where the variable
e.g.\"result\" should be substituted by OUT
after this convert. -- Tuo*/
   }
   BaseProcessor{
    false
   }

  }
  LoadFlagOn(arg){
   variable{
    
   }
   1{
    wire oneb1;
wire zerob1;

oneb1 = '1';
zerob1 = '0';
null = MemLoadFlag00.write(oneb1);
null = MemLoadFlag10.write(zerob1);

null = RecordRt0s.write(oneb1);
null = RecordRt0r.write(zerob1);
null = RecordRt0d.write(arg);
//This macro basically sets the Memory Read Flag on \
//and records the rt (arg) for LOAD instructions' \
//forward unit control. This macro should be deployed \
//at stage 3, i.e. EX of \"normal\" load instructions. \ 
//These three latches are considered as parts \
//of ID/EX pipeline registers.
   }
   BaseProcessor{
    false
   }

  }
  MemReadChk(arg1,arg2){
   variable{
    wire stallcondition;
   }
   1{
    wire MemRead;
wire [4:0] RecordRt;
wire arg1condition;
wire arg2condition;
wire orcondition;

MemRead = MemReadFlag0.read();
null = MemReadFlag0.reset();
RecordRt = Record_rt0.read();
arg1condition = COMP50.cmp(RecordRt,arg1);
arg2condition = COMP51.cmp(RecordRt,arg2);
orcondition = arg1condition & arg2condition;
stallcondition = orcondition & MemRead;
null = [stallcondition] STALL_EN.write(stallcondition);
//This macro is designed for normal instructions \
//including load instructions. It should be \
//deviced at stage 2 to detect stall condition \
//resulted by load instructions.
   }
   BaseProcessor{
    false
   }

  }
  DLoadFlagOn(arg){
   variable{
    
   }
   1{
    wire oneb1;
wire zerob1;

zerob1 = '0';
oneb1 = '1';
null = MemLoadFlag00.write(oneb1);
null = MemLoadFlag10.write(oneb1);
null = RecordRt0s.write(oneb1);
null = RecordRt0r.write(zerob1);
null = RecordRt0d.write(arg);
/*null = RecordRt0.write(arg);
replace this by writing r wire '0' and s wire '1' \
and d wire data*/
//This macro basically sets the Memory Read Flag on \
//and records the rt (arg) for LOAD instructions' \
//forward unit control. This macro should be deployed \
//at stage 3, i.e. EX of \"DOUBLE\" load instructions. \ 
//These three latches are considered as parts \
//of ID/EX pipeline registers.
   }
   BaseProcessor{
    false
   }

  }
  StallDecision3D(arg1,arg2,arg3){
   variable{
    wire stallcondition;
   }
   1{
    wire MemRead0;
wire MemRead1;
wire MemRead2;
wire MemRead3;
wire [4:0] RecordRT;
wire [4:0] RecordNRT;
wire arg1RT;
wire arg2RT;
wire arg3RT;
wire arg1NRT;
wire arg2NRT;
wire arg3NRT;
wire one1b0;
wire zero1b0;
wire [3:0] tmp4b0;
wire [3:0] tmp4b1;
wire [1:0] tmp2b0;
wire yes0;
wire yes1;
wire yes2;
wire check0;
wire check00;
wire check1;
wire check10;
wire check2;
wire check20;
wire check21;
wire check22;
wire check23;
wire c0000;
wire c0001;
wire c0001_0;
wire n_c0001_0;
wire c0001_1;
wire c10xx;
wire c10xx_0;
wire n_c10xx_0;
wire c10xx_1;
wire c11xx;
wire c11xx_0;
wire n_c11xx_0;
wire c11xx_1;
wire stallcondition0;


MemRead0 = MemLoadFlag01.read();//sload.cycle1
MemRead1 = MemLoadFlag11.read();//dload.cycle1
MemRead2 = MemReadFlag0.read();//sload.cycle2
MemRead3 = MemReadFlag1.read();//dload.cycle2
tmp4b1 = <MemRead0,MemRead1,MemRead2,MemRead3>;
tmp2b0 = <MemRead0,MemRead1>;
RecordRT = RecordRt1.read();
tmp4b0 = RecordRT[4:1];
one1b0 = '1';
zero1b0 = '0';
RecordNRT = <tmp4b0,one1b0>; //This way is used before
arg1RT = COMP50.cmp(RecordRT,arg1);
arg2RT = COMP51.cmp(RecordRT,arg2);
arg3RT = COMP52.cmp(RecordRT,arg3);
arg1NRT = COMP53.cmp(RecordNRT,arg1);
arg2NRT = COMP54.cmp(RecordNRT,arg2);
arg3NRT = COMP55.cmp(RecordNRT,arg3);
//case 0000, do nothing
c0000 = tmp4b1 == \"0000\"; //no load is on
//case 0001, dload.cycle2
yes0 = tmp4b1 == \"0001\";
check00 = arg1NRT | arg2NRT;
check0 = check00 | arg3NRT;
//case 10xx, sload.cycle1
yes1 = tmp2b0 == \"10\";
check10 = arg1RT | arg2RT;
check1 = check10 | arg3RT;
//case 11xx, dload.cycle1
yes2 = tmp2b0 == \"11\";
check20 = arg1NRT | arg2NRT;
check21 = check20 | arg1RT;
check22 = check21 | arg3RT;
check23 = check22 | arg3NRT;
check2 = check23 | arg2RT;
//Convergence
//--Lvl 0
c0001_0 = yes0 & check0;
n_c0001_0 = ~ c0001_0;
c10xx_0 = yes1 & check1;
n_c10xx_0 = ~ c10xx_0;
c11xx_0 = yes2 & check2;
n_c11xx_0 = ~ c11xx_0;
//--Lvl 1
c0001_1 = c0001_0 & n_c10xx_0;
c0001 = c0001_1 & n_c11xx_0;
c10xx_1 = c10xx_0 & n_c0001_0;
c10xx = c10xx_1 & n_c11xx_0;
c11xx_1 = c11xx_0 & n_c0001_0;
c11xx = c11xx_1 & n_c10xx_0;
//--output flag
null = [c0001] MemReadFlag0.write(zero1b0);
null = [c0001] MemReadFlag1.write(zero1b0);
null = [c10xx] MemReadFlag0.write(zero1b0);
null = [c10xx] MemReadFlag1.write(zero1b0);
null = [c11xx] MemReadFlag0.write(zero1b0);
null = [c11xx] MemReadFlag1.write(one1b0);
//stall decision making
stallcondition0 = c0001 | c10xx;
stallcondition = stallcondition0 | c11xx;
null = [stallcondition] WIRE_STALL_EN.write(one1b0);
 
//This macro is designed for all instructions \
//including load instructions. It should be \
//deployed at stage 2 to detect stall condition \
//resulted by load instructions and make stall \
//decision by setting WIRE_STALL_EN signal.
   }
   BaseProcessor{
    false
   }

  }
  StallDecision4D(arg1,arg2,arg3,arg4){
   variable{
    wire stallcondition;
   }
   1{
    wire MemRead0;
wire MemRead1;
wire MemRead2;
wire MemRead3;
wire [4:0] RecordRT;
wire [4:0] RecordNRT;
wire arg1RT;
wire arg2RT;
wire arg3RT;
wire arg4RT;
wire arg1NRT;
wire arg2NRT;
wire arg3NRT;
wire arg4NRT;
wire one1b0;
wire zero1b0;
wire [3:0] tmp4b0;
wire [3:0] tmp4b1;
wire [1:0] tmp2b0;
wire yes0;
wire yes1;
wire yes2;
wire check0;
wire check00;
wire check01;
wire check1;
wire check10;
wire check11;
wire check2;
wire check20;
wire check21;
wire check22;
wire check23;
wire check24;
wire check25;
wire c0000;
wire c0001;
wire c0001_0;
wire n_c0001_0;
wire c0001_1;
wire c10xx;
wire c10xx_0;
wire n_c10xx_0;
wire c10xx_1;
wire c11xx;
wire c11xx_0;
wire n_c11xx_0;
wire c11xx_1;
wire stallcondition0;

MemRead0 = MemLoadFlag01.read();//sload.cycle1
MemRead1 = MemLoadFlag11.read();//dload.cycle1
MemRead2 = MemReadFlag0.read();//sload.cycle2
MemRead3 = MemReadFlag1.read();//dload.cycle2
tmp4b1 = <MemRead0,MemRead1,MemRead2,MemRead3>;
tmp2b0 = <MemRead0,MemRead1>;
RecordRT = RecordRt1.read();
tmp4b0 = RecordRT[4:1];
one1b0 = '1';
zero1b0 = '0';
RecordNRT = <tmp4b0,one1b0>; //This way is used before
arg1RT = COMP50.cmp(RecordRT,arg1);
arg2RT = COMP51.cmp(RecordRT,arg2);
arg3RT = COMP52.cmp(RecordRT,arg3);
arg4RT = COMP53.cmp(RecordRT,arg4);
arg1NRT = COMP54.cmp(RecordNRT,arg1);
arg2NRT = COMP55.cmp(RecordNRT,arg2);
arg3NRT = COMP56.cmp(RecordNRT,arg3);
arg4NRT = COMP57.cmp(RecordNRT,arg4);
//case 0000, do nothing
c0000 = tmp4b1 == \"0000\"; //no load is on
//case 0001, dload.cycle2
yes0 = tmp4b1 == \"0001\";
check00 = arg1NRT | arg2NRT;
check01 = check00 | arg3NRT;
check0 = check01 | arg4NRT;
//case 10xx, sload.cycle1
yes1 = tmp2b0 == \"10\";
check10 = arg1RT | arg2RT;
check11 = check10 | arg3RT;
check1 = check11 | arg4RT;
//case 11xx, dload.cycle1
yes2 = tmp2b0 == \"11\";
check20 = arg1NRT | arg2NRT;
check21 = check20 | arg1RT;
check22 = check21 | arg3RT;
check23 = check22 | arg3NRT;
check24 = check23 | arg2RT;
check25 = check24 | arg4RT;
check2 = check25 | arg4NRT;
//Convergence
//--Lvl 0
c0001_0 = yes0 & check0;
n_c0001_0 = ~ c0001_0;
c10xx_0 = yes1 & check1;
n_c10xx_0 = ~ c10xx_0;
c11xx_0 = yes2 & check2;
n_c11xx_0 = ~ c11xx_0;
//--Lvl 1
c0001_1 = c0001_0 & n_c10xx_0;
c0001 = c0001_1 & n_c11xx_0;
c10xx_1 = c10xx_0 & n_c0001_0;
c10xx = c10xx_1 & n_c11xx_0;
c11xx_1 = c11xx_0 & n_c0001_0;
c11xx = c11xx_1 & n_c10xx_0;
//--output flag
null = [c0001] MemReadFlag0.write(zero1b0);
null = [c0001] MemReadFlag1.write(zero1b0);
null = [c10xx] MemReadFlag0.write(zero1b0);
null = [c10xx] MemReadFlag1.write(zero1b0);
null = [c11xx] MemReadFlag0.write(zero1b0);
null = [c11xx] MemReadFlag1.write(one1b0);
//stall decision making
stallcondition0 = c0001 | c10xx;
stallcondition = stallcondition0 | c11xx;
null = [stallcondition] WIRE_STALL_EN.write(one1b0);
   }
   BaseProcessor{
    false
   }

  }
  StallDecision1D(arg){
   variable{
    wire stallcondition;
   }
   1{
    wire MemRead0;
wire MemRead1;
wire MemRead2;
wire MemRead3;
wire [4:0] RecordRT;
wire [4:0] RecordNRT;
wire argRT;
wire argNRT;
wire one1b0;
wire zero1b0;
wire [3:0] tmp4b0;
wire [3:0] tmp4b1;
wire [1:0] tmp2b0;
wire yes0;
wire yes1;
wire yes2;
wire check0;
wire check1;
wire check2;
wire c0000;
wire c0001;
wire c0001_0;
wire n_c0001_0;
wire c0001_1;
wire c10xx;
wire c10xx_0;
wire n_c10xx_0;
wire c10xx_1;
wire c11xx;
wire c11xx_0;
wire n_c11xx_0;
wire c11xx_1;
wire stallcondition0;

MemRead0 = MemLoadFlag01.read();//sload.cycle1
MemRead1 = MemLoadFlag11.read();//dload.cycle1
MemRead2 = MemReadFlag0.read();//sload.cycle2
MemRead3 = MemReadFlag1.read();//dload.cycle2
tmp4b1 = <MemRead0,MemRead1,MemRead2,MemRead3>;
tmp2b0 = <MemRead0,MemRead1>;
RecordRT = RecordRt1.read();
tmp4b0 = RecordRT[4:1];
one1b0 = '1';
zero1b0 = '0';
RecordNRT = <tmp4b0,one1b0>; //This way is used before
argRT = COMP50.cmp(RecordRT,arg);
argNRT = COMP51.cmp(RecordNRT,arg);
//case 0000, do nothing
c0000 = tmp4b1 == \"0000\"; //no load is on
//case 0001, dload.cycle2
yes0 = tmp4b1 == \"0001\";
check0 = argNRT == '1';
//case 10xx, sload.cycle1
yes1 = tmp2b0 == \"10\";
check1 = argRT == '1';
//case 11xx, dload.cycle1
yes2 = tmp2b0 == \"11\";
check2 = argRT | argNRT;
//Convergence
//--Lvl 0
c0001_0 = yes0 & check0;
n_c0001_0 = ~ c0001_0;
c10xx_0 = yes1 & check1;
n_c10xx_0 = ~ c10xx_0;
c11xx_0 = yes2 & check2;
n_c11xx_0 = ~ c11xx_0;
//--Lvl 1
c0001_1 = c0001_0 & n_c10xx_0;
c0001 = c0001_1 & n_c11xx_0;
c10xx_1 = c10xx_0 & n_c0001_0;
c10xx = c10xx_1 & n_c11xx_0;
c11xx_1 = c11xx_0 & n_c0001_0;
c11xx = c11xx_1 & n_c10xx_0;
//--output flag
null = [c0001] MemReadFlag0.write(zero1b0);
null = [c0001] MemReadFlag1.write(zero1b0);
null = [c10xx] MemReadFlag0.write(zero1b0);
null = [c10xx] MemReadFlag1.write(zero1b0);
null = [c11xx] MemReadFlag0.write(zero1b0);
null = [c11xx] MemReadFlag1.write(one1b0);
//stall decision making
stallcondition0 = c0001 | c10xx;
stallcondition = stallcondition0 | c11xx;
null = [stallcondition] WIRE_STALL_EN.write(one1b0);

//This macro is designed for all instructions \
//including load instructions. It should be \
//deployed at stage 2 to detect stall condition \
//resulted by load instructions and make stall \
//decision by setting WIRE_STALL_EN signal.
   }
   BaseProcessor{
    false
   }

  }
  StallDecision2D(arg1,arg2){
   variable{
    wire stallcondition;
   }
   1{
    wire MemRead0;
wire MemRead1;
wire MemRead2;
wire MemRead3;
wire [4:0] RecordRT;
wire [4:0] RecordNRT;
wire arg1RT;
wire arg2RT;
wire arg1NRT;
wire arg2NRT;
wire one1b0;
wire zero1b0;
wire [3:0] tmp4b0;
wire [3:0] tmp4b1;
wire [1:0] tmp2b0;
wire yes0;
wire yes1;
wire yes2;
wire check0;
wire check1;
wire check2;
wire check20;
wire check21;
wire c0000;
wire c0001;
wire c0001_0;
wire n_c0001_0;
wire c0001_1;
wire c10xx;
wire c10xx_0;
wire n_c10xx_0;
wire c10xx_1;
wire c11xx;
wire c11xx_0;
wire n_c11xx_0;
wire c11xx_1;
wire stallcondition0;

MemRead0 = MemLoadFlag01.read();//sload.cycle1
MemRead1 = MemLoadFlag11.read();//dload.cycle1
MemRead2 = MemReadFlag0.read();//sload.cycle2
MemRead3 = MemReadFlag1.read();//dload.cycle2
tmp4b1 = <MemRead0,MemRead1,MemRead2,MemRead3>;
tmp2b0 = <MemRead0,MemRead1>;
RecordRT = RecordRt1.read();
tmp4b0 = RecordRT[4:1];
one1b0 = '1';
zero1b0 = '0';
RecordNRT = <tmp4b0,one1b0>; //This way is used before
arg1RT = COMP50.cmp(RecordRT,arg1);
arg2RT = COMP51.cmp(RecordRT,arg2);
arg1NRT = COMP52.cmp(RecordNRT,arg1);
arg2NRT = COMP53.cmp(RecordNRT,arg2); 
//case 0000, do nothing
c0000 = tmp4b1 == \"0000\"; //no load is on
//case 0001, dload.cycle2
yes0 = tmp4b1 == \"0001\";
check0 = arg1NRT | arg2NRT;
//case 10xx, sload.cycle1
yes1 = tmp2b0 == \"10\";
check1 = arg1RT | arg2RT;
//case 11xx, dload.cycle1
yes2 = tmp2b0 == \"11\";
check20 = arg1NRT | arg2NRT;
check21 = check20 | arg1RT;
check2 = check21 | arg2RT;
//Convergence
//--Lvl 0
c0001_0 = yes0 & check0;
n_c0001_0 = ~ c0001_0;
c10xx_0 = yes1 & check1;
n_c10xx_0 = ~ c10xx_0;
c11xx_0 = yes2 & check2;
n_c11xx_0 = ~ c11xx_0;
//--Lvl 1
c0001_1 = c0001_0 & n_c10xx_0;
c0001 = c0001_1 & n_c11xx_0;
c10xx_1 = c10xx_0 & n_c0001_0;
c10xx = c10xx_1 & n_c11xx_0;
c11xx_1 = c11xx_0 & n_c0001_0;
c11xx = c11xx_1 & n_c10xx_0;
//--output flag
null = [c0001] MemReadFlag0.write(zero1b0);
null = [c0001] MemReadFlag1.write(zero1b0);
null = [c10xx] MemReadFlag0.write(zero1b0);
null = [c10xx] MemReadFlag1.write(zero1b0);
null = [c11xx] MemReadFlag0.write(zero1b0);
null = [c11xx] MemReadFlag1.write(one1b0);
//stall decision making
stallcondition0 = c0001 | c10xx;
stallcondition = stallcondition0 | c11xx;
null = [stallcondition] WIRE_STALL_EN.write(one1b0);
/*------------------------------------------------*/
/*MemRead0 = MemLoadFlag01.read();
MemRead1 = MemLoadFlag11.read();
tmp2b0 = <MemRead0,MemRead1>;
RecordRT = RecordRt1.read();
tmp4b0 = RecordRT[4:1];
one1b0 = '1';
zero1b0 = '0';
RecordNRT = <tmp4b0,one1b0>; 
arg1RT = COMP50.cmp(RecordRT,arg1);
arg2RT = COMP51.cmp(RecordRT,arg2);
arg1NRT = COMP52.cmp(RecordNRT,arg1);
arg2NRT = COMP53.cmp(RecordNRT,arg2); 
NArg1NRT = ~ arg1NRT;
NArg2NRT = ~ arg2NRT;
tmp4b1 = <arg1RT,arg2RT,arg1NRT,arg2NRT>;
pass0 = tmp4b1 == \"0000\"; 
pass1 = tmp2b0 == \"00\"; 
pass2 = pass0 | pass1; */
//Single Load Scenario
/*singleLoad = tmp2b0 == \"10\"; 
singleStall0 = arg1RT | arg2RT;
singleStall1 = singleStall0 & singleLoad;*/
//Double Load Scenario
/*doubleLoad0 = tmp2b0 == \"11\";
doubleLoad1 = tmp2b0 == \"01\";*/
//--RT Hazard
/*doubleStall00 = arg1RT & NArg2NRT;
doubleStall01 = arg2RT & NArg1NRT;
doubleStall02 = doubleStall00 | doubleStall01;
doubleStall03 = doubleStall02 & doubleLoad0;*/
//--NRT Hazard
//----Cycle 1
//doubleStall10 = arg1NRT | arg2NRT;
//doubleStall11 = doubleStall10 & doubleLoad0;
//----Cycle 2
//doubleStall12 = doubleStall10 & doubleLoad1;
//Convergence
//--stallcondition = singleStall1 | doubleStall03 | doubleStall11 | doubleStall12; 
/*stallcondition0 = singleStall1 | doubleStall03;
stallcondition1 = stallcondition0 | doubleStall11;
stallcondition = stallcondition1 | doubleStall12;*/
//--clearFlag0 = singleStall1 | doubleStall03 | doubleStall11 | pass0;
/*clearFlag00 = singleStall1 | doubleStall03;
clearFlag01 = clearFlag00 | doubleStall11;
clearFlag0 = clearFlag01 | pass0;*/
//--clearFlag1 = doubleStall03 | doubleStall12 | pass0;
//clearFlag10 = doubleStall03 | doubleStall12;
//clearFlag1 = clearFlag10 | pass0;
//Decision Making
/*null = [stallcondition] WIRE_STALL_EN.write(stallcondition);
null = [clearFlag0] MemLoadFlag00r.write(one1b0);
null = [clearFlag0] MemLoadFlag00s.write(zero1b0);
null = [clearFlag0] MemLoadFlag10r.write(one1b0);
null = [clearFlag0] MemLoadFlag10s.write(zero1b0);*/
/*null = [clearFlag0] MemLoadFlag00.write(zero1b0);
null = [clearFlag1] MemLoadFlag10.write(zero1b0);*/
//This macro is designed for all instructions \
//including load instructions. It should be \
//deployed at stage 2 to detect stall condition \
//resulted by load instructions and make stall \
//decision by setting WIRE_STALL_EN signal.
   }
   BaseProcessor{
    false
   }

  }
  fetchNsimpchk(){
   variable{
    wire [31:0] tmp_pc;
   }
   1{
    wire[31:0] current_pc;
wire iramaddr_err; 
wire[63:0] inst0;

current_pc = CPC.read();
tmp_pc=current_pc;
<inst0,iramaddr_err> = Imem.ld_64(current_pc);
null = IReg.write(inst0);
null = CPC.inc();
   }
   BaseProcessor{
    false
   }

  }
  XOR64b(IN0,IN1,OUT){
   variable{
    
   }
   1{
    wire[63:0] tmp0;
wire[63:0] tmp1;
wire[63:0] negIN0;
wire[63:0] negIN1;

negIN0 = ~IN0;
negIN1 = ~IN1;
tmp0 = IN0 & negIN1;
tmp1 = negIN0 & IN1;
OUT = tmp0|tmp1;
   }
   BaseProcessor{
    false
   }

  }
  FETCH(){
   variable{
    wire [31:0] tmp_pc;
   }
   1{
    wire[31:0] current_pc;
wire iramaddr_err; 
wire[63:0] inst0;

current_pc = CPC.read();
tmp_pc=current_pc;
<inst0,iramaddr_err> = Imem.ld_64(current_pc);
null = IReg.write(inst0);
null = CPC.inc();
   }
   BaseProcessor{
    false
   }

  }
  storeL(){
   variable{
    wire [31:0] addr;
wire [31:0] result;
   }
   1{
    wire [3:0] flag;

<addr,flag> = ALU1.add(source0, source2);
   }
   2{
    wire [29:0] addr_mask;
wire [1:0] zero2;
wire [31:0] target;
wire [31:0] data;
wire addr_err;
wire [1:0] vAddr10;
wire [7:0] data3;
wire [7:0] data2;
wire [7:0] data1;
wire [7:0] reg3;
wire [7:0] reg2;
wire [7:0] reg1;
wire [31:0] result3;
wire [31:0] result2;
wire [31:0] result1;
wire [31:0] result0;
wire [31:0] nData;
wire [7:0] byte0;
wire [7:0] byte1;
wire [7:0] byte2;
wire [7:0] byte3;

addr_mask = addr[31:2];
vAddr10 = addr[1:0];
zero2 = \"00\";
target = <addr_mask, zero2>;

<data, addr_err> = Dmem.ld_32(target);

byte0 = data[31:24];
byte1 = data[23:16];
byte2 = data[15:8];
byte3 = data[7:0];
nData = <byte3, byte2, byte1, byte0>;

data3 = nData[31:24];
data2 = nData[23:16];
data1 = nData[15:8];
reg3 = source1[31:24];
reg2 = source1[23:16];
reg1 = source1[15:8];
result3 = source1;
result2 = <data3, reg3, reg2, reg1>;
result1 = <data3, data2, reg3, reg2>;
result0 = <data3, data2, data1, reg3>;
result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
   }
   3{
    wire addr_err;
wire [29:0] addr_mask;
wire [1:0] zero2;
wire [31:0] target;
wire [31:0] nResult;
wire [7:0] byte0;
wire [7:0] byte1;
wire [7:0] byte2;
wire [7:0] byte3;

addr_mask = addr[31:2];
zero2 = \"00\";
target = <addr_mask, zero2>;

byte0 = result[31:24];
byte1 = result[23:16];
byte2 = result[15:8];
byte3 = result[7:0];
nResult = <byte3, byte2, byte1, byte0>;

addr_err = Dmem.s_32(target, nResult);
   }
   BaseProcessor{
    false
   }

  }
  storeR(){
   variable{
    wire [31:0] addr;
wire [31:0] result;
   }
   1{
    wire [3:0] flag;

<addr, flag> = ALU1.add(source0,source2);
   }
   2{
    wire [29:0] addr_mask;
wire [1:0] zero2;
wire [31:0] target;
wire [31:0] data;
wire addr_err;
wire [1:0] vAddr10;
wire [7:0] data2;
wire [7:0] data1;
wire [7:0] data0;
wire [7:0] reg2;
wire [7:0] reg1;
wire [7:0] reg0;
wire [31:0] result3;
wire [31:0] result2;
wire [31:0] result1;
wire [31:0] result0;
wire [31:0] nData;
wire [7:0] byte0;
wire [7:0] byte1;
wire [7:0] byte2;
wire [7:0] byte3;

addr_mask = addr[31:2];
vAddr10 = addr[1:0];
zero2 = \"00\";
target = <addr_mask, zero2>;

<data, addr_err> = Dmem.ld_32(target);

byte0 = data[31:24];
byte1 = data[23:16];
byte2 = data[15:8];
byte3 = data[7:0];
nData = <byte3, byte2, byte1, byte0>;

data2 = nData[23:16];
data1 = nData[15:8];
data0 = nData[7:0];
reg2 = source1[23:16];
reg1 = source1[15:8];
reg0 = source1[7:0];

result0 = source1;
result1 = <reg2, reg1, reg0, data0>;
result2 = <reg1, reg0, data1, data0>;
result3 = <reg0, data2, data1, data0>;
result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
   }
   3{
    wire addr_err;
wire [29:0] addr_mask;
wire [1:0] zero2;
wire [31:0] target;
wire [31:0] nResult;
wire [7:0] byte0;
wire [7:0] byte1;
wire [7:0] byte2;
wire [7:0] byte3;

addr_mask = addr[31:2];
zero2 = \"00\";

byte0 = result[31:24];
byte1 = result[23:16];
byte2 = result[15:8];
byte3 = result[7:0];
nResult = <byte3, byte2, byte1, byte0>;

target = <addr_mask, zero2>;
addr_err = Dmem.s_32(target, nResult);
   }
   BaseProcessor{
    false
   }

  }

 }

}
Estimation{
 ArchLevel{
  Complete{
   OFF
  }

 }
 BehaviorLevel{
  Complete{
   OFF
  }

 }
 RTLevel{
  Complete{
   OFF
  }

 }

}
Generation{
 ISSmodel{
  Complete{
   OFF
  }

 }
 Model{
  Complete{
   ON
  }
  lang{
   0{
    VHDL
   }
   1{
    Verilog
   }
   2{
    SystemC
   }

  }

 }

}
SW_Generation{
 SWmodel{
  Complete{
   OFF
  }

 }

}
ASM_Generation{
 ASMmodel{
  Complete{
   OFF
  }

 }

}
