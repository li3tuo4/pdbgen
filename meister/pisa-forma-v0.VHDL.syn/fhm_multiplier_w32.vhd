--
-- Copyright (C) 2008 ASIP Solutions, Inc. All rights reserved. 
-- Generated by ASIP Meister 2.3 on 2014/09/17 13:51:55 
--
-- Module     : 32-bit unsigned adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^32-1

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity fhm_multiplier_w32_add32 is
  port (a, b   : in std_logic_vector(31 downto 0);
        cin    : in std_logic;
        result : out std_logic_vector(31 downto 0);
        cout   : out std_logic);
end fhm_multiplier_w32_add32;

architecture synthesis of fhm_multiplier_w32_add32 is

begin  -- synthesis

  addition: process (a, b, cin)
    variable int_a, int_b : std_logic_vector(32 downto 0);
    variable int_result   : std_logic_vector(32 downto 0);
  begin
    int_a      := '0' & a;
    int_b      := '0' & b;

    int_result := int_a + int_b + cin;

    result     <= int_result(31 downto 0);
    cout       <= int_result(32);

  end process addition;

end synthesis;

-- Module     : 64-bit unsigned adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^32-1

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity fhm_multiplier_w32_add64 is
  port (a, b   : in std_logic_vector(63 downto 0);
        cin    : in std_logic;
        result : out std_logic_vector(63 downto 0);
        cout   : out std_logic);
end fhm_multiplier_w32_add64;

architecture synthesis of fhm_multiplier_w32_add64 is

begin  -- synthesis

  addition: process (a, b, cin)
    variable int_a, int_b : std_logic_vector(64 downto 0);
    variable int_result   : std_logic_vector(64 downto 0);
  begin
    int_a      := '0' & a;
    int_b      := '0' & b;

    int_result := int_a + int_b + cin;

    result     <= int_result(63 downto 0);
    cout       <= int_result(64);

  end process addition;

end synthesis;

-- Module     : 32-bit Unsigned Multiplier
-- Feature    : type : array
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :

-- Functionality :
--  port
--   W      : bit width. boundary of input
--   a, b   : can represent from 0 to 2^32-1 in integer
--   result : multiplied result

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity fhm_multiplier_w32_amul is
  port (a, b   : in std_logic_vector(31 downto 0);
        result : out std_logic_vector(63 downto 0));
end fhm_multiplier_w32_amul;

architecture synthesis of fhm_multiplier_w32_amul is

  -- component declaration
  -- adder
  component fhm_multiplier_w32_add32
    port (a, b   : in std_logic_vector(31 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector(31 downto 0);
          cout   : out std_logic);
  end component;

  --  type definition
  type vectors is array (Natural range <>) of std_logic_vector(31 downto
  	0);

  --  signal declaration
  signal qout   : std_logic_vector(31 downto 0);
  signal add_a	: vectors(31 downto 0);
  signal add_b	: vectors(31 downto 0);
  signal add_s	: vectors(31 downto 0);
  signal s	: vectors(31 downto 0);
  signal c	: std_logic_vector(31 downto 0);
 
  signal zero	: std_logic;

begin

  zero <= '0';

  a_connect : for i in 0 to 31 generate
    add_a0 : if (i = 0) generate
      input_0 : for j in 31 downto 0 generate
        s(i)(j) <= a(j) and b(0);
      end generate input_0;
    c(0) <= zero;

    end generate add_a0;
    
    add_as : if (0 < i and i <= 31) generate
      input_0 : for j in 31 downto 0 generate
        add_a(i)(j) <= a(j) and b(i);
        b_carry : if (j = 31) generate
	  add_b(i)(j) <= c(i-1);
	end generate b_carry;

  b_other : if (j /= 31) generate
	  add_b(i)(j) <= s(i-1)(j+1);
	end generate b_other;

      end generate input_0;

    end generate add_as;

  end generate a_connect;

  -- make result
  s_conv : for i in 1 to 30 generate
    result(i) <= s(i)(0);
  end generate s_conv;

  s_conv2 : for i in 31 to 62 generate
    result(i) <= s(31)(i-31);
  end generate s_conv2;

  result(0) <= a(0) and b(0);
  result(63) <= c(31);

  -- port mapping : adder
  add_connect : for i in 1 to 31 generate
   adds : fhm_multiplier_w32_add32
      port map (add_a(i), add_b(i),
                zero, s(i), c(i) );
  end generate add_connect;

end synthesis;

--%%

-- Module     : 32-bit 2's complement converter
-- Feature    : 32-bit
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996.
-- Version : 1.0  :

-- Functionality :
--  port
--   data_in  : data for convert
--   conv     : '1' then convert data
--   data_out : converted data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity fhm_multiplier_w32_tconv32 is
    port (data_in  : in  std_logic_vector(31 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector(31 downto 0));
end fhm_multiplier_w32_tconv32;

architecture synthesis of fhm_multiplier_w32_tconv32 is

  component fhm_multiplier_w32_add32
    port (a, b   : in std_logic_vector(31 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector(31 downto 0);
          cout   : out std_logic);
  end component;

  signal not_data_in  : std_logic_vector(31 downto 0);
  signal zero         : std_logic_vector(31 downto 0);
  signal tmp_data_out : std_logic_vector(31 downto 0);
  signal tmp_cout     : std_logic;

begin

  not_data_in <= not data_in;
  zero <= "00000000000000000000000000000000";

  two_conv : fhm_multiplier_w32_add32
    port map (not_data_in, zero, conv,
              tmp_data_out, tmp_cout);

  data_out <= data_in when conv = '0' else
              tmp_data_out;

end synthesis;

--%%

-- Module     : 64-bit 2's complement converter
-- Feature    : 64-bit
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996.

-- Version : 1.0  :
-- Functionality :
--  port
--   data_in  : data for convert
--   conv     : '1' then convert data
--   data_out : converted data


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity fhm_multiplier_w32_tconv64 is
    port (data_in  : in  std_logic_vector(63 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector(63 downto 0));
end fhm_multiplier_w32_tconv64;

architecture synthesis of fhm_multiplier_w32_tconv64 is

  component fhm_multiplier_w32_add64
    port (a, b   : in std_logic_vector(63 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector(63 downto 0);
          cout   : out std_logic);
  end component;

  signal not_data_in  : std_logic_vector(63 downto 0);
  signal zero         : std_logic_vector(63 downto 0);
  signal tmp_data_out : std_logic_vector(63 downto 0);
  signal tmp_cout     : std_logic;

begin

  not_data_in <= not data_in;
  zero <=
  	"0000000000000000000000000000000000000000000000000000000000000000";

  two_conv : fhm_multiplier_w32_add64
    port map (not_data_in, zero, conv,
              tmp_data_out, tmp_cout);

  data_out <= data_in when conv = '0' else
              tmp_data_out;

end synthesis;

--%%

-- Module     : 32-bit Multiplier
-- Feature    : array default two_complement
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1997,1999.
--              Modified by T.Yoshimura (c)2004.
-- Version    : 1.2  :
-- Functionality :
--  port
--   W       : bit width. boundary of input
--   clock   : clock
--   a, b    : can represent from 0 to 2^32-1 in integer
--   mode    : '0' when data type is unsigned
--             '1' when data type is two_complement
--   start   : (ignore)
--   result  : multiplied result
--   fin     : '1' when operation is over

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity fhm_multiplier_w32 is
  port (clock  : in std_logic;
        async_reset  : in std_logic;
        reset  : in std_logic;
        a, b   : in std_logic_vector(31 downto 0);
        mode   : in std_logic;
        start  : in std_logic;
        clear  : in std_logic;
        result : out std_logic_vector(63 downto 0);
        fin    : out std_logic);
end fhm_multiplier_w32;

architecture synthesis of fhm_multiplier_w32 is

  component fhm_multiplier_w32_amul
    port (a, b   : in std_logic_vector(31 downto 0);
          result : out std_logic_vector(63 downto 0));
  end component;

  component fhm_multiplier_w32_tconv32
    port (data_in  : in std_logic_vector(31 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector(31 downto 0));
  end component;

  component fhm_multiplier_w32_tconv64
    port (data_in  : in std_logic_vector(63 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector(63 downto 0));
  end component;

  signal conved_a          : std_logic_vector(31 downto 0);
  signal conved_b          : std_logic_vector(31 downto 0);
  signal conved_result     : std_logic_vector(63 downto 0);

  signal tmp_a             : std_logic_vector(31 downto 0);
  signal tmp_b             : std_logic_vector(31 downto 0);
  signal tmp_result        : std_logic_vector(63 downto 0);

  signal result_tconv_conv     : std_logic;

begin

  result_tconv_conv <= a(31) xor b(31);

  conv_a : fhm_multiplier_w32_tconv32
    port map (a, a(31), conved_a);

  conv_b : fhm_multiplier_w32_tconv32
    port map (b, b(31), conved_b);
  fin <= '1';

  tmp_a <= a when mode = '0' else
           conved_a;

  tmp_b <= b when mode = '0' else
           conved_b;

  mulu : fhm_multiplier_w32_amul
    port map (tmp_a, tmp_b, tmp_result);
  conv_result : fhm_multiplier_w32_tconv64
    port map (tmp_result, result_tconv_conv, conved_result);

  result <= tmp_result when mode = '0' else
            conved_result;

end synthesis;

-----------------------------------------
-- Generated by ASIP Meister ver.2.3.2 --
-----------------------------------------
