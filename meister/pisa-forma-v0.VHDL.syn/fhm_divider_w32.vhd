--
-- Copyright (C) 2008 ASIP Solutions, Inc. All rights reserved. 
-- Generated by ASIP Meister 2.3 on 2014/09/17 13:51:55 
--
-- Module     : 32-bit unsigned adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0

-- Functionality : behavior level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^32-1

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity fhm_divider_w32_add32 is
  port (a, b   : in std_logic_vector(31 downto 0);
        cin    : in std_logic;
        result : out std_logic_vector(31 downto 0);
        cout   : out std_logic);
end fhm_divider_w32_add32;

architecture synthesis of fhm_divider_w32_add32 is

begin  -- behavior

  addition: process (a, b, cin)
    variable int_a, int_b : std_logic_vector(32 downto 0);
    variable int_result   : std_logic_vector(32 downto 0);
  begin
    int_a      := '0' & a;
    int_b      := '0' & b;

    int_result := int_a + int_b + cin;

    result     <= int_result(31 downto 0);
    cout       <= int_result(32);

  end process addition;

end synthesis;


--%%

-- Module     : Basic 32-bit array unsigned divider
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :

-- Functionality :
--  port
--   a      : dividend
--   b      : divisor
--   q      : result of a / b
--   r      : reminder of a / b
--   flag   : '1' when b = 0

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;
  use IEEE.std_logic_arith.all;

entity fhm_divider_w32_adiv32 is
  port (a, b : in std_logic_vector(31 downto 0);
        q, r : out std_logic_vector(31 downto 0);
        flag : out std_logic );
end fhm_divider_w32_adiv32;

architecture synthesis of fhm_divider_w32_adiv32 is

  -- component declaration
  -- adder
  component fhm_divider_w32_add32
    port (a, b   : in std_logic_vector(31 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector(31 downto 0);
          cout   : out std_logic);
  end component;

  --  type definition
  type vectors is array (Natural range <>) of std_logic_vector(31 downto
  	0);

  --  signal declaration
  signal qout   : std_logic_vector(31 downto 0);
  signal conv_b	: std_logic_vector(31 downto 0);
  signal add_a	: vectors(31 downto 0);
  signal s	: vectors(31 downto 0);
  signal c	: std_logic_vector(31 downto 0);
  signal subr	: vectors(0 to 30);

  signal one	: std_logic;

begin  -- synthesis

  one <= '1';

  -- zero flag
  flag <= '1' when b = "00000000000000000000000000000000" else
          '0';

  conv_b <= not b;
 
  a_connect : for i in 0 to 31 generate
    add_a0 : if (i = 0) generate
      input_0 : for j in 31 downto 1 generate
        add_a(i)(j) <= '0';
      end generate input_0;
        add_a(i)(0) <= a(31);

    end generate add_a0;
    
    add_as : if (0 < i and i < 31) generate
      input_0 : for j in 31 downto i+1 generate
        add_a(i)(j) <= '0';
      end generate input_0;
        add_a(i)(i downto 0) <= subr(i-1)(i-1 downto 0) & a(31-i);
    end generate add_as;

    add_aend : if (i = 31) generate
      add_a(i) <= subr(30)(30 downto 0) & a(0);
    end generate add_aend;
  end generate a_connect;

  sub_r : for i in 0 to 30 generate
    subs : for j in i downto 0 generate
      front : if (j /= 0) generate
	subr(i)(j) <=    (s(i)(j) and c(i))
                      or ((not c(i)) and subr(i-1)(j-1));
	
      end generate front;

      last : if (j = 0) generate
	subr(i)(j) <=    (s(i)(j) and c(i))
                     or ((not c(i)) and a(31-i));
      end generate last;
    end generate subs;
  end generate sub_r;

  rems : for j in 31 downto 0 generate
    rfront : if (j /= 0) generate
      r(j) <=    (s(31)(j) and c(31)) 
              or ((not c(31)) and subr(30)(j-1));
    end generate rfront;

    rlast : if (j = 0) generate
      r(j) <=    (s(31)(j) and c(31))
              or ((not c(31)) and a(0));
    end generate rlast;
  end generate rems;

  qui : for i in 31 downto 0 generate
    q(i) <= c(31-i);
  end generate qui;

  -- port mapping: adder
  add_connect : for i in 0 to 31 generate
   adds : fhm_divider_w32_add32
      port map (
        a      => add_a(i),
        b      => conv_b,
        cin    => one,
        result => s(i),
        cout   => c(i));
  end generate add_connect;

end synthesis;


--%%

-- Module     : 32-bit 2's complement converter
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0  :

-- Functionality :
--  port
--   data_in  : data for convert
--   conv     : '1' then convert data
--   data_out : converted data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity fhm_divider_w32_tconv32 is
  port (data_in  : in  std_logic_vector(31 downto 0);
        conv     : in std_logic;
        data_out : out std_logic_vector(31 downto 0));
end fhm_divider_w32_tconv32;

architecture synthesis of fhm_divider_w32_tconv32 is

  -- adder
  component fhm_divider_w32_add32
    port (a, b   : in std_logic_vector(31 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector(31 downto 0);
          cout   : out std_logic);
  end component;

  signal not_data_in  : std_logic_vector(31 downto 0);
  signal zero         : std_logic_vector(31 downto 0);
  signal tmp_data_out : std_logic_vector(31 downto 0);
  signal tmp_cout     : std_logic;

begin

  not_data_in <= not data_in;
  zero <= (others => '0');

  two_conv : fhm_divider_w32_add32
    port map (
      a      => not_data_in,
      b      => zero,
      cin    => conv,
      result => tmp_data_out,
      cout   => tmp_cout);
  
  data_out <= data_in when conv = '0' else
              tmp_data_out;

end synthesis;

--%%

-- Module     : 32-bit array two_complement divider
--              using default for adder algorithm
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997,1999
--              Modified by T.Yoshimura (c)2004
-- Version    : 1.1  :
--              1.2  : Bug fixed

-- Functionality :
--  port
--   clock : (ignore)
--   async_reset : (ignore)
--   reset : (ignore)
--   clear : (ignore)
--   a     : dividend
--   b     : divisor
--   start : (ignore)
--   mode  : 
--   q     : result of a / b
--   r     : reminder of a / b
--   flag  : '1' if b = 0
--   fin   : (ignore)

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity fhm_divider_w32 is
  port (clock    : in std_logic;
	async_reset    : in std_logic;
	reset    : in std_logic;
        clear    : in std_logic;
        a, b     : in std_logic_vector(31 downto 0);
        start    : in std_logic;
        mode     : in std_logic;
        q        : out std_logic_vector(31 downto 0);
        r        : out std_logic_vector(31 downto 0);
        flag     : out std_logic;
        fin      : out std_logic );
end fhm_divider_w32;

architecture synthesis of fhm_divider_w32 is
  component fhm_divider_w32_adiv32
    port (a, b : in std_logic_vector(31 downto 0);
          q, r : out std_logic_vector(31 downto 0);
          flag : out std_logic);
  end component;

  component fhm_divider_w32_tconv32
    port (data_in  : in std_logic_vector(31 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector(31 downto 0));
  end component;

  signal conved_a : std_logic_vector(31 downto 0);
  signal conved_b : std_logic_vector(31 downto 0);
  signal conved_q : std_logic_vector(31 downto 0);
  signal conved_r : std_logic_vector(31 downto 0);

  signal tmp_a    : std_logic_vector(31 downto 0);
  signal tmp_b    : std_logic_vector(31 downto 0);
  signal tmp_q    : std_logic_vector(31 downto 0);
  signal tmp_r    : std_logic_vector(31 downto 0);
  signal q_tconv_conv, r_tconv_conv : std_logic;

begin

  q_tconv_conv <= a(31) xor b(31);
  r_tconv_conv <= a(31);

  conv_a : fhm_divider_w32_tconv32
    port map (
      data_in  => a,
      conv     => a(31),
      data_out => conved_a);

  conv_b : fhm_divider_w32_tconv32
    port map (
      data_in  => b,
      conv     => b(31),
      data_out => conved_b);

  tmp_a <= a when mode = '0' else
           conved_a;

  tmp_b <= b when mode = '0' else
           conved_b;
  fin <= '1';

  divu : fhm_divider_w32_adiv32
    port map (
      a    => tmp_a,
      b    => tmp_b,
      q    => tmp_q,
      r    => tmp_r,
      flag => flag);

  conv_q : fhm_divider_w32_tconv32
    port map (
      data_in  => tmp_q,
      conv     => q_tconv_conv,
      data_out => conved_q);

  conv_r : fhm_divider_w32_tconv32
    port map (
      data_in  => tmp_r,
      conv     => r_tconv_conv,
      data_out => conved_r);

  q <= tmp_q when mode = '0' else
             conved_q;
  r <= tmp_r when mode = '0' else
             conved_r;

end synthesis;

-----------------------------------------
-- Generated by ASIP Meister ver.2.3.2 --
-----------------------------------------
