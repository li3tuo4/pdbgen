// Copyright (C) 2008 ASIP Solutions, Inc. All rights reserved. 
// Generated by ASIP Meister 2.3 on 2014/09/19 21:18:26 
mod "lb"
{
/* Architecture Parameter */
  num_stages 6;
  stage IF : fetch_stage;
  stage ID : decode_stage,register_read_stage;
  stage EX : register_read_stage,exec_stage;
  stage MEM1 : memory_read_stage,memory_write_stage;
  stage MEM2 : memory_read_stage,memory_write_stage;
  stage WB : register_write_stage;

/* Resource */
  resource ALU1
  {
    model "alu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=default";
    };
  };
  resource ADD1
  {
    model "adder";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=default";
    };
  };
  resource DIV1
  {
    model "divider";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 algorithm=array data_type=two_complement";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=array adder_algorithm=default data_type=two_complement";
    };
  };
  resource EXT1
  {
    model "extender";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=16 bit_width_out=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=16 bit_width_out=32";
    };
  };
  resource MUL1
  {
    model "multiplier";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 algorithm=array data_type=two_complement";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=array adder_algorithm=default data_type=two_complement";
    };
  };
  resource HI : plain_register
  {
    model "register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource LO : plain_register
  {
    model "register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource GPR : register_file
  {
    model "registerfile";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 num_register=32 num_read_port=4 num_write_port=2";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 num_register=32 num_read_port=4 num_write_port=2";
    };
  };
  resource IReg : instr_register
  {
    model "register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=64";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=64";
    };
  };
  resource Dmem : data_memory
  {
    model "mifu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 address_space=32 access_width=8 access_mode=multi_cycle type=read_write";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 address_space=32 access_width=8 access_mode=multi_cycle type=read_write";
    };
  };
  resource CPC : program_counter
  {
    model "pcu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 increment_step=8 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 increment_step=8 adder_algorithm=default";
    };
  };
  resource SFT1
  {
    model "shifter";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 amount=variable";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 amount=variable";
    };
  };
  resource SYSREG
  {
    model "register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource FWU0
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
  };
  resource FWU1
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
  };
  resource FWU2
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
  };
  resource FWU3
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
  };
  resource ADDER2
  {
    model "adder";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=default";
    };
  };
  resource Imem : instr_memory
  {
    model "mifu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=64 address_space=32 access_width=64 access_mode=single_cycle type=read_write";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=64 address_space=32 access_width=64 access_mode=single_cycle type=read_write";
    };
  };
  resource FWU4
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=8";
    };
  };
  resource FWUL0
  {
    model "fwu_lock";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=8 lockstage_number=6";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=8 lockstage_number=6";
    };
  };
  resource FWUL1
  {
    model "fwu_lock";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=8 lockstage_number=6";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=8 lockstage_number=6";
    };
  };
  resource FWUL2
  {
    model "fwu_lock";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=8 lockstage_number=6";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=8 lockstage_number=6";
    };
  };
  resource FWUL3
  {
    model "fwu_lock";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=8 lockstage_number=6";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=8 lockstage_number=6";
    };
  };
  resource MUXw32p4
  {
    model "multiplexor";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 number_of_ports=4";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 number_of_ports=4";
    };
  };
  resource CTRLWIRE_FORMA_EX0
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource CYCLEWIRE_FORMA_EX
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource CYCLEWIRE_FORMA_ID
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource CYCLEWIRE_FORMA_M1
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource CYCLEWIRE_FORMA_M2
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource CYCLEWIRE_FORMA_WB
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource CTRLWIRE_FORMA_EX1
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource CTRLWIRE_FORMA_EX2
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource CTRLWIRE_FORMA_M10
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource CTRLWIRE_FORMA_M11
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource CTRLWIRE_FORMA_M12
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource CTRLWIRE_FORMA_M20
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource CTRLWIRE_FORMA_M21
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource CTRLWIRE_FORMA_M22
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource CTRLWIRE_FORMA_M23
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource DATAOUT_FORMA_EX0
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_EX1
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_EX2
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_M10
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_M11
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_M12
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_M13
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_M20
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_M21
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_M22
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_M23
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_WB0
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_ID0
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_ID1
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_WB1
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_M24
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_ID2
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };
  resource DATAOUT_FORMA_ID3
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=136 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=136 default_output=fix_to_0";
    };
  };

/* Instruction Type */
  instr_type R
  {
    reserved [63:48] res000="0000000000000000";
    opecode [47:32] opcode;
    reserved [31:29] res001="000";
    operand [28:24] rs;
    reserved [23:21] res002="000";
    operand [20:16] rt;
    reserved [15:13] res003="000";
    operand [12:8] rd;
    operand [7:0] shamt;
  };
  instr_type I
  {
    reserved [63:48] res000="0000000000000000";
    opecode [47:32] opcode;
    reserved [31:29] res001="000";
    operand [28:24] rs;
    reserved [23:21] res002="000";
    operand [20:16] rt;
    operand [15:0] imm;
  };
  instr_type J
  {
    reserved [63:48] res000="0000000000000000";
    opecode [47:32] opcode;
    reserved [31:26] res001="000000";
    operand [25:0] targ;
  };
  instr_type INH
  {
    reserved [63:48] res000="0000000000000000";
    opecode [47:32] opcode;
    reserved [31:0] res001="00000000000000000000000000000000";
  };

/* I/O Port */
  top_module ssCPU_2_3_0;
  clock_port CLK;
  reset_port Reset;
  port [31:0] imaddr {
    direction out;
    connect_to Imem.addr2mem;
  };
  port [63:0] imdat_in {
    direction in;
    connect_to Imem.data2cpu;
  };
  port [63:0] imdat_out {
    direction out;
    connect_to Imem.data2mem;
  };
  port imrw {
    direction out;
    connect_to Imem.rw2mem;
  };
  port imaddr_err {
    direction in;
    connect_to Imem.aderr2cpu;
  };
  port [31:0] DataAB {
    direction out;
    connect_to Dmem.addr2mem;
  };
  port [31:0] DataDIB {
    direction in;
    connect_to Dmem.data2cpu;
  };
  port [31:0] DataDOB {
    direction out;
    connect_to Dmem.data2mem;
  };
  port DataReq {
    direction out;
    connect_to Dmem.req2mem;
  };
  port DataAck {
    direction in;
    connect_to Dmem.ack2cpu;
  };
  port DataRW {
    direction out;
    connect_to Dmem.rw2mem;
  };
  port [1:0] DataMode {
    direction out;
    connect_to Dmem.mode2mem;
  };
  port DataExt {
    direction out;
    connect_to Dmem.ext2mem;
  };
  port DataAdrerr {
    direction in;
    connect_to Dmem.aderr2cpu;
  };
  port DataCancel {
    direction out;
    connect_to Dmem.cancel2mem;
  };

/* Exception */
  reset_interrupt reset {
    cause_condition {
      port Reset;
      active_value '1';
    };
  };

  catch_interrupt reset {
    null = IReg.reset();
    null = CPC.reset();
    null = GPR.reset();
  };

/* Instruction */
  instruction LB : I
  {
    opecode  opcode = "0000000000100000";

    wire[31:0] source0;
    wire[31:0] source1;
    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ld_8(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LBU : I
  {
    opecode  opcode = "0000000000100010";

    wire[31:0] source0;
    wire[31:0] source1;
    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ldu_8(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LH : I
  {
    opecode  opcode = "0000000000100100";

    wire[31:0] source0;
    wire[31:0] source1;
    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ld_16(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LHU : I
  {
    opecode  opcode = "0000000000100110";

    wire[31:0] source0;
    wire[31:0] source1;
    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ldu_16(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LW : I
  {
    opecode  opcode = "0000000000101000";

    wire[31:0] source0;
    wire[31:0] source1;
    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ld_32(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction DLW : I
  {
    opecode  opcode = "0000000000101001";

    wire[31:0] source0;
    wire[31:0] source1;
    wire [31:0] addr1;
    wire [31:0] addr2;
    wire [31:0] bigE_word0;
    wire [31:0] bigE_word1;
    wire [4:0] nextRT;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [3:0] tmpRT;
      wire one;
      
      <addr1,flag> = ALU1.add(source0,source1);
      
      one ='1';
      tmpRT = rt[4:1];
      nextRT = <tmpRT,one>;
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      null = FWUL0.lock2(nextRT);
      null = FWUL1.lock2(nextRT);
      null = FWUL2.lock2(nextRT);
      null = FWUL3.lock2(nextRT);
    };

    stage 4 :
    {
      wire cout;
      wire cin;
      wire [31:0] four32bit;
      wire addr_err;
      wire [31:0] result1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      cin = '0';
      four32bit = "00000000000000000000000000000100";
      
      <result1,addr_err> = Dmem.ld_32(addr1);
      byte0 = result1[31:24];
      byte1 = result1[23:16];
      byte2 = result1[15:8];
      byte3 = result1[7:0];
      bigE_word0 = <byte3, byte2, byte1, byte0>;
      /*bigE_word0 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word0
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word0);
      null = FWUL1.forward3(rt,bigE_word0);
      null = FWUL2.forward3(rt,bigE_word0);
      null = FWUL3.forward3(rt,bigE_word0);
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      null = FWUL0.lock4(nextRT);
      null = FWUL1.lock4(nextRT);
      null = FWUL2.lock4(nextRT);
      null = FWUL3.lock4(nextRT);
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] result2;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result2,addr_err> = Dmem.ld_32(addr2);
      byte0 = result2[31:24];
      byte1 = result2[23:16];
      byte2 = result2[15:8];
      byte3 = result2[7:0];
      bigE_word1 = <byte3, byte2, byte1, byte0>;
      /*bigE_word1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word1
      after this convert. -- Tuo*/
      null = FWUL0.forward5(rt,bigE_word0);
      null = FWUL1.forward5(rt,bigE_word0);
      null = FWUL2.forward5(rt,bigE_word0);
      null = FWUL3.forward5(rt,bigE_word0);
      null = FWUL0.forward6(nextRT,bigE_word1);
      null = FWUL1.forward6(nextRT,bigE_word1);
      null = FWUL2.forward6(nextRT,bigE_word1);
      null = FWUL3.forward6(nextRT,bigE_word1);
      null = FWUL0.lock5(nextRT);
      null = FWUL1.lock5(nextRT);
      null = FWUL2.lock5(nextRT);
      null = FWUL3.lock5(nextRT);
    };

    stage 6 :
    {
      null = FWUL0.forward7(rt,bigE_word0);
      null = FWUL1.forward7(rt,bigE_word0);
      null = FWUL2.forward7(rt,bigE_word0);
      null = FWUL3.forward7(rt,bigE_word0);
      null = FWUL0.forward8(nextRT,bigE_word1);
      null = FWUL1.forward8(nextRT,bigE_word1);
      null = FWUL2.forward8(nextRT,bigE_word1);
      null = FWUL3.forward8(nextRT,bigE_word1);
      null = GPR.write0(rt,bigE_word0);
      null = GPR.write1(nextRT,bigE_word1);
    };
  };
  instruction LWL : I
  {
    opecode  opcode = "0000000000101100";

    wire[31:0] source0;
    wire[31:0] source1;
    wire[31:0] source2;
    wire[31:0] addr;
    wire[31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      wire[31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0, source2);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire[29:0] addr_mask;
      wire[1:0] zero2;
      wire[31:0] target;
      wire[31:0] data;
      wire addr_err;
      wire[1:0] vAddr10;
      wire[7:0] data2;
      wire[7:0] data1;
      wire[7:0] data0;
      wire[7:0] reg2;
      wire[7:0] reg1;
      wire[7:0] reg0;
      wire[31:0] result3;
      wire[31:0] result2;
      wire[31:0] result1;
      wire[31:0] result0;
      wire[31:0] bigE_data;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      addr_mask = addr[31:2];
      vAddr10 = addr[1:0];
      zero2 = "00";
      target = <addr_mask,zero2>;
      
      <data,addr_err> = Dmem.ld_32(target);
      
      byte0 = data[31:24];
      byte1 = data[23:16];
      byte2 = data[15:8];
      byte3 = data[7:0];
      bigE_data = <byte3, byte2, byte1, byte0>;
      
      data2 = bigE_data[23:16];
      data1 = bigE_data[15:8];
      data0 = bigE_data[7:0];
      reg2 = source1[23:16];
      reg1 = source1[15:8];
      reg0 = source1[7:0];
      
      result0 = <data0, reg2, reg1, reg0>;
      result1 = <data1, data0, reg1, reg0>;
      result2 = <data2, data1, data0, reg0>;
      result3 = bigE_data;
      result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
      
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction LWR : I
  {
    opecode  opcode = "0000000000101101";

    wire[31:0] source0;
    wire[31:0] source1;
    wire[31:0] source2;
    wire[31:0] addr;
    wire[31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      wire[31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0, source2);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire[29:0] addr_mask;
      wire[1:0] zero2;
      wire[31:0] target;
      wire[31:0] data;
      wire addr_err;
      wire[1:0] vAddr10;
      wire[7:0] data3;
      wire[7:0] data2;
      wire[7:0] data1;
      wire[7:0] reg3;
      wire[7:0] reg2;
      wire[7:0] reg1;
      wire[31:0] result3;
      wire[31:0] result2;
      wire[31:0] result1;
      wire[31:0] result0;
      wire[31:0] bigE_data;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      addr_mask = addr[31:2];
      vAddr10 = addr[1:0];
      zero2 = "00";
      target = <addr_mask,zero2>;
      
      <data,addr_err> = Dmem.ld_32(target);
      byte0 = data[31:24];
      byte1 = data[23:16];
      byte2 = data[15:8];
      byte3 = data[7:0];
      bigE_data = <byte3, byte2, byte1, byte0>;
      /*bigE_data is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_data
      after this convert. -- Tuo*/
      data3 = bigE_data[31:24];
      data2 = bigE_data[23:16];
      data1 = bigE_data[15:8];
      reg3 = source1[31:24];
      reg2 = source1[23:16];
      reg1 = source1[15:8];
      
      result3 = <reg3, reg2, reg1, data3>;
      result2 = <reg3, reg2, data3, data2>;
      result1 = <reg3, data3, data2, data1>;
      result0 = bigE_data;
      result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
      
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction SB : I
  {
    opecode  opcode = "0000000000110000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] addr;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] LE_source1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3, byte2, byte1, byte0>;
      /*LE_source1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source1
      after this convert. -- Tuo*/
      addr_err = Dmem.s_8(addr,LE_source1 /*source1*/);
    };

    stage 6 :
    {
      
    };
  };
  instruction SH : I
  {
    opecode  opcode = "0000000000110010";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] addr;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] LE_source1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3, byte2, byte1, byte0>;
      /*LE_source1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source1
      after this convert. -- Tuo*/
      addr_err = Dmem.s_16(addr,LE_source1 /*source1*/);
    };

    stage 6 :
    {
      
    };
  };
  instruction SW : I
  {
    opecode  opcode = "0000000000110100";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] addr;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] LE_source1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3, byte2, byte1, byte0>;
      /*LE_source1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source1
      after this convert. -- Tuo*/
      addr_err = Dmem.s_32(addr,LE_source1 /*source1*/);
    };

    stage 6 :
    {
      
    };
  };
  instruction DSW : I
  {
    opecode  opcode = "0000000000110101";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] source3;
    wire [31:0] addr1;
    wire [31:0] addr2;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire [31:0] tmp_source3;
      wire [4:0] rt2;
      wire [3:0] oldrt;
      wire one;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; one = '1';
      oldrt = rt[4:1];
      rt2 = <oldrt,one>;
      tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source3 = GPR.read2(rt2);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = EXT1.sign(imm);
      source3 = FWUL2.forward(rt2,tmp_source3);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire cin;
      wire cout;
      wire [31:0] four32bit;
      
      <addr1, flag> = ALU1.add(source0,source2);
      cin = '1';
      four32bit = "00000000000000000000000000000100";
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] LE_source1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3, byte2, byte1, byte0>;
      /*LE_source1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source1
      after this convert. -- Tuo*/
      addr_err = Dmem.s_32(addr1,LE_source1 /*source1*/);
    };

    stage 6 :
    {
      wire addr_err;
      wire [31:0] LE_source3;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source3[31:24];
      byte1 = source3[23:16];
      byte2 = source3[15:8];
      byte3 = source3[7:0];
      LE_source3 = <byte3, byte2, byte1, byte0>;
      /*LE_source3 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source3
      after this convert. -- Tuo*/
      addr_err = Dmem.s_32(addr2,LE_source3 /*source3*/);
    };
  };
  instruction DSZ : I
  {
    opecode  opcode = "0000000000111000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] addr1;
    wire [31:0] addr2;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [4:0] zero5;
      wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; zero5 = "00000";
      tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(zero5);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(zero5,tmp_source1);
      source2 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr1,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      wire cin;
      wire cout;
      wire [31:0] four32bit;
      
      cin = '1';
      four32bit ="00000000000000000000000000000100";
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
    };

    stage 5 :
    {
      wire addr_err;
      
      addr_err = Dmem.s_32(addr1,source1);
    };

    stage 6 :
    {
      wire addr_err;
      
      addr_err = Dmem.s_32(addr2,source1);
    };
  };
  instruction SWL : I
  {
    opecode  opcode = "0000000000111001";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] tmp_pc;
    wire [31:0] addr;
    wire [31:0] result; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0, source2);
    };

    stage 4 :
    {
      wire [29:0] addr_mask;
      wire [1:0] zero2;
      wire [31:0] target;
      wire [31:0] data;
      wire addr_err;
      wire [1:0] vAddr10;
      wire [7:0] data3;
      wire [7:0] data2;
      wire [7:0] data1;
      wire [7:0] reg3;
      wire [7:0] reg2;
      wire [7:0] reg1;
      wire [31:0] result3;
      wire [31:0] result2;
      wire [31:0] result1;
      wire [31:0] result0;
      wire [31:0] nData;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      addr_mask = addr[31:2];
      vAddr10 = addr[1:0];
      zero2 = "00";
      target = <addr_mask, zero2>;
      
      <data, addr_err> = Dmem.ld_32(target);
      
      byte0 = data[31:24];
      byte1 = data[23:16];
      byte2 = data[15:8];
      byte3 = data[7:0];
      nData = <byte3, byte2, byte1, byte0>;
      
      data3 = nData[31:24];
      data2 = nData[23:16];
      data1 = nData[15:8];
      reg3 = source1[31:24];
      reg2 = source1[23:16];
      reg1 = source1[15:8];
      result3 = source1;
      result2 = <data3, reg3, reg2, reg1>;
      result1 = <data3, data2, reg3, reg2>;
      result0 = <data3, data2, data1, reg3>;
      result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
    };

    stage 5 :
    {
      wire addr_err;
      wire [29:0] addr_mask;
      wire [1:0] zero2;
      wire [31:0] target;
      wire [31:0] nResult;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      addr_mask = addr[31:2];
      zero2 = "00";
      target = <addr_mask, zero2>;
      
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      nResult = <byte3, byte2, byte1, byte0>;
      
      addr_err = Dmem.s_32(target, nResult);
    };

    stage 6 :
    {
      
    };
  };
  instruction SWR : I
  {
    opecode  opcode = "0000000000111010";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] tmp_pc;
    wire [31:0] addr;
    wire [31:0] result; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr, flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      wire [29:0] addr_mask;
      wire [1:0] zero2;
      wire [31:0] target;
      wire [31:0] data;
      wire addr_err;
      wire [1:0] vAddr10;
      wire [7:0] data2;
      wire [7:0] data1;
      wire [7:0] data0;
      wire [7:0] reg2;
      wire [7:0] reg1;
      wire [7:0] reg0;
      wire [31:0] result3;
      wire [31:0] result2;
      wire [31:0] result1;
      wire [31:0] result0;
      wire [31:0] nData;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      addr_mask = addr[31:2];
      vAddr10 = addr[1:0];
      zero2 = "00";
      target = <addr_mask, zero2>;
      
      <data, addr_err> = Dmem.ld_32(target);
      
      byte0 = data[31:24];
      byte1 = data[23:16];
      byte2 = data[15:8];
      byte3 = data[7:0];
      nData = <byte3, byte2, byte1, byte0>;
      
      data2 = nData[23:16];
      data1 = nData[15:8];
      data0 = nData[7:0];
      reg2 = source1[23:16];
      reg1 = source1[15:8];
      reg0 = source1[7:0];
      
      result0 = source1;
      result1 = <reg2, reg1, reg0, data0>;
      result2 = <reg1, reg0, data1, data0>;
      result3 = <reg0, data2, data1, data0>;
      result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
    };

    stage 5 :
    {
      wire addr_err;
      wire [29:0] addr_mask;
      wire [1:0] zero2;
      wire [31:0] target;
      wire [31:0] nResult;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      addr_mask = addr[31:2];
      zero2 = "00";
      
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      nResult = <byte3, byte2, byte1, byte0>;
      
      target = <addr_mask, zero2>;
      addr_err = Dmem.s_32(target, nResult);
    };

    stage 6 :
    {
      
    };
  };
  instruction LB_RR : R
  {
    opecode  opcode = "0000000011000000";

    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ld_8(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LBU_RR : R
  {
    opecode  opcode = "0000000011000001";

    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ldu_8(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LH_RR : R
  {
    opecode  opcode = "0000000011000010";

    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ld_16(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LHU_RR : R
  {
    opecode  opcode = "0000000011000011";

    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ldu_16(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LW_RR : R
  {
    opecode  opcode = "0000000011000100";

    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire[3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result,addr_err> = Dmem.ld_32(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      /*bigE_word is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction DLW_RR : R
  {
    opecode  opcode = "0000000011001110";

    wire [31:0] addr1;
    wire [31:0] addr2;
    wire [31:0] bigE_word0;
    wire [31:0] bigE_word1;
    wire [4:0] nextRT;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [3:0] tmpRT;
      wire one;
      
      <addr1,flag> = ALU1.add(source0,source1);
      
      one ='1';
      tmpRT = rt[4:1];
      nextRT = <tmpRT,one>;
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      null = FWUL0.lock2(nextRT);
      null = FWUL1.lock2(nextRT);
      null = FWUL2.lock2(nextRT);
      null = FWUL3.lock2(nextRT);
    };

    stage 4 :
    {
      wire cout;
      wire cin;
      wire [31:0] four32bit;
      wire addr_err;
      wire [31:0] result1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      cin = '0';
      four32bit = "00000000000000000000000000000100";
      
      <result1,addr_err> = Dmem.ld_32(addr1);
      byte0 = result1[31:24];
      byte1 = result1[23:16];
      byte2 = result1[15:8];
      byte3 = result1[7:0];
      bigE_word0 = <byte3, byte2, byte1, byte0>;
      /*bigE_word0 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word0
      after this convert. -- Tuo*/
      null = FWUL0.forward3(rt,bigE_word0);
      null = FWUL1.forward3(rt,bigE_word0);
      null = FWUL2.forward3(rt,bigE_word0);
      null = FWUL3.forward3(rt,bigE_word0);
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      null = FWUL0.lock4(nextRT);
      null = FWUL1.lock4(nextRT);
      null = FWUL2.lock4(nextRT);
      null = FWUL3.lock4(nextRT);
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] result2;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      <result2,addr_err> = Dmem.ld_32(addr2);
      byte0 = result2[31:24];
      byte1 = result2[23:16];
      byte2 = result2[15:8];
      byte3 = result2[7:0];
      bigE_word1 = <byte3, byte2, byte1, byte0>;
      /*bigE_word1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by bigE_word1
      after this convert. -- Tuo*/
      null = FWUL0.forward5(rt,bigE_word0);
      null = FWUL1.forward5(rt,bigE_word0);
      null = FWUL2.forward5(rt,bigE_word0);
      null = FWUL3.forward5(rt,bigE_word0);
      null = FWUL0.forward6(nextRT,bigE_word1);
      null = FWUL1.forward6(nextRT,bigE_word1);
      null = FWUL2.forward6(nextRT,bigE_word1);
      null = FWUL3.forward6(nextRT,bigE_word1);
      null = FWUL0.lock5(nextRT);
      null = FWUL1.lock5(nextRT);
      null = FWUL2.lock5(nextRT);
      null = FWUL3.lock5(nextRT);
    };

    stage 6 :
    {
      null = FWUL0.forward7(rt,bigE_word0);
      null = FWUL1.forward7(rt,bigE_word0);
      null = FWUL2.forward7(rt,bigE_word0);
      null = FWUL3.forward7(rt,bigE_word0);
      null = FWUL0.forward8(nextRT,bigE_word1);
      null = FWUL1.forward8(nextRT,bigE_word1);
      null = FWUL2.forward8(nextRT,bigE_word1);
      null = FWUL3.forward8(nextRT,bigE_word1);
      null = GPR.write0(rt,bigE_word0);
      null = GPR.write1(nextRT,bigE_word1);
    };
  };
  instruction SB_RR : R
  {
    opecode  opcode = "0000000011000110";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] addr;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire [31:0] tmp_source2;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source2 = GPR.read2(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] LE_source1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3, byte2, byte1, byte0>;
      /*LE_source1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source1
      after this convert. -- Tuo*/
      addr_err = Dmem.s_8(addr,LE_source1 /*source1*/);
    };

    stage 6 :
    {
      
    };
  };
  instruction SH_RR : R
  {
    opecode  opcode = "0000000011000111";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] addr;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire [31:0] tmp_source2;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source2 = GPR.read2(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] LE_source1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3, byte2, byte1, byte0>;
      /*LE_source1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source1
      after this convert. -- Tuo*/
      addr_err = Dmem.s_16(addr,LE_source1 /*source1*/);
    };

    stage 6 :
    {
      
    };
  };
  instruction SW_RR : R
  {
    opecode  opcode = "0000000011001000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] addr;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire [31:0] tmp_source2;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source2 = GPR.read2(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] LE_source1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3, byte2, byte1, byte0>;
      /*LE_source1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source1
      after this convert. -- Tuo*/
      addr_err = Dmem.s_32(addr,LE_source1 /*source1*/);
    };

    stage 6 :
    {
      
    };
  };
  instruction DSW_RR : R
  {
    opecode  opcode = "0000000011010000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] source3;
    wire [31:0] addr1;
    wire [31:0] addr2;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [4:0] rt2;
      wire [3:0] oldrt;
      wire one;
      wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire [31:0] tmp_source2;
      wire [31:0] tmp_source3;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; one = '1';
      oldrt = rt[4:1];
      rt2 = <oldrt,one>;
      tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source2 = GPR.read2(rd);
      tmp_source3 = GPR.read3(rt2);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
      source3 = FWUL3.forward(rt2,tmp_source3);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire cin;
      wire cout;
      wire [31:0] four32bit;
      
      <addr1, flag> = ALU1.add(source0,source2);
      cin = '1';
      four32bit = "00000000000000000000000000000100";
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire addr_err;
      wire [31:0] LE_source1;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3, byte2, byte1, byte0>;
      /*LE_source1 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source1
      after this convert. -- Tuo*/
      addr_err = Dmem.s_32(addr1,LE_source1 /*source1*/);
    };

    stage 6 :
    {
      wire addr_err;
      wire [31:0] LE_source3;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      
      byte0 = source3[31:24];
      byte1 = source3[23:16];
      byte2 = source3[15:8];
      byte3 = source3[7:0];
      LE_source3 = <byte3, byte2, byte1, byte0>;
      /*LE_source3 is the output of this macro algorithm,
      which converts a little-endian word to
      big-endian, or vice versa. This macro should be added to
      load/store instructions, where the variable
      e.g."result" should be substituted by LE_source3
      after this convert. -- Tuo*/
      addr_err = Dmem.s_32(addr2,LE_source3 /*source3*/);
    };
  };
  instruction DSZ_RR : R
  {
    opecode  opcode = "0000000011010001";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] source2;
    wire [31:0] addr1;
    wire [31:0] addr2;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [4:0] zero5;
      wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire [31:0] tmp_source2;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; zero5 = "00000";
      tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(zero5);
      tmp_source2 = GPR.read2(rd);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(zero5,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr1,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      wire cin;
      wire cout;
      wire [31:0] four32bit;
      
      cin = '1';
      four32bit ="00000000000000000000000000000100";
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
    };

    stage 5 :
    {
      wire addr_err;
      
      addr_err = Dmem.s_32(addr1,source1);
    };

    stage 6 :
    {
      wire addr_err;
      
      addr_err = Dmem.s_32(addr2,source1);
    };
  };
  instruction JUMP : J
  {
    opecode  opcode = "0000000000000001";

    wire [31:0] result;
    wire [31:0] tmp_pc; wire [25:0] targ;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_cpc;
      wire [1:0] const;
      wire [3:0] cpc_top;
      wire zero1b0;
      wire one1b0;
      
      tmp_ir = IReg.read(); targ = tmp_ir[25:0]; one1b0 = '1';
      zero1b0 = '0';
      const = "00";
      tmp_cpc = CPC.read();
      cpc_top = tmp_cpc[31:28];
      result = <cpc_top,targ,const>;
    };

    stage 3 :
    {
      null = CPC.write(result);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction JAL : J
  {
    opecode  opcode = "0000000000000010";

    wire [31:0] link;
    wire [4:0] linkReg;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [25:0] targ;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_cpc;
      wire [1:0] const;
      wire [3:0] cpc_top;
      
      tmp_ir = IReg.read(); targ = tmp_ir[25:0]; const = "00";
      tmp_cpc = CPC.read();
      link = tmp_cpc;
      cpc_top = tmp_cpc[31:28];
      result = <cpc_top,targ,const>;
      linkReg = "11111";
    };

    stage 3 :
    {
      null = CPC.write(result);
      null = FWUL0.forward1(linkReg,link);
      null = FWUL1.forward1(linkReg,link);
      null = FWUL2.forward1(linkReg,link);
      null = FWUL3.forward1(linkReg,link);
    };

    stage 4 :
    {
      null = FWUL0.forward3(linkReg,link);
      null = FWUL1.forward3(linkReg,link);
      null = FWUL2.forward3(linkReg,link);
      null = FWUL3.forward3(linkReg,link);
    };

    stage 5 :
    {
      null = FWUL0.forward5(linkReg,link);
      null = FWUL1.forward5(linkReg,link);
      null = FWUL2.forward5(linkReg,link);
      null = FWUL3.forward5(linkReg,link);
    };

    stage 6 :
    {
      null = GPR.write0(linkReg,link);
      null = FWUL0.forward7(linkReg,link);
      null = FWUL1.forward7(linkReg,link);
      null = FWUL2.forward7(linkReg,link);
      null = FWUL3.forward7(linkReg,link);
    };
  };
  instruction JR : R
  {
    opecode  opcode = "0000000000000011";

    wire [31:0] target;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source = GPR.read0(rs);
      target = FWUL0.forward(rs,tmp_source);
    };

    stage 3 :
    {
      null =CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction JALR : R
  {
    opecode  opcode = "0000000000000100";

    wire [31:0] target;
    wire [31:0] link;
    wire [4:0] linkReg;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; link = CPC.read();
      tmp_source = GPR.read0(rs);
      target = FWUL0.forward(rs,tmp_source);
    };

    stage 3 :
    {
      null = CPC.write(target);
      linkReg = "11111";
      null = FWUL0.forward1(linkReg,link);
      null = FWUL1.forward1(linkReg,link);
      null = FWUL2.forward1(linkReg,link);
      null = FWUL3.forward1(linkReg,link);
    };

    stage 4 :
    {
      null = FWUL0.forward3(linkReg,link);
      null = FWUL1.forward3(linkReg,link);
      null = FWUL2.forward3(linkReg,link);
      null = FWUL3.forward3(linkReg,link);
    };

    stage 5 :
    {
      null = FWUL0.forward5(linkReg,link);
      null = FWUL1.forward5(linkReg,link);
      null = FWUL2.forward5(linkReg,link);
      null = FWUL3.forward5(linkReg,link);
    };

    stage 6 :
    {
      null = GPR.write0(linkReg,link);
      null = FWUL0.forward7(linkReg,link);
      null = FWUL1.forward7(linkReg,link);
      null = FWUL2.forward7(linkReg,link);
      null = FWUL3.forward7(linkReg,link);
    };
  };
  instruction BEQ : I
  {
    opecode  opcode = "0000000000000101";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] target;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire cin;
      wire cout;
      wire [1:0] zero2;
      wire [31:0] ext_imm;
      wire [29:0] tmp;
      wire [31:0] offset;
      wire [31:0] tmp_cpc;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire zero;
      wire cond;
      wire [3:0] flag;
      
      flag = ALU1.cmp(source0,source1);
      zero = flag[2];
      cond = zero =='1';
      null = [cond] CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BNE : I
  {
    opecode  opcode = "0000000000000110";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] target;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire cin;
      wire cout;
      wire [1:0] zero2;
      wire [31:0] ext_imm;
      wire [29:0] tmp;
      wire [31:0] offset;
      wire [31:0] tmp_cpc;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire zero;
      wire cond;
      wire [3:0] flag;
      
      flag = ALU1.cmp(source0,source1);
      zero = flag[2];
      cond = zero !='1';
      null = [cond] CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BLEZ : I
  {
    opecode  opcode = "0000000000000111";

    wire [31:0] target;
    wire [31:0] src0;
    wire[31:0] source0;
    wire[31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_cpc;
      wire cout;
      wire [31:0] offset;
      wire [31:0] ext_imm;
      wire [29:0] tmp;
      wire [1:0] zero2;
      wire cin;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      src0 = FWU0.forward(rs,tmp_source0);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire cond_tmp;
      wire cond;
      wire [3:0] flag;
      wire N;
      wire Z;
      
      flag = ALU1.cmpz(src0);
      N = flag[1];
      Z = flag[2];
      cond_tmp = N|Z;
      cond = cond_tmp == '1';
      null = [cond] CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BGTZ : I
  {
    opecode  opcode = "0000000000001000";

    wire [31:0] src0;
    wire [31:0] target;
    wire[31:0] source0;
    wire[31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_cpc;
      wire cout;
      wire [31:0] offset;
      wire [31:0] ext_imm;
      wire [29:0] tmp;
      wire [1:0] zero2;
      wire cin;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      src0 = FWU0.forward(rs,tmp_source0);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire cond_tmp;
      wire cond;
      wire [3:0] flag;
      wire N;
      wire Z;
      
      flag = ALU1.cmpz(src0);
      N = flag[1];
      Z = flag[2];
      cond_tmp = N|Z;
      cond = cond_tmp != '1';
      null = [cond] CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BLTZ : I
  {
    opecode  opcode = "0000000000001001";

    wire [31:0] src0;
    wire [31:0] target;
    wire[31:0] source0;
    wire[31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_cpc;
      wire cout;
      wire [31:0] offset;
      wire [31:0] ext_imm;
      wire [29:0] tmp;
      wire [1:0] zero2;
      wire cin;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      src0 = FWU0.forward(rs,tmp_source0);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire cond;
      wire [3:0] flag;
      wire N;
      
      flag = ALU1.cmpz(src0);
      N = flag[1];
      cond = N == '1';
      null = [cond] CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BGEZ : I
  {
    opecode  opcode = "0000000000001010";

    wire [31:0] src0;
    wire [31:0] target;
    wire[31:0] source0;
    wire[31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_cpc;
      wire cout;
      wire [31:0] offset;
      wire [31:0] ext_imm;
      wire [29:0] tmp;
      wire [1:0] zero2;
      wire cin;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      src0 = FWU0.forward(rs,tmp_source0);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire cond;
      wire [3:0] flag;
      wire N;
      
      flag = ALU1.cmpz(src0);
      N = flag[1];
      cond = N != '1';
      null = [cond] CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction ADD : R
  {
    opecode  opcode = "0000000001000000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.add(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction ADDI : I
  {
    opecode  opcode = "0000000001000001";

    wire[31:0] source0;
    wire[31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.add(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction ADDU : R
  {
    opecode  opcode = "0000000001000010";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.addu(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction ADDIU : I
  {
    opecode  opcode = "0000000001000011";

    wire[31:0] source0;
    wire[31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.addu(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction SUB : R
  {
    opecode  opcode = "0000000001000100";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.sub(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SUBU : R
  {
    opecode  opcode = "0000000001000101";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.subu(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction MULT : R
  {
    opecode  opcode = "0000000001000110";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] resulthi;
    wire [31:0] resultlo;
    wire [63:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      result = MUL1.mul(source0,source1);
      resulthi = result[63:32];
      resultlo = result[31:0];
      null = LO.write(resultlo);
      null = HI.write(resulthi);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction MULTU : R
  {
    opecode  opcode = "0000000001000111";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] resulthi;
    wire [31:0] resultlo;
    wire [63:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      result = MUL1.mulu(source0,source1);
      resulthi = result[63:32];
      resultlo = result[31:0];
      null = LO.write(resultlo);
      null = HI.write(resulthi);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction DIV : R
  {
    opecode  opcode = "0000000001001000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] resulthi;
    wire [31:0] resultlo;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire flag;
      
      <resultlo,resulthi,flag> = DIV1.div(source0,source1);
      null = LO.write(resultlo);
      null = HI.write(resulthi);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction DIVU : R
  {
    opecode  opcode = "0000000001001001";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] resulthi;
    wire [31:0] resultlo;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire flag;
      
      <resultlo,resulthi,flag> = DIV1.divu(source0,source1);
      null = LO.write(resultlo);
      null = HI.write(resulthi);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction MFHI : R
  {
    opecode  opcode = "0000000001001010";

    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire zero1b;
      wire one1b0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; one1b0 = '1';
      zero1b = '0';
      result = HI.read();
    };

    stage 3 :
    {
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction MTHI : R
  {
    opecode  opcode = "0000000001001011";

    wire [31:0] source0;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
    };

    stage 3 :
    {
      null = HI.write(source0);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction MFLO : R
  {
    opecode  opcode = "0000000001001100";

    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire zero1b;
      wire one1b0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; one1b0 = '1';
      zero1b = '0';
      result = LO.read();
    };

    stage 3 :
    {
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction MTLO : R
  {
    opecode  opcode = "0000000001001101";

    wire [31:0] source0;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
    };

    stage 3 :
    {
      null = LO.write(source0);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction AND : R
  {
    opecode  opcode = "0000000001001110";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.and(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction ANDI : I
  {
    opecode  opcode = "0000000001001111";

    wire [31:0] result;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.zero(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.and(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction OR : R
  {
    opecode  opcode = "0000000001010000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.or(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction ORI : I
  {
    opecode  opcode = "0000000001010001";

    wire [31:0] result;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.zero(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.or(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction XOR : R
  {
    opecode  opcode = "0000000001010010";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.xor(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction XORI : I
  {
    opecode  opcode = "0000000001010011";

    wire [31:0] result;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.zero(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.xor(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction NOR : R
  {
    opecode  opcode = "0000000001010100";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.nor(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLL : R
  {
    opecode  opcode = "0000000001010101";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [23:0] zero24;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; zero24 = "000000000000000000000000";
      
      tmp_source0 = GPR.read0(rt);
      source0 = FWUL0.forward(rt,tmp_source0);
      source1 = <zero24,shamt>;
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source1[4:0];
      result = SFT1.sll(source0,shift);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLLV : R
  {
    opecode  opcode = "0000000001010110";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source0[4:0];
      result = SFT1.sll(source1,shift);
      /*rs has the shamt*/
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SRL : R
  {
    opecode  opcode = "0000000001010111";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [23:0] zero24;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; zero24 = "000000000000000000000000";
      
      tmp_source0 = GPR.read0(rt);
      source0 = FWUL0.forward(rt,tmp_source0);
      source1 = <zero24,shamt>;
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source1[4:0];
      result = SFT1.srl(source0,shift);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SRLV : R
  {
    opecode  opcode = "0000000001011000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source0[4:0];
      result = SFT1.srl(source1,shift);
      /*rs -> source1 has the shamt*/
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SRA : R
  {
    opecode  opcode = "0000000001011001";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [23:0] zero24;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; zero24 = "000000000000000000000000";
      
      tmp_source0 = GPR.read0(rt);
      source0 = FWUL0.forward(rt,tmp_source0);
      source1 = <zero24,shamt>;
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source1[4:0];
      result = SFT1.sra(source0,shift);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SRAV : R
  {
    opecode  opcode = "0000000001011010";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source0[4:0];
      result = SFT1.sra(source1,shift);
      /*rs -> source1 has the shamt*/
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLT : R
  {
    opecode  opcode = "0000000001011011";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [1:0] flag2;
      wire NnV;
      wire VnN;
      wire cond;
      wire [30:0] zero31;
      
      zero31 = "0000000000000000000000000000000";
      
      flag = ALU1.cmp(source0,source1);
      flag2 = flag[1:0];
      
      NnV = flag2 == "10";
      VnN = flag == "1001";
      cond = NnV | VnN;
      result = <zero31,cond>;
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLTI : I
  {
    opecode  opcode = "0000000001011100";

    wire[31:0] source0;
    wire[31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [1:0] flag2;
      wire NnV;
      wire VnN;
      wire cond;
      wire [30:0] zero31;
      
      zero31 = "0000000000000000000000000000000";
      
      flag = ALU1.cmp(source0,source1);
      flag2 = flag[1:0];
      
      NnV = flag2 == "10";
      VnN = flag == "1001";
      cond = NnV | VnN;
      result = <zero31,cond>;
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction SLTU : R
  {
    opecode  opcode = "0000000001011101";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [1:0] flag2;
      wire cond;
      wire [30:0] zero31;
      
      zero31 = "0000000000000000000000000000000";
      
      flag = ALU1.cmpu(source0,source1);
      flag2 = flag[3:2];
      cond = flag2 == "00";
      result = <zero31,cond>;
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLTIU : I
  {
    opecode  opcode = "0000000001011110";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.zero(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [1:0] flag2;
      wire cond;
      wire [30:0] zero31;
      
      zero31 = "0000000000000000000000000000000";
      
      flag = ALU1.cmpu(source0,source1);
      flag2 = flag[3:2];
      cond = flag2 == "00";
      result = <zero31,cond>;
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction NOP : INH
  {
    opecode  opcode = "0000000000000000";

    wire [31:0] tmp_pc;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       
      
      tmp_ir = IReg.read(); 
    };

    stage 3 :
    {
      
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction LUI : I
  {
    opecode  opcode = "0000000010100010";

    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [15:0] zero16;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; zero16 = "0000000000000000";
      result = <imm,zero16>;
    };

    stage 3 :
    {
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction SYSCALL : INH
  {
    opecode  opcode = "0000000010100000";

    wire [31:0] tmp_cpc;
    wire [31:0] tmp_pc;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       
      
      tmp_ir = IReg.read(); tmp_cpc = CPC.read();
    };

    stage 3 :
    {
      wire [31:0] result;
      
      result = "00000000000000000000000001100000";
      null = SYSREG.write(tmp_cpc);
      null = CPC.write(result);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BREAK : INH
  {
    opecode  opcode = "0000000010100001";

    wire[31:0] tmp_cpc;
    wire [31:0] tmp_pc;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       
      
      tmp_ir = IReg.read(); tmp_cpc = CPC.read();
    };

    stage 3 :
    {
      wire [31:0] result;
      
      null = SYSREG.write(tmp_cpc);
      result = "00000000000000000000000000110000";
      null = CPC.write(result);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction SYSRET : INH
  {
    opecode  opcode = "0000000011111111";

    wire[31:0] result;
    wire [31:0] tmp_pc;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       
      
      tmp_ir = IReg.read(); result = SYSREG.read();
    };

    stage 3 :
    {
      null = CPC.write(result);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction LBm : I
  {
    opecode  opcode = "0101000000100000";

    wire[31:0] addr;
    wire[31:0] bigE_word;
    wire [31:0] tmp_pc;
    wire[31:0] source0;
    wire[31:0] source1; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire[31:0] current_pc;
      wire iramaddr_err; 
      wire[63:0] inst0;
      
      current_pc = CPC.read();
      tmp_pc=current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire[31:0] tmp_source0;
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rrd0;
      wire [2:0] f1_rrd0;
      wire [31:0] f2_rrd0;
      wire [31:0] f3_rrd0;
      wire [31:0] f4_rrd0;
      wire [31:0] f5_rrd0;
      wire [2:0] f6_rrd0;
      wire [135:0] code_rrd0;
      wire [1:0] f0_fwd0;
      wire [2:0] f1_fwd0;
      wire [31:0] f2_fwd0;
      wire [31:0] f3_fwd0;
      wire [31:0] f4_fwd0;
      wire [31:0] f5_fwd0;
      wire [2:0] f6_fwd0;
      wire [135:0] code_fwd0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
      
      cycle = CYCLEWIRE_FORMA_ID.read();
      zero27b = "000000000000000000000000000";
      f0_rrd0 = "00";
      f1_rrd0 = "000";
      f2_rrd0 = <zero27b,rs>;
      f3_rrd0 = tmp_source0;
      f4_rrd0 = cycle;
      f5_rrd0 = tmp_pc;
      f6_rrd0 = "001";
      code_rrd0 = <f0_rrd0,f1_rrd0,f2_rrd0,f3_rrd0,f4_rrd0,f5_rrd0,f6_rrd0>;
      null = DATAOUT_FORMA_ID0.write(code_rrd0);
      
      f0_fwd0 = "00";
      f1_fwd0 = "011";
      f2_fwd0 = <zero27b,rs>;
      f3_fwd0 = source0;
      f4_fwd0 = cycle;
      f5_fwd0 = tmp_pc;
      f6_fwd0 = "001";
      code_fwd0 = <f0_fwd0,f1_fwd0,f2_fwd0,f3_fwd0,f4_fwd0,f5_fwd0,f6_fwd0>;
      null = DATAOUT_FORMA_ID1.write(code_fwd0);
    };

    stage 3 :
    {
      wire[3:0] flag;
      wire [31:0] cycle;
      wire ctrlwire_ex0;
      wire cond_ex0;
      wire [1:0] f0_ex0;
      wire [2:0] f1_ex0;
      wire [31:0] f2_ex0;
      wire [31:0] f3_ex0;
      wire [31:0] f4_ex0;
      wire [31:0] f5_ex0;
      wire [2:0] f6_ex0;
      wire [135:0] code_ex0;
      wire ctrlwire_ex1;
      wire cond_ex1;
      wire ctrlwire_ex2;
      wire cond_ex2;
      
      <addr,flag> = ALU1.add(source0,source1);
      
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      
      cycle = CYCLEWIRE_FORMA_EX.read();
      ctrlwire_ex0 = CTRLWIRE_FORMA_EX0.read();
      cond_ex0 = ctrlwire_ex0 == '1';
      f0_ex0 = "10";
      f1_ex0 = "100";
      f2_ex0 = "00000000000000000000000000000000";
      f3_ex0 = "00000000000000000000000000000000";
      f4_ex0 = cycle;
      f5_ex0 = tmp_pc;
      f6_ex0 = "010";
      code_ex0 = <f0_ex0,f1_ex0,f2_ex0,f3_ex0,f4_ex0,f5_ex0,f6_ex0>;
      null = [cond_ex0]DATAOUT_FORMA_EX0.write(code_ex0);
      
      ctrlwire_ex1 = CTRLWIRE_FORMA_EX1.read();
      cond_ex1 = ctrlwire_ex1 == '1';
      null = [cond_ex1]DATAOUT_FORMA_EX1.write(code_ex0);
      
      ctrlwire_ex2 = CTRLWIRE_FORMA_EX2.read();
      cond_ex2 = ctrlwire_ex2 == '1';
      null = [cond_ex2]DATAOUT_FORMA_EX2.write(code_ex0);
    };

    stage 4 :
    {
      wire addr_err;
      wire[31:0] result;
      wire [7:0] byte0;
      wire [7:0] byte1;
      wire [7:0] byte2;
      wire [7:0] byte3;
      wire [31:0] cycle;
      wire ctrlwire_m10;
      wire cond_m10;
      wire [1:0] f0_m10;
      wire [2:0] f1_m10;
      wire [31:0] f2_m10;
      wire [31:0] f3_m10;
      wire [31:0] f4_m10;
      wire [31:0] f5_m10;
      wire [2:0] f6_m10;
      wire [135:0] code_m10;
      wire ctrlwire_m11;
      wire cond_m11;
      wire ctrlwire_m12;
      wire cond_m12;
      wire [1:0] f0_mrd;
      wire [2:0] f1_mrd;
      wire [31:0] f2_mrd;
      wire [31:0] f3_mrd;
      wire [31:0] f4_mrd;
      wire [31:0] f5_mrd;
      wire [2:0] f6_mrd;
      wire [135:0] code_mrd;
      
      <result,addr_err> = Dmem.ld_8(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3, byte2, byte1, byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      
      cycle = CYCLEWIRE_FORMA_M1.read();
      ctrlwire_m10 = CTRLWIRE_FORMA_M10.read();
      cond_m10 = ctrlwire_m10 == '1';
      f0_m10 = "10";
      f1_m10 = "001";
      f2_m10 = "00000000000000000000000000000000";
      f3_m10 = "00000000000000000000000000000000";
      f4_m10 = cycle;
      f5_m10 = tmp_pc;
      f6_m10 = "011";
      code_m10 = <f0_m10,f1_m10,f2_m10,f3_m10,f4_m10,f5_m10,f6_m10>;
      null = [cond_m10]DATAOUT_FORMA_M10.write(code_m10);
      
      ctrlwire_m11 = CTRLWIRE_FORMA_M11.read();
      cond_m11 = ctrlwire_m11 == '1';
      null = [cond_m11]DATAOUT_FORMA_M11.write(code_m10);
      
      ctrlwire_m12 = CTRLWIRE_FORMA_M12.read();
      cond_m12 = ctrlwire_m12 == '1';
      null = [cond_m12]DATAOUT_FORMA_M12.write(code_m10);
      
      f0_mrd = "00";
      f1_mrd = "001";
      f2_mrd = addr;
      f3_mrd = bigE_word;
      f4_mrd = cycle;
      f5_mrd = tmp_pc;
      f6_mrd = "011";
      code_mrd = <f0_mrd,f1_mrd,f2_mrd,f3_mrd,f4_mrd,f5_mrd,f6_mrd>;
      null = DATAOUT_FORMA_M13.write(code_mrd);
    };

    stage 5 :
    {
      wire [31:0] cycle;
      wire ctrlwire_m20;
      wire cond_m20;
      wire [1:0] f0_m20;
      wire [2:0] f1_m20;
      wire [31:0] f2_m20;
      wire [31:0] f3_m20;
      wire [31:0] f4_m20;
      wire [31:0] f5_m20;
      wire [2:0] f6_m20;
      wire [135:0] code_m20;
      wire ctrlwire_m21;
      wire cond_m21;
      wire ctrlwire_m22;
      wire cond_m22;
      wire ctrlwire_m23;
      wire cond_m23;
      
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
      
      cycle = CYCLEWIRE_FORMA_M2.read();
      ctrlwire_m20 = CTRLWIRE_FORMA_M20.read();
      cond_m20 = ctrlwire_m20 == '1';
      f0_m20 = "10";
      f1_m20 = "001";
      f2_m20 = "00000000000000000000000000000000";
      f3_m20 = "00000000000000000000000000000000";
      f4_m20 = cycle;
      f5_m20 = tmp_pc;
      f6_m20 = "100";
      code_m20 = <f0_m20,f1_m20,f2_m20,f3_m20,f4_m20,f5_m20,f6_m20>;
      null = [cond_m20]DATAOUT_FORMA_M20.write(code_m20);
      
      ctrlwire_m21 = CTRLWIRE_FORMA_M21.read();
      cond_m21 = ctrlwire_m21 == '1';
      null = [cond_m21]DATAOUT_FORMA_M21.write(code_m20);
      
      ctrlwire_m22 = CTRLWIRE_FORMA_M22.read();
      cond_m22 = ctrlwire_m22 == '1';
      null = [cond_m22]DATAOUT_FORMA_M22.write(code_m20);
      
      ctrlwire_m23 = CTRLWIRE_FORMA_M23.read();
      cond_m23 = ctrlwire_m23 == '1';
      null = [cond_m23]DATAOUT_FORMA_M23.write(code_m20);
    };

    stage 6 :
    {
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rwr0;
      wire [2:0] f1_rwr0;
      wire [31:0] f2_rwr0;
      wire [31:0] f3_rwr0;
      wire [31:0] f4_rwr0;
      wire [31:0] f5_rwr0;
      wire [2:0] f6_rwr0;
      wire [135:0] code_rwr0;
      
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      
      cycle = CYCLEWIRE_FORMA_WB.read();
      zero27b = "000000000000000000000000000";
      f0_rwr0 = "01";
      f1_rwr0 = "000";
      f2_rwr0 = <zero27b,rt>;
      f3_rwr0 = bigE_word;
      f4_rwr0 = cycle;
      f5_rwr0 = tmp_pc;
      f6_rwr0 = "101";
      code_rwr0 = <f0_rwr0,f1_rwr0,f2_rwr0,f3_rwr0,f4_rwr0,f5_rwr0,f6_rwr0>;
      null = DATAOUT_FORMA_WB0.write(code_rwr0);
    };
  };
  instruction LBUm : I
  {
    opecode  opcode = "0101000000100010";

    wire [31:0] bigE_word;
    wire [31:0] addr;
    wire [31:0] tmp_pc;
    wire[31:0] source0;
    wire[31:0] source1; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rrd0;
      wire [2:0] f1_rrd0;
      wire [31:0] f2_rrd0;
      wire [31:0] f3_rrd0;
      wire [31:0] f4_rrd0;
      wire [31:0] f5_rrd0;
      wire [2:0] f6_rrd0;
      wire [135:0] code_rrd0;
      wire [1:0] f0_fwd0;
      wire [2:0] f1_fwd0;
      wire [31:0] f2_fwd0;
      wire [31:0] f3_fwd0;
      wire [31:0] f4_fwd0;
      wire [31:0] f5_fwd0;
      wire [2:0] f6_fwd0;
      wire [135:0] code_fwd0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
      cycle = CYCLEWIRE_FORMA_ID.read();
      zero27b = "000000000000000000000000000";
      f0_rrd0 = "00";
      f1_rrd0 = "000";
      f2_rrd0 = <zero27b,rs>;
      f3_rrd0 = tmp_source0;
      f4_rrd0 = cycle;
      f5_rrd0 = tmp_pc;
      f6_rrd0 = "001";
      code_rrd0 = <f0_rrd0,f1_rrd0,f2_rrd0,f3_rrd0,f4_rrd0,f5_rrd0,f6_rrd0>;
      null = DATAOUT_FORMA_ID0.write(code_rrd0);
      
      f0_fwd0 = "00";
      f1_fwd0 = "011";
      f2_fwd0 = <zero27b,rs>;
      f3_fwd0 = source0;
      f4_fwd0 = cycle;
      f5_fwd0 = tmp_pc;
      f6_fwd0 = "001";
      code_fwd0 = <f0_fwd0,f1_fwd0,f2_fwd0,f3_fwd0,f4_fwd0,f5_fwd0,f6_fwd0>;
      null = DATAOUT_FORMA_ID1.write(code_fwd0);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [31:0] cycle;
      wire ctrlwire_ex0;
      wire cond_ex0;
      wire [1:0] f0_ex0;
      wire [2:0] f1_ex0;
      wire [31:0] f2_ex0;
      wire [31:0] f3_ex0;
      wire [31:0] f4_ex0;
      wire [31:0] f5_ex0;
      wire [2:0] f6_ex0;
      wire [135:0] code_ex0;
      wire ctrlwire_ex1;
      wire cond_ex1;
      wire ctrlwire_ex2;
      wire cond_ex2;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      
      cycle = CYCLEWIRE_FORMA_EX.read();
      ctrlwire_ex0 = CTRLWIRE_FORMA_EX0.read();
      cond_ex0 = ctrlwire_ex0 == '1';
      f0_ex0 = "10";
      f1_ex0 = "100";
      f2_ex0 = "00000000000000000000000000000000";
      f3_ex0 = "00000000000000000000000000000000";
      f4_ex0 = cycle;
      f5_ex0 = tmp_pc;
      f6_ex0 = "010";
      code_ex0 = <f0_ex0,f1_ex0,f2_ex0,f3_ex0,f4_ex0,f5_ex0,f6_ex0>;
      null = [cond_ex0]DATAOUT_FORMA_EX0.write(code_ex0);
      
      ctrlwire_ex1 = CTRLWIRE_FORMA_EX1.read();
      cond_ex1 = ctrlwire_ex1 == '1';
      null = [cond_ex1]DATAOUT_FORMA_EX1.write(code_ex0);
      
      ctrlwire_ex2 = CTRLWIRE_FORMA_EX2.read();
      cond_ex2 = ctrlwire_ex2 == '1';
      null = [cond_ex2]DATAOUT_FORMA_EX2.write(code_ex0);
    };

    stage 4 :
    {
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [31:0] result;
      wire  addr_err;
      wire [31:0] cycle;
      wire ctrlwire_m10;
      wire cond_m10;
      wire [1:0] f0_m10;
      wire [2:0] f1_m10;
      wire [31:0] f2_m10;
      wire [31:0] f3_m10;
      wire [31:0] f4_m10;
      wire [31:0] f5_m10;
      wire [2:0] f6_m10;
      wire [135:0] code_m10;
      wire ctrlwire_m11;
      wire cond_m11;
      wire ctrlwire_m12;
      wire cond_m12;
      wire [1:0] f0_mrd;
      wire [2:0] f1_mrd;
      wire [31:0] f2_mrd;
      wire [31:0] f3_mrd;
      wire [31:0] f4_mrd;
      wire [31:0] f5_mrd;
      wire [2:0] f6_mrd;
      wire [135:0] code_mrd;
      
      <result,addr_err> = Dmem.ldu_8(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      
      cycle = CYCLEWIRE_FORMA_M1.read();
      ctrlwire_m10 = CTRLWIRE_FORMA_M10.read();
      cond_m10 = ctrlwire_m10 == '1';
      f0_m10 = "10";
      f1_m10 = "001";
      f2_m10 = "00000000000000000000000000000000";
      f3_m10 = "00000000000000000000000000000000";
      f4_m10 = cycle;
      f5_m10 = tmp_pc;
      f6_m10 = "011";
      code_m10 = <f0_m10,f1_m10,f2_m10,f3_m10,f4_m10,f5_m10,f6_m10>;
      null = [cond_m10]DATAOUT_FORMA_M10.write(code_m10);
      
      ctrlwire_m11 = CTRLWIRE_FORMA_M11.read();
      cond_m11 = ctrlwire_m11 == '1';
      null = [cond_m11]DATAOUT_FORMA_M11.write(code_m10);
      
      ctrlwire_m12 = CTRLWIRE_FORMA_M12.read();
      cond_m12 = ctrlwire_m12 == '1';
      null = [cond_m12]DATAOUT_FORMA_M12.write(code_m10);
      
      f0_mrd = "00";
      f1_mrd = "001";
      f2_mrd = addr;
      f3_mrd = bigE_word;
      f4_mrd = cycle;
      f5_mrd = tmp_pc;
      f6_mrd = "011";
      code_mrd = <f0_mrd,f1_mrd,f2_mrd,f3_mrd,f4_mrd,f5_mrd,f6_mrd>;
      null = DATAOUT_FORMA_M13.write(code_mrd);
    };

    stage 5 :
    {
      wire [31:0] cycle;
      wire ctrlwire_m20;
      wire cond_m20;
      wire [1:0] f0_m20;
      wire [2:0] f1_m20;
      wire [31:0] f2_m20;
      wire [31:0] f3_m20;
      wire [31:0] f4_m20;
      wire [31:0] f5_m20;
      wire [2:0] f6_m20;
      wire [135:0] code_m20;
      wire ctrlwire_m21;
      wire cond_m21;
      wire ctrlwire_m22;
      wire cond_m22;
      wire ctrlwire_m23;
      wire cond_m23;
      
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
      
      cycle = CYCLEWIRE_FORMA_M2.read();
      ctrlwire_m20 = CTRLWIRE_FORMA_M20.read();
      cond_m20 = ctrlwire_m20 == '1';
      f0_m20 = "10";
      f1_m20 = "001";
      f2_m20 = "00000000000000000000000000000000";
      f3_m20 = "00000000000000000000000000000000";
      f4_m20 = cycle;
      f5_m20 = tmp_pc;
      f6_m20 = "100";
      code_m20 = <f0_m20,f1_m20,f2_m20,f3_m20,f4_m20,f5_m20,f6_m20>;
      null = [cond_m20]DATAOUT_FORMA_M20.write(code_m20);
      
      ctrlwire_m21 = CTRLWIRE_FORMA_M21.read();
      cond_m21 = ctrlwire_m21 == '1';
      null = [cond_m21]DATAOUT_FORMA_M21.write(code_m20);
      
      ctrlwire_m22 = CTRLWIRE_FORMA_M22.read();
      cond_m22 = ctrlwire_m22 == '1';
      null = [cond_m22]DATAOUT_FORMA_M22.write(code_m20);
      
      ctrlwire_m23 = CTRLWIRE_FORMA_M23.read();
      cond_m23 = ctrlwire_m23 == '1';
      null = [cond_m23]DATAOUT_FORMA_M23.write(code_m20);
    };

    stage 6 :
    {
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rwr0;
      wire [2:0] f1_rwr0;
      wire [31:0] f2_rwr0;
      wire [31:0] f3_rwr0;
      wire [31:0] f4_rwr0;
      wire [31:0] f5_rwr0;
      wire [2:0] f6_rwr0;
      wire [135:0] code_rwr0;
      
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
      cycle = CYCLEWIRE_FORMA_WB.read();
      zero27b = "000000000000000000000000000";
      f0_rwr0 = "01";
      f1_rwr0 = "000";
      f2_rwr0 = <zero27b,rt>;
      f3_rwr0 = bigE_word;
      f4_rwr0 = cycle;
      f5_rwr0 = tmp_pc;
      f6_rwr0 = "101";
      code_rwr0 = <f0_rwr0,f1_rwr0,f2_rwr0,f3_rwr0,f4_rwr0,f5_rwr0,f6_rwr0>;
      null = DATAOUT_FORMA_WB0.write(code_rwr0);
    };
  };
  instruction LHm : I
  {
    opecode  opcode = "0101000000100100";

    wire [31:0] bigE_word;
    wire [31:0] addr;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rrd0;
      wire [2:0] f1_rrd0;
      wire [31:0] f2_rrd0;
      wire [31:0] f3_rrd0;
      wire [31:0] f4_rrd0;
      wire [31:0] f5_rrd0;
      wire [2:0] f6_rrd0;
      wire [135:0] code_rrd0;
      wire [1:0] f0_fwd0;
      wire [2:0] f1_fwd0;
      wire [31:0] f2_fwd0;
      wire [31:0] f3_fwd0;
      wire [31:0] f4_fwd0;
      wire [31:0] f5_fwd0;
      wire [2:0] f6_fwd0;
      wire [135:0] code_fwd0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
      
      cycle = CYCLEWIRE_FORMA_ID.read();
      zero27b = "000000000000000000000000000";
      f0_rrd0 = "00";
      f1_rrd0 = "000";
      f2_rrd0 = <zero27b,rs>;
      f3_rrd0 = tmp_source0;
      f4_rrd0 = cycle;
      f5_rrd0 = tmp_pc;
      f6_rrd0 = "001";
      code_rrd0 = <f0_rrd0,f1_rrd0,f2_rrd0,f3_rrd0,f4_rrd0,f5_rrd0,f6_rrd0>;
      null = DATAOUT_FORMA_ID0.write(code_rrd0);
      
      f0_fwd0 = "00";
      f1_fwd0 = "011";
      f2_fwd0 = <zero27b,rs>;
      f3_fwd0 = source0;
      f4_fwd0 = cycle;
      f5_fwd0 = tmp_pc;
      f6_fwd0 = "001";
      code_fwd0 = <f0_fwd0,f1_fwd0,f2_fwd0,f3_fwd0,f4_fwd0,f5_fwd0,f6_fwd0>;
      null = DATAOUT_FORMA_ID1.write(code_fwd0);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [31:0] cycle;
      wire ctrlwire_ex0;
      wire cond_ex0;
      wire [1:0] f0_ex0;
      wire [2:0] f1_ex0;
      wire [31:0] f2_ex0;
      wire [31:0] f3_ex0;
      wire [31:0] f4_ex0;
      wire [31:0] f5_ex0;
      wire [2:0] f6_ex0;
      wire [135:0] code_ex0;
      wire ctrlwire_ex1;
      wire cond_ex1;
      wire ctrlwire_ex2;
      wire cond_ex2;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      
      cycle = CYCLEWIRE_FORMA_EX.read();
      ctrlwire_ex0 = CTRLWIRE_FORMA_EX0.read();
      cond_ex0 = ctrlwire_ex0 == '1';
      f0_ex0 = "10";
      f1_ex0 = "100";
      f2_ex0 = "00000000000000000000000000000000";
      f3_ex0 = "00000000000000000000000000000000";
      f4_ex0 = cycle;
      f5_ex0 = tmp_pc;
      f6_ex0 = "010";
      code_ex0 = <f0_ex0,f1_ex0,f2_ex0,f3_ex0,f4_ex0,f5_ex0,f6_ex0>;
      null = [cond_ex0]DATAOUT_FORMA_EX0.write(code_ex0);
      
      ctrlwire_ex1 = CTRLWIRE_FORMA_EX1.read();
      cond_ex1 = ctrlwire_ex1 == '1';
      null = [cond_ex1]DATAOUT_FORMA_EX1.write(code_ex0);
      
      ctrlwire_ex2 = CTRLWIRE_FORMA_EX2.read();
      cond_ex2 = ctrlwire_ex2 == '1';
      null = [cond_ex2]DATAOUT_FORMA_EX2.write(code_ex0);
    };

    stage 4 :
    {
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [31:0] result;
      wire  addr_err;
      wire [31:0] cycle;
      wire ctrlwire_m10;
      wire cond_m10;
      wire [1:0] f0_m10;
      wire [2:0] f1_m10;
      wire [31:0] f2_m10;
      wire [31:0] f3_m10;
      wire [31:0] f4_m10;
      wire [31:0] f5_m10;
      wire [2:0] f6_m10;
      wire [135:0] code_m10;
      wire ctrlwire_m11;
      wire cond_m11;
      wire ctrlwire_m12;
      wire cond_m12;
      wire [1:0] f0_mrd;
      wire [2:0] f1_mrd;
      wire [31:0] f2_mrd;
      wire [31:0] f3_mrd;
      wire [31:0] f4_mrd;
      wire [31:0] f5_mrd;
      wire [2:0] f6_mrd;
      wire [135:0] code_mrd;
      
      <result,addr_err> = Dmem.ld_16(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      
      cycle = CYCLEWIRE_FORMA_M1.read();
      ctrlwire_m10 = CTRLWIRE_FORMA_M10.read();
      cond_m10 = ctrlwire_m10 == '1';
      f0_m10 = "10";
      f1_m10 = "001";
      f2_m10 = "00000000000000000000000000000000";
      f3_m10 = "00000000000000000000000000000000";
      f4_m10 = cycle;
      f5_m10 = tmp_pc;
      f6_m10 = "011";
      code_m10 = <f0_m10,f1_m10,f2_m10,f3_m10,f4_m10,f5_m10,f6_m10>;
      null = [cond_m10]DATAOUT_FORMA_M10.write(code_m10);
      
      ctrlwire_m11 = CTRLWIRE_FORMA_M11.read();
      cond_m11 = ctrlwire_m11 == '1';
      null = [cond_m11]DATAOUT_FORMA_M11.write(code_m10);
      
      ctrlwire_m12 = CTRLWIRE_FORMA_M12.read();
      cond_m12 = ctrlwire_m12 == '1';
      null = [cond_m12]DATAOUT_FORMA_M12.write(code_m10);
      
      f0_mrd = "00";
      f1_mrd = "001";
      f2_mrd = addr;
      f3_mrd = bigE_word;
      f4_mrd = cycle;
      f5_mrd = tmp_pc;
      f6_mrd = "011";
      code_mrd = <f0_mrd,f1_mrd,f2_mrd,f3_mrd,f4_mrd,f5_mrd,f6_mrd>;
      null = DATAOUT_FORMA_M13.write(code_mrd);
    };

    stage 5 :
    {
      wire [31:0] cycle;
      wire ctrlwire_m20;
      wire cond_m20;
      wire [1:0] f0_m20;
      wire [2:0] f1_m20;
      wire [31:0] f2_m20;
      wire [31:0] f3_m20;
      wire [31:0] f4_m20;
      wire [31:0] f5_m20;
      wire [2:0] f6_m20;
      wire [135:0] code_m20;
      wire ctrlwire_m21;
      wire cond_m21;
      wire ctrlwire_m22;
      wire cond_m22;
      wire ctrlwire_m23;
      wire cond_m23;
      
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
      
      cycle = CYCLEWIRE_FORMA_M2.read();
      ctrlwire_m20 = CTRLWIRE_FORMA_M20.read();
      cond_m20 = ctrlwire_m20 == '1';
      f0_m20 = "10";
      f1_m20 = "001";
      f2_m20 = "00000000000000000000000000000000";
      f3_m20 = "00000000000000000000000000000000";
      f4_m20 = cycle;
      f5_m20 = tmp_pc;
      f6_m20 = "100";
      code_m20 = <f0_m20,f1_m20,f2_m20,f3_m20,f4_m20,f5_m20,f6_m20>;
      null = [cond_m20]DATAOUT_FORMA_M20.write(code_m20);
      
      ctrlwire_m21 = CTRLWIRE_FORMA_M21.read();
      cond_m21 = ctrlwire_m21 == '1';
      null = [cond_m21]DATAOUT_FORMA_M21.write(code_m20);
      
      ctrlwire_m22 = CTRLWIRE_FORMA_M22.read();
      cond_m22 = ctrlwire_m22 == '1';
      null = [cond_m22]DATAOUT_FORMA_M22.write(code_m20);
      
      ctrlwire_m23 = CTRLWIRE_FORMA_M23.read();
      cond_m23 = ctrlwire_m23 == '1';
      null = [cond_m23]DATAOUT_FORMA_M23.write(code_m20);
    };

    stage 6 :
    {
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rwr0;
      wire [2:0] f1_rwr0;
      wire [31:0] f2_rwr0;
      wire [31:0] f3_rwr0;
      wire [31:0] f4_rwr0;
      wire [31:0] f5_rwr0;
      wire [2:0] f6_rwr0;
      wire [135:0] code_rwr0;
      
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
      
      cycle = CYCLEWIRE_FORMA_WB.read();
      zero27b = "000000000000000000000000000";
      f0_rwr0 = "01";
      f1_rwr0 = "000";
      f2_rwr0 = <zero27b,rt>;
      f3_rwr0 = bigE_word;
      f4_rwr0 = cycle;
      f5_rwr0 = tmp_pc;
      f6_rwr0 = "101";
      code_rwr0 = <f0_rwr0,f1_rwr0,f2_rwr0,f3_rwr0,f4_rwr0,f5_rwr0,f6_rwr0>;
      null = DATAOUT_FORMA_WB0.write(code_rwr0);
    };
  };
  instruction LHUm : I
  {
    opecode  opcode = "0101000000100110";

    wire [31:0] bigE_word;
    wire [31:0] addr;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rrd0;
      wire [2:0] f1_rrd0;
      wire [31:0] f2_rrd0;
      wire [31:0] f3_rrd0;
      wire [31:0] f4_rrd0;
      wire [31:0] f5_rrd0;
      wire [2:0] f6_rrd0;
      wire [135:0] code_rrd0;
      wire [1:0] f0_fwd0;
      wire [2:0] f1_fwd0;
      wire [31:0] f2_fwd0;
      wire [31:0] f3_fwd0;
      wire [31:0] f4_fwd0;
      wire [31:0] f5_fwd0;
      wire [2:0] f6_fwd0;
      wire [135:0] code_fwd0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
      
      cycle = CYCLEWIRE_FORMA_ID.read();
      zero27b = "000000000000000000000000000";
      f0_rrd0 = "00";
      f1_rrd0 = "000";
      f2_rrd0 = <zero27b,rs>;
      f3_rrd0 = tmp_source0;
      f4_rrd0 = cycle;
      f5_rrd0 = tmp_pc;
      f6_rrd0 = "001";
      code_rrd0 = <f0_rrd0,f1_rrd0,f2_rrd0,f3_rrd0,f4_rrd0,f5_rrd0,f6_rrd0>;
      null = DATAOUT_FORMA_ID0.write(code_rrd0);
      
      f0_fwd0 = "00";
      f1_fwd0 = "011";
      f2_fwd0 = <zero27b,rs>;
      f3_fwd0 = source0;
      f4_fwd0 = cycle;
      f5_fwd0 = tmp_pc;
      f6_fwd0 = "001";
      code_fwd0 = <f0_fwd0,f1_fwd0,f2_fwd0,f3_fwd0,f4_fwd0,f5_fwd0,f6_fwd0>;
      null = DATAOUT_FORMA_ID1.write(code_fwd0);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [31:0] cycle;
      wire ctrlwire_ex0;
      wire cond_ex0;
      wire [1:0] f0_ex0;
      wire [2:0] f1_ex0;
      wire [31:0] f2_ex0;
      wire [31:0] f3_ex0;
      wire [31:0] f4_ex0;
      wire [31:0] f5_ex0;
      wire [2:0] f6_ex0;
      wire [135:0] code_ex0;
      wire ctrlwire_ex1;
      wire cond_ex1;
      wire ctrlwire_ex2;
      wire cond_ex2;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      
      cycle = CYCLEWIRE_FORMA_EX.read();
      ctrlwire_ex0 = CTRLWIRE_FORMA_EX0.read();
      cond_ex0 = ctrlwire_ex0 == '1';
      f0_ex0 = "10";
      f1_ex0 = "100";
      f2_ex0 = "00000000000000000000000000000000";
      f3_ex0 = "00000000000000000000000000000000";
      f4_ex0 = cycle;
      f5_ex0 = tmp_pc;
      f6_ex0 = "010";
      code_ex0 = <f0_ex0,f1_ex0,f2_ex0,f3_ex0,f4_ex0,f5_ex0,f6_ex0>;
      null = [cond_ex0]DATAOUT_FORMA_EX0.write(code_ex0);
      
      ctrlwire_ex1 = CTRLWIRE_FORMA_EX1.read();
      cond_ex1 = ctrlwire_ex1 == '1';
      null = [cond_ex1]DATAOUT_FORMA_EX1.write(code_ex0);
      
      ctrlwire_ex2 = CTRLWIRE_FORMA_EX2.read();
      cond_ex2 = ctrlwire_ex2 == '1';
      null = [cond_ex2]DATAOUT_FORMA_EX2.write(code_ex0);
    };

    stage 4 :
    {
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [31:0] result;
      wire  addr_err;
      wire [31:0] cycle;
      wire ctrlwire_m10;
      wire cond_m10;
      wire [1:0] f0_m10;
      wire [2:0] f1_m10;
      wire [31:0] f2_m10;
      wire [31:0] f3_m10;
      wire [31:0] f4_m10;
      wire [31:0] f5_m10;
      wire [2:0] f6_m10;
      wire [135:0] code_m10;
      wire ctrlwire_m11;
      wire cond_m11;
      wire ctrlwire_m12;
      wire cond_m12;
      wire [1:0] f0_mrd;
      wire [2:0] f1_mrd;
      wire [31:0] f2_mrd;
      wire [31:0] f3_mrd;
      wire [31:0] f4_mrd;
      wire [31:0] f5_mrd;
      wire [2:0] f6_mrd;
      wire [135:0] code_mrd;
      
      <result,addr_err> = Dmem.ldu_16(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      
      cycle = CYCLEWIRE_FORMA_M1.read();
      ctrlwire_m10 = CTRLWIRE_FORMA_M10.read();
      cond_m10 = ctrlwire_m10 == '1';
      f0_m10 = "10";
      f1_m10 = "001";
      f2_m10 = "00000000000000000000000000000000";
      f3_m10 = "00000000000000000000000000000000";
      f4_m10 = cycle;
      f5_m10 = tmp_pc;
      f6_m10 = "011";
      code_m10 = <f0_m10,f1_m10,f2_m10,f3_m10,f4_m10,f5_m10,f6_m10>;
      null = [cond_m10]DATAOUT_FORMA_M10.write(code_m10);
      
      ctrlwire_m11 = CTRLWIRE_FORMA_M11.read();
      cond_m11 = ctrlwire_m11 == '1';
      null = [cond_m11]DATAOUT_FORMA_M11.write(code_m10);
      
      ctrlwire_m12 = CTRLWIRE_FORMA_M12.read();
      cond_m12 = ctrlwire_m12 == '1';
      null = [cond_m12]DATAOUT_FORMA_M12.write(code_m10);
      
      f0_mrd = "00";
      f1_mrd = "001";
      f2_mrd = addr;
      f3_mrd = bigE_word;
      f4_mrd = cycle;
      f5_mrd = tmp_pc;
      f6_mrd = "011";
      code_mrd = <f0_mrd,f1_mrd,f2_mrd,f3_mrd,f4_mrd,f5_mrd,f6_mrd>;
      null = DATAOUT_FORMA_M13.write(code_mrd);
    };

    stage 5 :
    {
      wire [31:0] cycle;
      wire ctrlwire_m20;
      wire cond_m20;
      wire [1:0] f0_m20;
      wire [2:0] f1_m20;
      wire [31:0] f2_m20;
      wire [31:0] f3_m20;
      wire [31:0] f4_m20;
      wire [31:0] f5_m20;
      wire [2:0] f6_m20;
      wire [135:0] code_m20;
      wire ctrlwire_m21;
      wire cond_m21;
      wire ctrlwire_m22;
      wire cond_m22;
      wire ctrlwire_m23;
      wire cond_m23;
      
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
      
      cycle = CYCLEWIRE_FORMA_M2.read();
      ctrlwire_m20 = CTRLWIRE_FORMA_M20.read();
      cond_m20 = ctrlwire_m20 == '1';
      f0_m20 = "10";
      f1_m20 = "001";
      f2_m20 = "00000000000000000000000000000000";
      f3_m20 = "00000000000000000000000000000000";
      f4_m20 = cycle;
      f5_m20 = tmp_pc;
      f6_m20 = "100";
      code_m20 = <f0_m20,f1_m20,f2_m20,f3_m20,f4_m20,f5_m20,f6_m20>;
      null = [cond_m20]DATAOUT_FORMA_M20.write(code_m20);
      
      ctrlwire_m21 = CTRLWIRE_FORMA_M21.read();
      cond_m21 = ctrlwire_m21 == '1';
      null = [cond_m21]DATAOUT_FORMA_M21.write(code_m20);
      
      ctrlwire_m22 = CTRLWIRE_FORMA_M22.read();
      cond_m22 = ctrlwire_m22 == '1';
      null = [cond_m22]DATAOUT_FORMA_M22.write(code_m20);
      
      ctrlwire_m23 = CTRLWIRE_FORMA_M23.read();
      cond_m23 = ctrlwire_m23 == '1';
      null = [cond_m23]DATAOUT_FORMA_M23.write(code_m20);
    };

    stage 6 :
    {
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rwr0;
      wire [2:0] f1_rwr0;
      wire [31:0] f2_rwr0;
      wire [31:0] f3_rwr0;
      wire [31:0] f4_rwr0;
      wire [31:0] f5_rwr0;
      wire [2:0] f6_rwr0;
      wire [135:0] code_rwr0;
      
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
      
      cycle = CYCLEWIRE_FORMA_WB.read();
      zero27b = "000000000000000000000000000";
      f0_rwr0 = "01";
      f1_rwr0 = "000";
      f2_rwr0 = <zero27b,rt>;
      f3_rwr0 = bigE_word;
      f4_rwr0 = cycle;
      f5_rwr0 = tmp_pc;
      f6_rwr0 = "101";
      code_rwr0 = <f0_rwr0,f1_rwr0,f2_rwr0,f3_rwr0,f4_rwr0,f5_rwr0,f6_rwr0>;
      null = DATAOUT_FORMA_WB0.write(code_rwr0);
    };
  };
  instruction LWm : I
  {
    opecode  opcode = "0101000000101000";

    wire [31:0] bigE_word;
    wire [31:0] addr;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rrd0;
      wire [2:0] f1_rrd0;
      wire [31:0] f2_rrd0;
      wire [31:0] f3_rrd0;
      wire [31:0] f4_rrd0;
      wire [31:0] f5_rrd0;
      wire [2:0] f6_rrd0;
      wire [135:0] code_rrd0;
      wire [1:0] f0_fwd0;
      wire [2:0] f1_fwd0;
      wire [31:0] f2_fwd0;
      wire [31:0] f3_fwd0;
      wire [31:0] f4_fwd0;
      wire [31:0] f5_fwd0;
      wire [2:0] f6_fwd0;
      wire [135:0] code_fwd0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
      
      cycle = CYCLEWIRE_FORMA_ID.read();
      zero27b = "000000000000000000000000000";
      f0_rrd0 = "00";
      f1_rrd0 = "000";
      f2_rrd0 = <zero27b,rs>;
      f3_rrd0 = tmp_source0;
      f4_rrd0 = cycle;
      f5_rrd0 = tmp_pc;
      f6_rrd0 = "001";
      code_rrd0 = <f0_rrd0,f1_rrd0,f2_rrd0,f3_rrd0,f4_rrd0,f5_rrd0,f6_rrd0>;
      null = DATAOUT_FORMA_ID0.write(code_rrd0);
      
      f0_fwd0 = "00";
      f1_fwd0 = "011";
      f2_fwd0 = <zero27b,rs>;
      f3_fwd0 = source0;
      f4_fwd0 = cycle;
      f5_fwd0 = tmp_pc;
      f6_fwd0 = "001";
      code_fwd0 = <f0_fwd0,f1_fwd0,f2_fwd0,f3_fwd0,f4_fwd0,f5_fwd0,f6_fwd0>;
      null = DATAOUT_FORMA_ID1.write(code_fwd0);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [31:0] cycle;
      wire ctrlwire_ex0;
      wire cond_ex0;
      wire [1:0] f0_ex0;
      wire [2:0] f1_ex0;
      wire [31:0] f2_ex0;
      wire [31:0] f3_ex0;
      wire [31:0] f4_ex0;
      wire [31:0] f5_ex0;
      wire [2:0] f6_ex0;
      wire [135:0] code_ex0;
      wire ctrlwire_ex1;
      wire cond_ex1;
      wire ctrlwire_ex2;
      wire cond_ex2;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      cycle = CYCLEWIRE_FORMA_EX.read();
      ctrlwire_ex0 = CTRLWIRE_FORMA_EX0.read();
      cond_ex0 = ctrlwire_ex0 == '1';
      f0_ex0 = "10";
      f1_ex0 = "100";
      f2_ex0 = "00000000000000000000000000000000";
      f3_ex0 = "00000000000000000000000000000000";
      f4_ex0 = cycle;
      f5_ex0 = tmp_pc;
      f6_ex0 = "010";
      code_ex0 = <f0_ex0,f1_ex0,f2_ex0,f3_ex0,f4_ex0,f5_ex0,f6_ex0>;
      null = [cond_ex0]DATAOUT_FORMA_EX0.write(code_ex0);
      
      ctrlwire_ex1 = CTRLWIRE_FORMA_EX1.read();
      cond_ex1 = ctrlwire_ex1 == '1';
      null = [cond_ex1]DATAOUT_FORMA_EX1.write(code_ex0);
      
      ctrlwire_ex2 = CTRLWIRE_FORMA_EX2.read();
      cond_ex2 = ctrlwire_ex2 == '1';
      null = [cond_ex2]DATAOUT_FORMA_EX2.write(code_ex0);
    };

    stage 4 :
    {
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [31:0] result;
      wire  addr_err;
      wire [31:0] cycle;
      wire ctrlwire_m10;
      wire cond_m10;
      wire [1:0] f0_m10;
      wire [2:0] f1_m10;
      wire [31:0] f2_m10;
      wire [31:0] f3_m10;
      wire [31:0] f4_m10;
      wire [31:0] f5_m10;
      wire [2:0] f6_m10;
      wire [135:0] code_m10;
      wire ctrlwire_m11;
      wire cond_m11;
      wire ctrlwire_m12;
      wire cond_m12;
      wire [1:0] f0_mrd;
      wire [2:0] f1_mrd;
      wire [31:0] f2_mrd;
      wire [31:0] f3_mrd;
      wire [31:0] f4_mrd;
      wire [31:0] f5_mrd;
      wire [2:0] f6_mrd;
      wire [135:0] code_mrd;
      
      <result,addr_err> = Dmem.ld_32(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      cycle = CYCLEWIRE_FORMA_M1.read();
      ctrlwire_m10 = CTRLWIRE_FORMA_M10.read();
      cond_m10 = ctrlwire_m10 == '1';
      f0_m10 = "10";
      f1_m10 = "001";
      f2_m10 = "00000000000000000000000000000000";
      f3_m10 = "00000000000000000000000000000000";
      f4_m10 = cycle;
      f5_m10 = tmp_pc;
      f6_m10 = "011";
      code_m10 = <f0_m10,f1_m10,f2_m10,f3_m10,f4_m10,f5_m10,f6_m10>;
      null = [cond_m10]DATAOUT_FORMA_M10.write(code_m10);
      
      ctrlwire_m11 = CTRLWIRE_FORMA_M11.read();
      cond_m11 = ctrlwire_m11 == '1';
      null = [cond_m11]DATAOUT_FORMA_M11.write(code_m10);
      
      ctrlwire_m12 = CTRLWIRE_FORMA_M12.read();
      cond_m12 = ctrlwire_m12 == '1';
      null = [cond_m12]DATAOUT_FORMA_M12.write(code_m10);
      
      f0_mrd = "00";
      f1_mrd = "001";
      f2_mrd = addr;
      f3_mrd = bigE_word;
      f4_mrd = cycle;
      f5_mrd = tmp_pc;
      f6_mrd = "011";
      code_mrd = <f0_mrd,f1_mrd,f2_mrd,f3_mrd,f4_mrd,f5_mrd,f6_mrd>;
      null = DATAOUT_FORMA_M13.write(code_mrd);
    };

    stage 5 :
    {
      wire [31:0] cycle;
      wire ctrlwire_m20;
      wire cond_m20;
      wire [1:0] f0_m20;
      wire [2:0] f1_m20;
      wire [31:0] f2_m20;
      wire [31:0] f3_m20;
      wire [31:0] f4_m20;
      wire [31:0] f5_m20;
      wire [2:0] f6_m20;
      wire [135:0] code_m20;
      wire ctrlwire_m21;
      wire cond_m21;
      wire ctrlwire_m22;
      wire cond_m22;
      wire ctrlwire_m23;
      wire cond_m23;
      
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
      
      cycle = CYCLEWIRE_FORMA_M2.read();
      ctrlwire_m20 = CTRLWIRE_FORMA_M20.read();
      cond_m20 = ctrlwire_m20 == '1';
      f0_m20 = "10";
      f1_m20 = "001";
      f2_m20 = "00000000000000000000000000000000";
      f3_m20 = "00000000000000000000000000000000";
      f4_m20 = cycle;
      f5_m20 = tmp_pc;
      f6_m20 = "100";
      code_m20 = <f0_m20,f1_m20,f2_m20,f3_m20,f4_m20,f5_m20,f6_m20>;
      null = [cond_m20]DATAOUT_FORMA_M20.write(code_m20);
      
      ctrlwire_m21 = CTRLWIRE_FORMA_M21.read();
      cond_m21 = ctrlwire_m21 == '1';
      null = [cond_m21]DATAOUT_FORMA_M21.write(code_m20);
      
      ctrlwire_m22 = CTRLWIRE_FORMA_M22.read();
      cond_m22 = ctrlwire_m22 == '1';
      null = [cond_m22]DATAOUT_FORMA_M22.write(code_m20);
      
      ctrlwire_m23 = CTRLWIRE_FORMA_M23.read();
      cond_m23 = ctrlwire_m23 == '1';
      null = [cond_m23]DATAOUT_FORMA_M23.write(code_m20);
    };

    stage 6 :
    {
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rwr0;
      wire [2:0] f1_rwr0;
      wire [31:0] f2_rwr0;
      wire [31:0] f3_rwr0;
      wire [31:0] f4_rwr0;
      wire [31:0] f5_rwr0;
      wire [2:0] f6_rwr0;
      wire [135:0] code_rwr0;
      
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
      cycle = CYCLEWIRE_FORMA_WB.read();
      zero27b = "000000000000000000000000000";
      f0_rwr0 = "01";
      f1_rwr0 = "000";
      f2_rwr0 = <zero27b,rt>;
      f3_rwr0 = bigE_word;
      f4_rwr0 = cycle;
      f5_rwr0 = tmp_pc;
      f6_rwr0 = "101";
      code_rwr0 = <f0_rwr0,f1_rwr0,f2_rwr0,f3_rwr0,f4_rwr0,f5_rwr0,f6_rwr0>;
      null = DATAOUT_FORMA_WB0.write(code_rwr0);
    };
  };
  instruction DLWm : I
  {
    opecode  opcode = "0101000000101001";

    wire [31:0] bigE_word0;
    wire [31:0] bigE_word1;
    wire [4:0] nextRT;
    wire [31:0] addr2;
    wire [31:0] tmp_pc;
    wire [31:0] addr1;
    wire[31:0] source0;
    wire[31:0] source1; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rrd0;
      wire [2:0] f1_rrd0;
      wire [31:0] f2_rrd0;
      wire [31:0] f3_rrd0;
      wire [31:0] f4_rrd0;
      wire [31:0] f5_rrd0;
      wire [2:0] f6_rrd0;
      wire [135:0] code_rrd0;
      wire [1:0] f0_fwd0;
      wire [2:0] f1_fwd0;
      wire [31:0] f2_fwd0;
      wire [31:0] f3_fwd0;
      wire [31:0] f4_fwd0;
      wire [31:0] f5_fwd0;
      wire [2:0] f6_fwd0;
      wire [135:0] code_fwd0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
      
      cycle = CYCLEWIRE_FORMA_ID.read();
      zero27b = "000000000000000000000000000";
      f0_rrd0 = "00";
      f1_rrd0 = "000";
      f2_rrd0 = <zero27b,rs>;
      f3_rrd0 = tmp_source0;
      f4_rrd0 = cycle;
      f5_rrd0 = tmp_pc;
      f6_rrd0 = "001";
      code_rrd0 = <f0_rrd0,f1_rrd0,f2_rrd0,f3_rrd0,f4_rrd0,f5_rrd0,f6_rrd0>;
      null = DATAOUT_FORMA_ID0.write(code_rrd0);
      
      f0_fwd0 = "00";
      f1_fwd0 = "011";
      f2_fwd0 = <zero27b,rs>;
      f3_fwd0 = source0;
      f4_fwd0 = cycle;
      f5_fwd0 = tmp_pc;
      f6_fwd0 = "001";
      code_fwd0 = <f0_fwd0,f1_fwd0,f2_fwd0,f3_fwd0,f4_fwd0,f5_fwd0,f6_fwd0>;
      null = DATAOUT_FORMA_ID1.write(code_fwd0);
    };

    stage 3 :
    {
      wire [3:0] tmpRT;
      wire [3:0] flag;
      wire  one;
      wire [31:0] cycle;
      wire ctrlwire_ex0;
      wire cond_ex0;
      wire [1:0] f0_ex0;
      wire [2:0] f1_ex0;
      wire [31:0] f2_ex0;
      wire [31:0] f3_ex0;
      wire [31:0] f4_ex0;
      wire [31:0] f5_ex0;
      wire [2:0] f6_ex0;
      wire [135:0] code_ex0;
      wire ctrlwire_ex1;
      wire cond_ex1;
      wire ctrlwire_ex2;
      wire cond_ex2;
      
      <addr1,flag> = ALU1.add(source0,source1);
      one = '1';
      tmpRT = rt[4:1];
      nextRT = <tmpRT,one>;
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      null = FWUL0.lock2(nextRT);
      null = FWUL1.lock2(nextRT);
      null = FWUL2.lock2(nextRT);
      null = FWUL3.lock2(nextRT);
      
      cycle = CYCLEWIRE_FORMA_EX.read();
      ctrlwire_ex0 = CTRLWIRE_FORMA_EX0.read();
      cond_ex0 = ctrlwire_ex0 == '1';
      f0_ex0 = "10";
      f1_ex0 = "100";
      f2_ex0 = "00000000000000000000000000000000";
      f3_ex0 = "00000000000000000000000000000000";
      f4_ex0 = cycle;
      f5_ex0 = tmp_pc;
      f6_ex0 = "010";
      code_ex0 = <f0_ex0,f1_ex0,f2_ex0,f3_ex0,f4_ex0,f5_ex0,f6_ex0>;
      null = [cond_ex0]DATAOUT_FORMA_EX0.write(code_ex0);
      
      ctrlwire_ex1 = CTRLWIRE_FORMA_EX1.read();
      cond_ex1 = ctrlwire_ex1 == '1';
      null = [cond_ex1]DATAOUT_FORMA_EX1.write(code_ex0);
      
      ctrlwire_ex2 = CTRLWIRE_FORMA_EX2.read();
      cond_ex2 = ctrlwire_ex2 == '1';
      null = [cond_ex2]DATAOUT_FORMA_EX2.write(code_ex0);
    };

    stage 4 :
    {
      wire [31:0] four32bit;
      wire  cout;
      wire [7:0] byte2;
      wire [7:0] byte3;
      wire  cin;
      wire [7:0] byte1;
      wire [31:0] result1;
      wire  addr_err;
      wire [7:0] byte0;
      wire [31:0] cycle;
      wire ctrlwire_m10;
      wire cond_m10;
      wire [1:0] f0_m10;
      wire [2:0] f1_m10;
      wire [31:0] f2_m10;
      wire [31:0] f3_m10;
      wire [31:0] f4_m10;
      wire [31:0] f5_m10;
      wire [2:0] f6_m10;
      wire [135:0] code_m10;
      wire ctrlwire_m11;
      wire cond_m11;
      wire ctrlwire_m12;
      wire cond_m12;
      wire [1:0] f0_mrd;
      wire [2:0] f1_mrd;
      wire [31:0] f2_mrd;
      wire [31:0] f3_mrd;
      wire [31:0] f4_mrd;
      wire [31:0] f5_mrd;
      wire [2:0] f6_mrd;
      wire [135:0] code_mrd;
      
      cin = '0';
      four32bit = "00000000000000000000000000000100";
      <result1,addr_err> = Dmem.ld_32(addr1);
      byte0 = result1[31:24];
      byte1 = result1[23:16];
      byte2 = result1[15:8];
      byte3 = result1[7:0];
      bigE_word0 = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word0);
      null = FWUL1.forward3(rt,bigE_word0);
      null = FWUL2.forward3(rt,bigE_word0);
      null = FWUL3.forward3(rt,bigE_word0);
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      null = FWUL0.lock4(nextRT);
      null = FWUL1.lock4(nextRT);
      null = FWUL2.lock4(nextRT);
      null = FWUL3.lock4(nextRT);
      
      cycle = CYCLEWIRE_FORMA_M1.read();
      ctrlwire_m10 = CTRLWIRE_FORMA_M10.read();
      cond_m10 = ctrlwire_m10 == '1';
      f0_m10 = "10";
      f1_m10 = "001";
      f2_m10 = "00000000000000000000000000000000";
      f3_m10 = "00000000000000000000000000000000";
      f4_m10 = cycle;
      f5_m10 = tmp_pc;
      f6_m10 = "011";
      code_m10 = <f0_m10,f1_m10,f2_m10,f3_m10,f4_m10,f5_m10,f6_m10>;
      null = [cond_m10]DATAOUT_FORMA_M10.write(code_m10);
      
      ctrlwire_m11 = CTRLWIRE_FORMA_M11.read();
      cond_m11 = ctrlwire_m11 == '1';
      null = [cond_m11]DATAOUT_FORMA_M11.write(code_m10);
      
      ctrlwire_m12 = CTRLWIRE_FORMA_M12.read();
      cond_m12 = ctrlwire_m12 == '1';
      null = [cond_m12]DATAOUT_FORMA_M12.write(code_m10);
      
      f0_mrd = "00";
      f1_mrd = "001";
      f2_mrd = addr1;
      f3_mrd = bigE_word0;
      f4_mrd = cycle;
      f5_mrd = tmp_pc;
      f6_mrd = "011";
      code_mrd = <f0_mrd,f1_mrd,f2_mrd,f3_mrd,f4_mrd,f5_mrd,f6_mrd>;
      null = DATAOUT_FORMA_M13.write(code_mrd);
    };

    stage 5 :
    {
      wire [31:0] result2;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      wire [31:0] cycle;
      wire ctrlwire_m20;
      wire cond_m20;
      wire [1:0] f0_m20;
      wire [2:0] f1_m20;
      wire [31:0] f2_m20;
      wire [31:0] f3_m20;
      wire [31:0] f4_m20;
      wire [31:0] f5_m20;
      wire [2:0] f6_m20;
      wire [135:0] code_m20;
      wire ctrlwire_m21;
      wire cond_m21;
      wire ctrlwire_m22;
      wire cond_m22;
      wire ctrlwire_m23;
      wire cond_m23;
      wire [1:0] f0_mrd;
      wire [2:0] f1_mrd;
      wire [31:0] f2_mrd;
      wire [31:0] f3_mrd;
      wire [31:0] f4_mrd;
      wire [31:0] f5_mrd;
      wire [2:0] f6_mrd;
      wire [135:0] code_mrd;
      
      <result2,addr_err> = Dmem.ld_32(addr2);
      byte0 = result2[31:24];
      byte1 = result2[23:16];
      byte2 = result2[15:8];
      byte3 = result2[7:0];
      bigE_word1 = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward5(rt,bigE_word0);
      null = FWUL1.forward5(rt,bigE_word0);
      null = FWUL2.forward5(rt,bigE_word0);
      null = FWUL3.forward5(rt,bigE_word0);
      null = FWUL0.forward6(nextRT,bigE_word1);
      null = FWUL1.forward6(nextRT,bigE_word1);
      null = FWUL2.forward6(nextRT,bigE_word1);
      null = FWUL3.forward6(nextRT,bigE_word1);
      null = FWUL0.lock5(nextRT);
      null = FWUL1.lock5(nextRT);
      null = FWUL2.lock5(nextRT);
      null = FWUL3.lock5(nextRT);
      
      cycle = CYCLEWIRE_FORMA_M2.read();
      ctrlwire_m20 = CTRLWIRE_FORMA_M20.read();
      cond_m20 = ctrlwire_m20 == '1';
      f0_m20 = "10";
      f1_m20 = "001";
      f2_m20 = "00000000000000000000000000000000";
      f3_m20 = "00000000000000000000000000000000";
      f4_m20 = cycle;
      f5_m20 = tmp_pc;
      f6_m20 = "100";
      code_m20 = <f0_m20,f1_m20,f2_m20,f3_m20,f4_m20,f5_m20,f6_m20>;
      null = [cond_m20]DATAOUT_FORMA_M20.write(code_m20);
      
      ctrlwire_m21 = CTRLWIRE_FORMA_M21.read();
      cond_m21 = ctrlwire_m21 == '1';
      null = [cond_m21]DATAOUT_FORMA_M21.write(code_m20);
      
      ctrlwire_m22 = CTRLWIRE_FORMA_M22.read();
      cond_m22 = ctrlwire_m22 == '1';
      null = [cond_m22]DATAOUT_FORMA_M22.write(code_m20);
      
      ctrlwire_m23 = CTRLWIRE_FORMA_M23.read();
      cond_m23 = ctrlwire_m23 == '1';
      null = [cond_m23]DATAOUT_FORMA_M23.write(code_m20);
      
      f0_mrd = "00";
      f1_mrd = "001";
      f2_mrd = addr2;
      f3_mrd = bigE_word0;
      f4_mrd = cycle;
      f5_mrd = tmp_pc;
      f6_mrd = "100";
      code_mrd = <f0_mrd,f1_mrd,f2_mrd,f3_mrd,f4_mrd,f5_mrd,f6_mrd>;
      null = DATAOUT_FORMA_M24.write(code_mrd);
    };

    stage 6 :
    {
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rwr0;
      wire [2:0] f1_rwr0;
      wire [31:0] f2_rwr0;
      wire [31:0] f3_rwr0;
      wire [31:0] f4_rwr0;
      wire [31:0] f5_rwr0;
      wire [2:0] f6_rwr0;
      wire [135:0] code_rwr0;
      wire [1:0] f0_rwr1;
      wire [2:0] f1_rwr1;
      wire [31:0] f2_rwr1;
      wire [31:0] f3_rwr1;
      wire [31:0] f4_rwr1;
      wire [31:0] f5_rwr1;
      wire [2:0] f6_rwr1;
      wire [135:0] code_rwr1;
      
      null = FWUL0.forward7(rt,bigE_word0);
      null = FWUL1.forward7(rt,bigE_word0);
      null = FWUL2.forward7(rt,bigE_word0);
      null = FWUL3.forward7(rt,bigE_word0);
      null = FWUL0.forward8(nextRT,bigE_word1);
      null = FWUL1.forward8(nextRT,bigE_word1);
      null = FWUL2.forward8(nextRT,bigE_word1);
      null = FWUL3.forward8(nextRT,bigE_word1);
      null = GPR.write0(rt,bigE_word0);
      null = GPR.write1(nextRT,bigE_word1);
      
      cycle = CYCLEWIRE_FORMA_WB.read();
      zero27b = "000000000000000000000000000";
      f0_rwr0 = "01";
      f1_rwr0 = "000";
      f2_rwr0 = <zero27b,rt>;
      f3_rwr0 = bigE_word0;
      f4_rwr0 = cycle;
      f5_rwr0 = tmp_pc;
      f6_rwr0 = "101";
      code_rwr0 = <f0_rwr0,f1_rwr0,f2_rwr0,f3_rwr0,f4_rwr0,f5_rwr0,f6_rwr0>;
      null = DATAOUT_FORMA_WB0.write(code_rwr0);
      
      f0_rwr1 = "01";
      f1_rwr1 = "000";
      f2_rwr1 = <zero27b,nextRT>;
      f3_rwr1 = bigE_word1;
      f4_rwr1 = cycle;
      f5_rwr1 = tmp_pc;
      f6_rwr1 = "101";
      code_rwr1 = <f0_rwr1,f1_rwr1,f2_rwr1,f3_rwr1,f4_rwr1,f5_rwr1,f6_rwr1>;
      null = DATAOUT_FORMA_WB1.write(code_rwr1);
    };
  };
  instruction LWLm : I
  {
    opecode  opcode = "0101000000101100";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rrd0;
      wire [2:0] f1_rrd0;
      wire [31:0] f2_rrd0;
      wire [31:0] f3_rrd0;
      wire [31:0] f4_rrd0;
      wire [31:0] f5_rrd0;
      wire [2:0] f6_rrd0;
      wire [135:0] code_rrd0;
      wire [1:0] f0_fwd0;
      wire [2:0] f1_fwd0;
      wire [31:0] f2_fwd0;
      wire [31:0] f3_fwd0;
      wire [31:0] f4_fwd0;
      wire [31:0] f5_fwd0;
      wire [2:0] f6_fwd0;
      wire [135:0] code_fwd0;
      wire [1:0] f0_rrd1;
      wire [2:0] f1_rrd1;
      wire [31:0] f2_rrd1;
      wire [31:0] f3_rrd1;
      wire [31:0] f4_rrd1;
      wire [31:0] f5_rrd1;
      wire [2:0] f6_rrd1;
      wire [135:0] code_rrd1;
      wire [1:0] f0_fwd1;
      wire [2:0] f1_fwd1;
      wire [31:0] f2_fwd1;
      wire [31:0] f3_fwd1;
      wire [31:0] f4_fwd1;
      wire [31:0] f5_fwd1;
      wire [2:0] f6_fwd1;
      wire [135:0] code_fwd1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      
      cycle = CYCLEWIRE_FORMA_ID.read();
      zero27b = "000000000000000000000000000";
      f0_rrd0 = "00";
      f1_rrd0 = "000";
      f2_rrd0 = <zero27b,rs>;
      f3_rrd0 = tmp_source0;
      f4_rrd0 = cycle;
      f5_rrd0 = tmp_pc;
      f6_rrd0 = "001";
      code_rrd0 = <f0_rrd0,f1_rrd0,f2_rrd0,f3_rrd0,f4_rrd0,f5_rrd0,f6_rrd0>;
      null = DATAOUT_FORMA_ID0.write(code_rrd0);
      
      f0_fwd0 = "00";
      f1_fwd0 = "011";
      f2_fwd0 = <zero27b,rs>;
      f3_fwd0 = source0;
      f4_fwd0 = cycle;
      f5_fwd0 = tmp_pc;
      f6_fwd0 = "001";
      code_fwd0 = <f0_fwd0,f1_fwd0,f2_fwd0,f3_fwd0,f4_fwd0,f5_fwd0,f6_fwd0>;
      null = DATAOUT_FORMA_ID1.write(code_fwd0);
      
      f0_rrd1 = "00";
      f1_rrd1 = "000";
      f2_rrd1 = <zero27b,rt>;
      f3_rrd1 = tmp_source1;
      f4_rrd1 = cycle;
      f5_rrd1 = tmp_pc;
      f6_rrd1 = "001";
      code_rrd1 = <f0_rrd1,f1_rrd1,f2_rrd1,f3_rrd1,f4_rrd1,f5_rrd1,f6_rrd1>;
      null = DATAOUT_FORMA_ID2.write(code_rrd1);
      
      f0_fwd1 = "00";
      f1_fwd1 = "011";
      f2_fwd1 = <zero27b,rs>;
      f3_fwd1 = source1;
      f4_fwd1 = cycle;
      f5_fwd1 = tmp_pc;
      f6_fwd1 = "001";
      code_fwd1 = <f0_fwd1,f1_fwd1,f2_fwd1,f3_fwd1,f4_fwd1,f5_fwd1,f6_fwd1>;
      null = DATAOUT_FORMA_ID3.write(code_fwd1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire [31:0] cycle;
      wire ctrlwire_ex0;
      wire cond_ex0;
      wire [1:0] f0_ex0;
      wire [2:0] f1_ex0;
      wire [31:0] f2_ex0;
      wire [31:0] f3_ex0;
      wire [31:0] f4_ex0;
      wire [31:0] f5_ex0;
      wire [2:0] f6_ex0;
      wire [135:0] code_ex0;
      wire ctrlwire_ex1;
      wire cond_ex1;
      wire ctrlwire_ex2;
      wire cond_ex2;
      
      <addr,flag> = ALU1.add(source0,source2);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      cycle = CYCLEWIRE_FORMA_EX.read();
      ctrlwire_ex0 = CTRLWIRE_FORMA_EX0.read();
      cond_ex0 = ctrlwire_ex0 == '1';
      f0_ex0 = "10";
      f1_ex0 = "100";
      f2_ex0 = "00000000000000000000000000000000";
      f3_ex0 = "00000000000000000000000000000000";
      f4_ex0 = cycle;
      f5_ex0 = tmp_pc;
      f6_ex0 = "010";
      code_ex0 = <f0_ex0,f1_ex0,f2_ex0,f3_ex0,f4_ex0,f5_ex0,f6_ex0>;
      null = [cond_ex0]DATAOUT_FORMA_EX0.write(code_ex0);
      
      ctrlwire_ex1 = CTRLWIRE_FORMA_EX1.read();
      cond_ex1 = ctrlwire_ex1 == '1';
      null = [cond_ex1]DATAOUT_FORMA_EX1.write(code_ex0);
      
      ctrlwire_ex2 = CTRLWIRE_FORMA_EX2.read();
      cond_ex2 = ctrlwire_ex2 == '1';
      null = [cond_ex2]DATAOUT_FORMA_EX2.write(code_ex0);
    };

    stage 4 :
    {
      wire [31:0] result0;
      wire [31:0] target;
      wire [7:0] byte2;
      wire [7:0] data1;
      wire [31:0] result1;
      wire [31:0] bigE_data;
      wire [7:0] reg2;
      wire [31:0] result3;
      wire [7:0] reg0;
      wire [7:0] reg1;
      wire [31:0] result2;
      wire [7:0] byte3;
      wire [7:0] byte0;
      wire [1:0] zero2;
      wire [1:0] vAddr10;
      wire  addr_err;
      wire [7:0] data2;
      wire [31:0] data;
      wire [7:0] data0;
      wire [7:0] byte1;
      wire [29:0] addr_mask;
      wire [31:0] cycle;
      wire ctrlwire_m10;
      wire cond_m10;
      wire [1:0] f0_m10;
      wire [2:0] f1_m10;
      wire [31:0] f2_m10;
      wire [31:0] f3_m10;
      wire [31:0] f4_m10;
      wire [31:0] f5_m10;
      wire [2:0] f6_m10;
      wire [135:0] code_m10;
      wire ctrlwire_m11;
      wire cond_m11;
      wire ctrlwire_m12;
      wire cond_m12;
      wire [1:0] f0_mrd;
      wire [2:0] f1_mrd;
      wire [31:0] f2_mrd;
      wire [31:0] f3_mrd;
      wire [31:0] f4_mrd;
      wire [31:0] f5_mrd;
      wire [2:0] f6_mrd;
      wire [135:0] code_mrd;
      
      addr_mask = addr[31:2];
      vAddr10 = addr[1:0];
      zero2 = "00";
      target = <addr_mask,zero2>;
      <data,addr_err> = Dmem.ld_32(target);
      byte0 = data[31:24];
      byte1 = data[23:16];
      byte2 = data[15:8];
      byte3 = data[7:0];
      bigE_data = <byte3,byte2,byte1,byte0>;
      data2 = bigE_data[23:16];
      data1 = bigE_data[15:8];
      data0 = bigE_data[7:0];
      reg2 = source1[23:16];
      reg1 = source1[15:8];
      reg0 = source1[7:0];
      result0 = <data0,reg2,reg1,reg0>;
      result1 = <data1,data0,reg1,reg0>;
      result2 = <data2,data1,data0,reg0>;
      result3 = bigE_data;
      result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      
      cycle = CYCLEWIRE_FORMA_M1.read();
      ctrlwire_m10 = CTRLWIRE_FORMA_M10.read();
      cond_m10 = ctrlwire_m10 == '1';
      f0_m10 = "10";
      f1_m10 = "001";
      f2_m10 = "00000000000000000000000000000000";
      f3_m10 = "00000000000000000000000000000000";
      f4_m10 = cycle;
      f5_m10 = tmp_pc;
      f6_m10 = "011";
      code_m10 = <f0_m10,f1_m10,f2_m10,f3_m10,f4_m10,f5_m10,f6_m10>;
      null = [cond_m10]DATAOUT_FORMA_M10.write(code_m10);
      
      ctrlwire_m11 = CTRLWIRE_FORMA_M11.read();
      cond_m11 = ctrlwire_m11 == '1';
      null = [cond_m11]DATAOUT_FORMA_M11.write(code_m10);
      
      ctrlwire_m12 = CTRLWIRE_FORMA_M12.read();
      cond_m12 = ctrlwire_m12 == '1';
      null = [cond_m12]DATAOUT_FORMA_M12.write(code_m10);
      
      f0_mrd = "00";
      f1_mrd = "001";
      f2_mrd = target;
      f3_mrd = bigE_data;
      f4_mrd = cycle;
      f5_mrd = tmp_pc;
      f6_mrd = "011";
      code_mrd = <f0_mrd,f1_mrd,f2_mrd,f3_mrd,f4_mrd,f5_mrd,f6_mrd>;
      null = DATAOUT_FORMA_M13.write(code_mrd);
    };

    stage 5 :
    {
      wire [31:0] cycle;
      wire ctrlwire_m20;
      wire cond_m20;
      wire [1:0] f0_m20;
      wire [2:0] f1_m20;
      wire [31:0] f2_m20;
      wire [31:0] f3_m20;
      wire [31:0] f4_m20;
      wire [31:0] f5_m20;
      wire [2:0] f6_m20;
      wire [135:0] code_m20;
      wire ctrlwire_m21;
      wire cond_m21;
      wire ctrlwire_m22;
      wire cond_m22;
      wire ctrlwire_m23;
      wire cond_m23;
      
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
      
      cycle = CYCLEWIRE_FORMA_M2.read();
      ctrlwire_m20 = CTRLWIRE_FORMA_M20.read();
      cond_m20 = ctrlwire_m20 == '1';
      f0_m20 = "10";
      f1_m20 = "001";
      f2_m20 = "00000000000000000000000000000000";
      f3_m20 = "00000000000000000000000000000000";
      f4_m20 = cycle;
      f5_m20 = tmp_pc;
      f6_m20 = "100";
      code_m20 = <f0_m20,f1_m20,f2_m20,f3_m20,f4_m20,f5_m20,f6_m20>;
      null = [cond_m20]DATAOUT_FORMA_M20.write(code_m20);
      
      ctrlwire_m21 = CTRLWIRE_FORMA_M21.read();
      cond_m21 = ctrlwire_m21 == '1';
      null = [cond_m21]DATAOUT_FORMA_M21.write(code_m20);
      
      ctrlwire_m22 = CTRLWIRE_FORMA_M22.read();
      cond_m22 = ctrlwire_m22 == '1';
      null = [cond_m22]DATAOUT_FORMA_M22.write(code_m20);
      
      ctrlwire_m23 = CTRLWIRE_FORMA_M23.read();
      cond_m23 = ctrlwire_m23 == '1';
      null = [cond_m23]DATAOUT_FORMA_M23.write(code_m20);
    };

    stage 6 :
    {
      wire [31:0] cycle;
      wire [26:0] zero27b;
      wire [1:0] f0_rwr0;
      wire [2:0] f1_rwr0;
      wire [31:0] f2_rwr0;
      wire [31:0] f3_rwr0;
      wire [31:0] f4_rwr0;
      wire [31:0] f5_rwr0;
      wire [2:0] f6_rwr0;
      wire [135:0] code_rwr0;
      
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
      
      cycle = CYCLEWIRE_FORMA_WB.read();
      zero27b = "000000000000000000000000000";
      f0_rwr0 = "01";
      f1_rwr0 = "000";
      f2_rwr0 = <zero27b,rt>;
      f3_rwr0 = result;
      f4_rwr0 = cycle;
      f5_rwr0 = tmp_pc;
      f6_rwr0 = "101";
      code_rwr0 = <f0_rwr0,f1_rwr0,f2_rwr0,f3_rwr0,f4_rwr0,f5_rwr0,f6_rwr0>;
      null = DATAOUT_FORMA_WB0.write(code_rwr0);
    };
  };
  instruction LWRm : I
  {
    opecode  opcode = "0101000000101101";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire [31:0] result0;
      wire [31:0] target;
      wire [7:0] byte2;
      wire [7:0] data1;
      wire [31:0] result1;
      wire [31:0] bigE_data;
      wire [7:0] reg2;
      wire [7:0] reg3;
      wire [31:0] result3;
      wire [7:0] reg1;
      wire [31:0] result2;
      wire [7:0] byte3;
      wire [7:0] byte0;
      wire [1:0] zero2;
      wire [1:0] vAddr10;
      wire  addr_err;
      wire [7:0] data2;
      wire [31:0] data;
      wire [7:0] byte1;
      wire [7:0] data3;
      wire [29:0] addr_mask;
      
      addr_mask = addr[31:2];
      vAddr10 = addr[1:0];
      zero2 = "00";
      target = <addr_mask,zero2>;
      <data,addr_err> = Dmem.ld_32(target);
      byte0 = data[31:24];
      byte1 = data[23:16];
      byte2 = data[15:8];
      byte3 = data[7:0];
      bigE_data = <byte3,byte2,byte1,byte0>;
      data3 = bigE_data[31:24];
      data2 = bigE_data[23:16];
      data1 = bigE_data[15:8];
      reg3 = source1[31:24];
      reg2 = source1[23:16];
      reg1 = source1[15:8];
      result3 = <reg3,reg2,reg1,data3>;
      result2 = <reg3,reg2,data3,data2>;
      result1 = <reg3,data3,data2,data1>;
      result0 = bigE_data;
      result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction SBm : I
  {
    opecode  opcode = "0101000000110000";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire [31:0] LE_source1;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_8(addr,LE_source1);
    };

    stage 6 :
    {
      
    };
  };
  instruction SHm : I
  {
    opecode  opcode = "0101000000110010";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire [31:0] LE_source1;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_16(addr,LE_source1);
    };

    stage 6 :
    {
      
    };
  };
  instruction SWm : I
  {
    opecode  opcode = "0101000000110100";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire [31:0] LE_source1;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_32(addr,LE_source1);
    };

    stage 6 :
    {
      
    };
  };
  instruction DSWm : I
  {
    opecode  opcode = "0101000000110101";

    wire [31:0] source2;
    wire [31:0] source3;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] addr2;
    wire [31:0] tmp_pc;
    wire [31:0] addr1; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [3:0] oldrt;
      wire [31:0] tmp_source1;
      wire [31:0] tmp_source3;
      wire  one;
      wire [4:0] rt2;
      wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; one = '1';
      oldrt = rt[4:1];
      rt2 = <oldrt,one>;
      tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source3 = GPR.read2(rt2);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = EXT1.sign(imm);
      source3 = FWUL2.forward(rt2,tmp_source3);
    };

    stage 3 :
    {
      wire [31:0] four32bit;
      wire [3:0] flag;
      wire  cin;
      wire  cout;
      
      <addr1,flag> = ALU1.add(source0,source2);
      cin = '1';
      four32bit = "00000000000000000000000000000100";
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire [31:0] LE_source1;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_32(addr1,LE_source1);
    };

    stage 6 :
    {
      wire [31:0] LE_source3;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source3[31:24];
      byte1 = source3[23:16];
      byte2 = source3[15:8];
      byte3 = source3[7:0];
      LE_source3 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_32(addr2,LE_source3);
    };
  };
  instruction DSZm : I
  {
    opecode  opcode = "0101000000111000";

    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] addr2;
    wire [31:0] tmp_pc;
    wire [31:0] addr1; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [4:0] zero5;
      wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; zero5 = "00000";
      tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(zero5);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(zero5,tmp_source1);
      source2 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr1,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      wire [31:0] four32bit;
      wire  cin;
      wire  cout;
      
      cin = '1';
      four32bit = "00000000000000000000000000000100";
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
    };

    stage 5 :
    {
      wire  addr_err;
      
      addr_err = Dmem.s_32(addr1,source1);
    };

    stage 6 :
    {
      wire  addr_err;
      
      addr_err = Dmem.s_32(addr2,source1);
    };
  };
  instruction SWLm : I
  {
    opecode  opcode = "0101000000111001";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      wire [31:0] result0;
      wire [31:0] target;
      wire [31:0] nData;
      wire [7:0] byte2;
      wire [7:0] data1;
      wire [31:0] result1;
      wire [7:0] byte1;
      wire [7:0] reg2;
      wire [7:0] reg3;
      wire [31:0] result3;
      wire [7:0] reg1;
      wire [31:0] result2;
      wire [7:0] byte3;
      wire [7:0] byte0;
      wire [1:0] zero2;
      wire [1:0] vAddr10;
      wire  addr_err;
      wire [7:0] data2;
      wire [31:0] data;
      wire [7:0] data3;
      wire [29:0] addr_mask;
      
      addr_mask = addr[31:2];
      vAddr10 = addr[1:0];
      zero2 = "00";
      target = <addr_mask,zero2>;
      <data,addr_err> = Dmem.ld_32(target);
      byte0 = data[31:24];
      byte1 = data[23:16];
      byte2 = data[15:8];
      byte3 = data[7:0];
      nData = <byte3,byte2,byte1,byte0>;
      data3 = nData[31:24];
      data2 = nData[23:16];
      data1 = nData[15:8];
      reg3 = source1[31:24];
      reg2 = source1[23:16];
      reg1 = source1[15:8];
      result3 = source1;
      result2 = <data3,reg3,reg2,reg1>;
      result1 = <data3,data2,reg3,reg2>;
      result0 = <data3,data2,data1,reg3>;
      result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
    };

    stage 5 :
    {
      wire [31:0] target;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [1:0] zero2;
      wire [31:0] nResult;
      wire  addr_err;
      wire [29:0] addr_mask;
      
      addr_mask = addr[31:2];
      zero2 = "00";
      target = <addr_mask,zero2>;
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      nResult = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_32(target,nResult);
    };

    stage 6 :
    {
      
    };
  };
  instruction SWRm : I
  {
    opecode  opcode = "0101000000111010";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source2 = EXT1.sign(imm);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      wire [31:0] result0;
      wire [31:0] target;
      wire [31:0] nData;
      wire [7:0] byte2;
      wire [7:0] data1;
      wire [31:0] result1;
      wire [7:0] byte1;
      wire [7:0] reg2;
      wire [31:0] result3;
      wire [7:0] reg0;
      wire [7:0] reg1;
      wire [31:0] result2;
      wire [7:0] byte3;
      wire [7:0] byte0;
      wire [1:0] zero2;
      wire [1:0] vAddr10;
      wire  addr_err;
      wire [7:0] data2;
      wire [31:0] data;
      wire [7:0] data0;
      wire [29:0] addr_mask;
      
      addr_mask = addr[31:2];
      vAddr10 = addr[1:0];
      zero2 = "00";
      target = <addr_mask,zero2>;
      <data,addr_err> = Dmem.ld_32(target);
      byte0 = data[31:24];
      byte1 = data[23:16];
      byte2 = data[15:8];
      byte3 = data[7:0];
      nData = <byte3,byte2,byte1,byte0>;
      data2 = nData[23:16];
      data1 = nData[15:8];
      data0 = nData[7:0];
      reg2 = source1[23:16];
      reg1 = source1[15:8];
      reg0 = source1[7:0];
      result0 = source1;
      result1 = <reg2,reg1,reg0,data0>;
      result2 = <reg1,reg0,data1,data0>;
      result3 = <reg0,data2,data1,data0>;
      result = MUXw32p4.sel(result0,result1,result2,result3,vAddr10);
    };

    stage 5 :
    {
      wire [31:0] target;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [1:0] zero2;
      wire [31:0] nResult;
      wire  addr_err;
      wire [29:0] addr_mask;
      
      addr_mask = addr[31:2];
      zero2 = "00";
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      nResult = <byte3,byte2,byte1,byte0>;
      target = <addr_mask,zero2>;
      addr_err = Dmem.s_32(target,nResult);
    };

    stage 6 :
    {
      
    };
  };
  instruction LB_RRm : R
  {
    opecode  opcode = "0101000011000000";

    wire [31:0] bigE_word;
    wire [31:0] addr;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [31:0] result;
      wire  addr_err;
      
      <result,addr_err> = Dmem.ld_8(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LBU_RRm : R
  {
    opecode  opcode = "0101000011000001";

    wire [31:0] bigE_word;
    wire [31:0] addr;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [31:0] result;
      wire  addr_err;
      
      <result,addr_err> = Dmem.ldu_8(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LH_RRm : R
  {
    opecode  opcode = "0101000011000010";

    wire [31:0] bigE_word;
    wire [31:0] addr;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [31:0] result;
      wire  addr_err;
      
      <result,addr_err> = Dmem.ld_16(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LHU_RRm : R
  {
    opecode  opcode = "0101000011000011";

    wire [31:0] bigE_word;
    wire [31:0] addr;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [31:0] result;
      wire  addr_err;
      
      <result,addr_err> = Dmem.ldu_16(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction LW_RRm : R
  {
    opecode  opcode = "0101000011000100";

    wire [31:0] bigE_word;
    wire [31:0] addr;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source1);
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
    };

    stage 4 :
    {
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire [31:0] result;
      wire  addr_err;
      
      <result,addr_err> = Dmem.ld_32(addr);
      byte0 = result[31:24];
      byte1 = result[23:16];
      byte2 = result[15:8];
      byte3 = result[7:0];
      bigE_word = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word);
      null = FWUL1.forward3(rt,bigE_word);
      null = FWUL2.forward3(rt,bigE_word);
      null = FWUL3.forward3(rt,bigE_word);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,bigE_word);
      null = FWUL1.forward5(rt,bigE_word);
      null = FWUL2.forward5(rt,bigE_word);
      null = FWUL3.forward5(rt,bigE_word);
    };

    stage 6 :
    {
      null = GPR.write0(rt,bigE_word);
      null = FWUL0.forward7(rt,bigE_word);
      null = FWUL1.forward7(rt,bigE_word);
      null = FWUL2.forward7(rt,bigE_word);
      null = FWUL3.forward7(rt,bigE_word);
    };
  };
  instruction DLW_RRm : R
  {
    opecode  opcode = "0101000011001110";

    wire [31:0] bigE_word0;
    wire [31:0] bigE_word1;
    wire [4:0] nextRT;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] addr2;
    wire [31:0] tmp_pc;
    wire [31:0] addr1; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rd,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] tmpRT;
      wire [3:0] flag;
      wire  one;
      
      <addr1,flag> = ALU1.add(source0,source1);
      one = '1';
      tmpRT = rt[4:1];
      nextRT = <tmpRT,one>;
      null = FWUL0.lock1(rt);
      null = FWUL1.lock1(rt);
      null = FWUL2.lock1(rt);
      null = FWUL3.lock1(rt);
      null = FWUL0.lock2(nextRT);
      null = FWUL1.lock2(nextRT);
      null = FWUL2.lock2(nextRT);
      null = FWUL3.lock2(nextRT);
    };

    stage 4 :
    {
      wire [31:0] four32bit;
      wire  cout;
      wire [7:0] byte2;
      wire [7:0] byte3;
      wire  cin;
      wire [7:0] byte1;
      wire [31:0] result1;
      wire  addr_err;
      wire [7:0] byte0;
      
      cin = '0';
      four32bit = "00000000000000000000000000000100";
      <result1,addr_err> = Dmem.ld_32(addr1);
      byte0 = result1[31:24];
      byte1 = result1[23:16];
      byte2 = result1[15:8];
      byte3 = result1[7:0];
      bigE_word0 = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward3(rt,bigE_word0);
      null = FWUL1.forward3(rt,bigE_word0);
      null = FWUL2.forward3(rt,bigE_word0);
      null = FWUL3.forward3(rt,bigE_word0);
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
      null = FWUL0.lock3(rt);
      null = FWUL1.lock3(rt);
      null = FWUL2.lock3(rt);
      null = FWUL3.lock3(rt);
      null = FWUL0.lock4(nextRT);
      null = FWUL1.lock4(nextRT);
      null = FWUL2.lock4(nextRT);
      null = FWUL3.lock4(nextRT);
    };

    stage 5 :
    {
      wire [31:0] result2;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      <result2,addr_err> = Dmem.ld_32(addr2);
      byte0 = result2[31:24];
      byte1 = result2[23:16];
      byte2 = result2[15:8];
      byte3 = result2[7:0];
      bigE_word1 = <byte3,byte2,byte1,byte0>;
      null = FWUL0.forward5(rt,bigE_word0);
      null = FWUL1.forward5(rt,bigE_word0);
      null = FWUL2.forward5(rt,bigE_word0);
      null = FWUL3.forward5(rt,bigE_word0);
      null = FWUL0.forward6(nextRT,bigE_word1);
      null = FWUL1.forward6(nextRT,bigE_word1);
      null = FWUL2.forward6(nextRT,bigE_word1);
      null = FWUL3.forward6(nextRT,bigE_word1);
      null = FWUL0.lock5(nextRT);
      null = FWUL1.lock5(nextRT);
      null = FWUL2.lock5(nextRT);
      null = FWUL3.lock5(nextRT);
    };

    stage 6 :
    {
      null = FWUL0.forward7(rt,bigE_word0);
      null = FWUL1.forward7(rt,bigE_word0);
      null = FWUL2.forward7(rt,bigE_word0);
      null = FWUL3.forward7(rt,bigE_word0);
      null = FWUL0.forward8(nextRT,bigE_word1);
      null = FWUL1.forward8(nextRT,bigE_word1);
      null = FWUL2.forward8(nextRT,bigE_word1);
      null = FWUL3.forward8(nextRT,bigE_word1);
      null = GPR.write0(rt,bigE_word0);
      null = GPR.write1(nextRT,bigE_word1);
    };
  };
  instruction SB_RRm : R
  {
    opecode  opcode = "0101000011000110";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source2;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source2 = GPR.read2(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire [31:0] LE_source1;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_8(addr,LE_source1);
    };

    stage 6 :
    {
      
    };
  };
  instruction SH_RRm : R
  {
    opecode  opcode = "0101000011000111";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source2;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source2 = GPR.read2(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire [31:0] LE_source1;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_16(addr,LE_source1);
    };

    stage 6 :
    {
      
    };
  };
  instruction SW_RRm : R
  {
    opecode  opcode = "0101000011001000";

    wire [31:0] addr;
    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source2;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source2 = GPR.read2(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire [31:0] LE_source1;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_32(addr,LE_source1);
    };

    stage 6 :
    {
      
    };
  };
  instruction DSW_RRm : R
  {
    opecode  opcode = "0101000011010000";

    wire [31:0] source2;
    wire [31:0] source3;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] addr2;
    wire [31:0] tmp_pc;
    wire [31:0] addr1; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      wire [31:0] tmp_source2;
      wire [31:0] tmp_source3;
      wire  one;
      wire [4:0] rt2;
      wire [3:0] oldrt;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; one = '1';
      oldrt = rt[4:1];
      rt2 = <oldrt,one>;
      tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      tmp_source2 = GPR.read2(rd);
      tmp_source3 = GPR.read3(rt2);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
      source3 = FWUL3.forward(rt2,tmp_source3);
    };

    stage 3 :
    {
      wire [31:0] four32bit;
      wire [3:0] flag;
      wire  cin;
      wire  cout;
      
      <addr1,flag> = ALU1.add(source0,source2);
      cin = '1';
      four32bit = "00000000000000000000000000000100";
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      wire [31:0] LE_source1;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source1[31:24];
      byte1 = source1[23:16];
      byte2 = source1[15:8];
      byte3 = source1[7:0];
      LE_source1 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_32(addr1,LE_source1);
    };

    stage 6 :
    {
      wire [31:0] LE_source3;
      wire [7:0] byte3;
      wire [7:0] byte2;
      wire [7:0] byte1;
      wire [7:0] byte0;
      wire  addr_err;
      
      byte0 = source3[31:24];
      byte1 = source3[23:16];
      byte2 = source3[15:8];
      byte3 = source3[7:0];
      LE_source3 = <byte3,byte2,byte1,byte0>;
      addr_err = Dmem.s_32(addr2,LE_source3);
    };
  };
  instruction DSZ_RRm : R
  {
    opecode  opcode = "0101000011010001";

    wire [31:0] source2;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] addr2;
    wire [31:0] tmp_pc;
    wire [31:0] addr1; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [4:0] zero5;
      wire [31:0] tmp_source0;
      wire [31:0] tmp_source2;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; zero5 = "00000";
      tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(zero5);
      tmp_source2 = GPR.read2(rd);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(zero5,tmp_source1);
      source2 = FWUL2.forward(rd,tmp_source2);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <addr1,flag> = ALU1.add(source0,source2);
    };

    stage 4 :
    {
      wire [31:0] four32bit;
      wire  cin;
      wire  cout;
      
      cin = '1';
      four32bit = "00000000000000000000000000000100";
      <addr2,cout> = ADDER2.adc(addr1,four32bit,cin);
    };

    stage 5 :
    {
      wire  addr_err;
      
      addr_err = Dmem.s_32(addr1,source1);
    };

    stage 6 :
    {
      wire  addr_err;
      
      addr_err = Dmem.s_32(addr2,source1);
    };
  };
  instruction JUMPm : J
  {
    opecode  opcode = "0101000000000001";

    wire [31:0] tmp_pc;
    wire [31:0] result; wire [25:0] targ;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire  one1b0;
      wire [1:0] const;
      wire  zero1b0;
      wire [3:0] cpc_top;
      wire [31:0] tmp_cpc;
      
      tmp_ir = IReg.read(); targ = tmp_ir[25:0]; one1b0 = '1';
      zero1b0 = '0';
      const = "00";
      tmp_cpc = CPC.read();
      cpc_top = tmp_cpc[31:28];
      result = <cpc_top,targ,const>;
    };

    stage 3 :
    {
      null = CPC.write(result);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction JALm : J
  {
    opecode  opcode = "0101000000000010";

    wire [4:0] linkReg;
    wire [31:0] tmp_pc;
    wire [31:0] link;
    wire [31:0] result; wire [25:0] targ;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [3:0] cpc_top;
      wire [1:0] const;
      wire [31:0] tmp_cpc;
      
      tmp_ir = IReg.read(); targ = tmp_ir[25:0]; const = "00";
      tmp_cpc = CPC.read();
      link = tmp_cpc;
      cpc_top = tmp_cpc[31:28];
      result = <cpc_top,targ,const>;
      linkReg = "11111";
    };

    stage 3 :
    {
      null = CPC.write(result);
      null = FWUL0.forward1(linkReg,link);
      null = FWUL1.forward1(linkReg,link);
      null = FWUL2.forward1(linkReg,link);
      null = FWUL3.forward1(linkReg,link);
    };

    stage 4 :
    {
      null = FWUL0.forward3(linkReg,link);
      null = FWUL1.forward3(linkReg,link);
      null = FWUL2.forward3(linkReg,link);
      null = FWUL3.forward3(linkReg,link);
    };

    stage 5 :
    {
      null = FWUL0.forward5(linkReg,link);
      null = FWUL1.forward5(linkReg,link);
      null = FWUL2.forward5(linkReg,link);
      null = FWUL3.forward5(linkReg,link);
    };

    stage 6 :
    {
      null = GPR.write0(linkReg,link);
      null = FWUL0.forward7(linkReg,link);
      null = FWUL1.forward7(linkReg,link);
      null = FWUL2.forward7(linkReg,link);
      null = FWUL3.forward7(linkReg,link);
    };
  };
  instruction JRm : R
  {
    opecode  opcode = "0101000000000011";

    wire [31:0] target;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source = GPR.read0(rs);
      target = FWUL0.forward(rs,tmp_source);
    };

    stage 3 :
    {
      null = CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction JALRm : R
  {
    opecode  opcode = "0101000000000100";

    wire [31:0] target;
    wire [4:0] linkReg;
    wire [31:0] tmp_pc;
    wire [31:0] link; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; link = CPC.read();
      tmp_source = GPR.read0(rs);
      target = FWUL0.forward(rs,tmp_source);
    };

    stage 3 :
    {
      null = CPC.write(target);
      linkReg = "11111";
      null = FWUL0.forward1(linkReg,link);
      null = FWUL1.forward1(linkReg,link);
      null = FWUL2.forward1(linkReg,link);
      null = FWUL3.forward1(linkReg,link);
    };

    stage 4 :
    {
      null = FWUL0.forward3(linkReg,link);
      null = FWUL1.forward3(linkReg,link);
      null = FWUL2.forward3(linkReg,link);
      null = FWUL3.forward3(linkReg,link);
    };

    stage 5 :
    {
      null = FWUL0.forward5(linkReg,link);
      null = FWUL1.forward5(linkReg,link);
      null = FWUL2.forward5(linkReg,link);
      null = FWUL3.forward5(linkReg,link);
    };

    stage 6 :
    {
      null = GPR.write0(linkReg,link);
      null = FWUL0.forward7(linkReg,link);
      null = FWUL1.forward7(linkReg,link);
      null = FWUL2.forward7(linkReg,link);
      null = FWUL3.forward7(linkReg,link);
    };
  };
  instruction BEQm : I
  {
    opecode  opcode = "0101000000000101";

    wire [31:0] target;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [29:0] tmp;
      wire [31:0] tmp_source0;
      wire  cout;
      wire  cin;
      wire [31:0] tmp_source1;
      wire [31:0] ext_imm;
      wire [1:0] zero2;
      wire [31:0] offset;
      wire [31:0] tmp_cpc;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire  zero;
      wire  cond;
      wire [3:0] flag;
      
      flag = ALU1.cmp(source0,source1);
      zero = flag[2];
      cond = zero =='1';
      null = [cond]CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BNEm : I
  {
    opecode  opcode = "0101000000000110";

    wire [31:0] target;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [29:0] tmp;
      wire [31:0] tmp_source0;
      wire  cout;
      wire  cin;
      wire [31:0] tmp_source1;
      wire [31:0] ext_imm;
      wire [1:0] zero2;
      wire [31:0] offset;
      wire [31:0] tmp_cpc;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire  zero;
      wire  cond;
      wire [3:0] flag;
      
      flag = ALU1.cmp(source0,source1);
      zero = flag[2];
      cond = zero != '1';
      null = [cond]CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BLEZm : I
  {
    opecode  opcode = "0101000000000111";

    wire [31:0] target;
    wire [31:0] source0;
    wire [31:0] src0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [29:0] tmp;
      wire [31:0] tmp_source0;
      wire  cout;
      wire  cin;
      wire [31:0] ext_imm;
      wire [31:0] offset;
      wire [31:0] tmp_cpc;
      wire [1:0] zero2;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      src0 = FWU0.forward(rs,tmp_source0);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire  cond_tmp;
      wire  Z;
      wire  cond;
      wire [3:0] flag;
      wire  N;
      
      flag = ALU1.cmpz(src0);
      N = flag[1];
      Z = flag[2];
      cond_tmp = N|Z;
      cond = cond_tmp == '1';
      null = [cond]CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BGTZm : I
  {
    opecode  opcode = "0101000000001000";

    wire [31:0] target;
    wire [31:0] source0;
    wire [31:0] src0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [29:0] tmp;
      wire [31:0] tmp_source0;
      wire  cout;
      wire  cin;
      wire [31:0] ext_imm;
      wire [31:0] offset;
      wire [31:0] tmp_cpc;
      wire [1:0] zero2;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      src0 = FWU0.forward(rs,tmp_source0);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire  cond_tmp;
      wire  Z;
      wire  cond;
      wire [3:0] flag;
      wire  N;
      
      flag = ALU1.cmpz(src0);
      N = flag[1];
      Z = flag[2];
      cond_tmp = N|Z;
      cond = cond_tmp != '1';
      null = [cond]CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BLTZm : I
  {
    opecode  opcode = "0101000000001001";

    wire [31:0] target;
    wire [31:0] source0;
    wire [31:0] src0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [29:0] tmp;
      wire [31:0] tmp_source0;
      wire  cout;
      wire  cin;
      wire [31:0] ext_imm;
      wire [31:0] offset;
      wire [31:0] tmp_cpc;
      wire [1:0] zero2;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      src0 = FWU0.forward(rs,tmp_source0);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire  cond;
      wire  N;
      
      flag = ALU1.cmpz(src0);
      N = flag[1];
      cond = N == '1';
      null = [cond]CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction BGEZm : I
  {
    opecode  opcode = "0101000000001010";

    wire [31:0] target;
    wire [31:0] source0;
    wire [31:0] src0;
    wire [31:0] source1;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [29:0] tmp;
      wire [31:0] tmp_source0;
      wire  cout;
      wire  cin;
      wire [31:0] ext_imm;
      wire [31:0] offset;
      wire [31:0] tmp_cpc;
      wire [1:0] zero2;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      src0 = FWU0.forward(rs,tmp_source0);
      cin = '0';
      zero2 = "00";
      ext_imm = EXT1.sign(imm);
      tmp = ext_imm[29:0];
      offset = <tmp,zero2>;
      tmp_cpc = CPC.read();
      <target,cout> = ADD1.adc(tmp_cpc,offset,cin);
    };

    stage 3 :
    {
      wire [3:0] flag;
      wire  cond;
      wire  N;
      
      flag = ALU1.cmpz(src0);
      N = flag[1];
      cond = N != '1';
      null = [cond]CPC.write(target);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction ADDm : R
  {
    opecode  opcode = "0101000001000000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.add(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction ADDIm : I
  {
    opecode  opcode = "0101000001000001";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.add(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction ADDUm : R
  {
    opecode  opcode = "0101000001000010";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.addu(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };

    stage 5 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction ADDIUm : I
  {
    opecode  opcode = "0101000001000011";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.addu(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction SUBm : R
  {
    opecode  opcode = "0101000001000100";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.sub(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SUBUm : R
  {
    opecode  opcode = "0101000001000101";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.subu(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction MULTm : R
  {
    opecode  opcode = "0101000001000110";

    wire [31:0] resulthi;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [63:0] result;
    wire [31:0] tmp_pc;
    wire [31:0] resultlo; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      result = MUL1.mul(source0,source1);
      resulthi = result[63:32];
      resultlo = result[31:0];
      null = LO.write(resultlo);
      null = HI.write(resulthi);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction MULTUm : R
  {
    opecode  opcode = "0101000001000111";

    wire [31:0] resulthi;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [63:0] result;
    wire [31:0] tmp_pc;
    wire [31:0] resultlo; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      result = MUL1.mulu(source0,source1);
      resulthi = result[63:32];
      resultlo = result[31:0];
      null = LO.write(resultlo);
      null = HI.write(resulthi);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction DIVm : R
  {
    opecode  opcode = "0101000001001000";

    wire [31:0] resulthi;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc;
    wire [31:0] resultlo; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire  flag;
      
      <resultlo,resulthi,flag> = DIV1.div(source0,source1);
      null = LO.write(resultlo);
      null = HI.write(resulthi);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction DIVUm : R
  {
    opecode  opcode = "0101000001001001";

    wire [31:0] resulthi;
    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] tmp_pc;
    wire [31:0] resultlo; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire  flag;
      
      <resultlo,resulthi,flag> = DIV1.divu(source0,source1);
      null = LO.write(resultlo);
      null = HI.write(resulthi);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction MFHIm : R
  {
    opecode  opcode = "0101000001001010";

    wire [31:0] tmp_pc;
    wire [31:0] result; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire  one1b0;
      wire  zero1b;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; one1b0 = '1';
      zero1b = '0';
      result = HI.read();
    };

    stage 3 :
    {
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction MTHIm : R
  {
    opecode  opcode = "0101000001001011";

    wire [31:0] source0;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
    };

    stage 3 :
    {
      null = HI.write(source0);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction MFLOm : R
  {
    opecode  opcode = "0101000001001100";

    wire [31:0] tmp_pc;
    wire [31:0] result; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire  one1b0;
      wire  zero1b;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; one1b0 = '1';
      zero1b = '0';
      result = LO.read();
    };

    stage 3 :
    {
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction MTLOm : R
  {
    opecode  opcode = "0101000001001101";

    wire [31:0] source0;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
    };

    stage 3 :
    {
      null = LO.write(source0);
    };

    stage 4 :
    {
      
    };

    stage 5 :
    {
      
    };

    stage 6 :
    {
      
    };
  };
  instruction ANDm : R
  {
    opecode  opcode = "0101000001001110";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.and(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction ANDIm : I
  {
    opecode  opcode = "0101000001001111";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.zero(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.and(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction ORm : R
  {
    opecode  opcode = "0101000001010000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.or(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction ORIm : I
  {
    opecode  opcode = "0101000001010001";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.zero(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.or(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction XORm : R
  {
    opecode  opcode = "0101000001010010";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.xor(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction XORIm : I
  {
    opecode  opcode = "0101000001010011";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.zero(imm);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.xor(source0,source1);
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction NORm : R
  {
    opecode  opcode = "0101000001010100";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [3:0] flag;
      
      <result,flag> = ALU1.nor(source0,source1);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLLm : R
  {
    opecode  opcode = "0101000001010101";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [23:0] zero24;
      wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; zero24 = "000000000000000000000000";
      tmp_source0 = GPR.read0(rt);
      source0 = FWUL0.forward(rt,tmp_source0);
      source1 = <zero24,shamt>;
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source1[4:0];
      result = SFT1.sll(source0,shift);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLLVm : R
  {
    opecode  opcode = "0101000001010110";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source0[4:0];
      result = SFT1.sll(source1,shift);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SRLm : R
  {
    opecode  opcode = "0101000001010111";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [23:0] zero24;
      wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; zero24 = "000000000000000000000000";
      tmp_source0 = GPR.read0(rt);
      source0 = FWUL0.forward(rt,tmp_source0);
      source1 = <zero24,shamt>;
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source1[4:0];
      result = SFT1.srl(source0,shift);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SRLVm : R
  {
    opecode  opcode = "0101000001011000";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source0[4:0];
      result = SFT1.srl(source1,shift);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SRAm : R
  {
    opecode  opcode = "0101000001011001";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [23:0] zero24;
      wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; zero24 = "000000000000000000000000";
      tmp_source0 = GPR.read0(rt);
      source0 = FWUL0.forward(rt,tmp_source0);
      source1 = <zero24,shamt>;
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source1[4:0];
      result = SFT1.sra(source0,shift);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SRAVm : R
  {
    opecode  opcode = "0101000001011010";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [4:0] shift;
      
      shift = source0[4:0];
      result = SFT1.sra(source1,shift);
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLTm : R
  {
    opecode  opcode = "0101000001011011";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [30:0] zero31;
      wire  VnN;
      wire [3:0] flag;
      wire  cond;
      wire [1:0] flag2;
      wire  NnV;
      
      zero31 = "0000000000000000000000000000000";
      flag = ALU1.cmp(source0,source1);
      flag2 = flag[1:0];
      NnV = flag2=="10";
      VnN = flag =="1001";
      cond = NnV | VnN;
      result = <zero31,cond>;
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLTUm : R
  {
    opecode  opcode = "0101000001011101";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [7:0] shamt;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      wire [31:0] tmp_source1;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; rd = tmp_ir[12:8]; shamt = tmp_ir[7:0]; tmp_source0 = GPR.read0(rs);
      tmp_source1 = GPR.read1(rt);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = FWUL1.forward(rt,tmp_source1);
    };

    stage 3 :
    {
      wire [30:0] zero31;
      wire [3:0] flag;
      wire  cond;
      wire [1:0] flag2;
      
      zero31 = "0000000000000000000000000000000";
      flag = ALU1.cmpu(source0,source1);
      flag2 = flag[3:2];
      cond = flag2 == "00";
      result = <zero31,cond>;
      null = FWUL0.forward1(rd,result);
      null = FWUL1.forward1(rd,result);
      null = FWUL2.forward1(rd,result);
      null = FWUL3.forward1(rd,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rd,result);
      null = FWUL1.forward3(rd,result);
      null = FWUL2.forward3(rd,result);
      null = FWUL3.forward3(rd,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rd,result);
      null = FWUL1.forward5(rd,result);
      null = FWUL2.forward5(rd,result);
      null = FWUL3.forward5(rd,result);
    };

    stage 6 :
    {
      null = GPR.write0(rd,result);
      null = FWUL0.forward7(rd,result);
      null = FWUL1.forward7(rd,result);
      null = FWUL2.forward7(rd,result);
      null = FWUL3.forward7(rd,result);
    };
  };
  instruction SLTIUm : I
  {
    opecode  opcode = "0101000001011110";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.zero(imm);
    };

    stage 3 :
    {
      wire [30:0] zero31;
      wire [3:0] flag;
      wire  cond;
      wire [1:0] flag2;
      
      zero31 = "0000000000000000000000000000000";
      flag = ALU1.cmpu(source0,source1);
      flag2 = flag[3:2];
      cond = flag2 == "00";
      result = <zero31,cond>;
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction LUIm : I
  {
    opecode  opcode = "0101000010100010";

    wire [31:0] tmp_pc;
    wire [31:0] result; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [15:0] zero16;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; zero16 = "0000000000000000";
      result = <imm,zero16>;
    };

    stage 3 :
    {
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
  instruction SLTIm : I
  {
    opecode  opcode = "0101000001011100";

    wire [31:0] source0;
    wire [31:0] source1;
    wire [31:0] result;
    wire [31:0] tmp_pc; wire [4:0] rs; wire [4:0] rt; wire [15:0] imm;

    stage 1 :
    {
      wire [31:0] current_pc;
      wire [63:0] inst0;
      wire  iramaddr_err;
      
      current_pc = CPC.read();
      tmp_pc = current_pc;
      <inst0,iramaddr_err> = Imem.ld_64(current_pc);
      null = IReg.write(inst0);
      null = CPC.inc();
    };

    stage 2 :
    {
      wire [63:0] tmp_ir;       wire [31:0] tmp_source0;
      
      tmp_ir = IReg.read(); rs = tmp_ir[28:24]; rt = tmp_ir[20:16]; imm = tmp_ir[15:0]; tmp_source0 = GPR.read0(rs);
      source0 = FWUL0.forward(rs,tmp_source0);
      source1 = EXT1.sign(imm);
    };

    stage 3 :
    {
      wire [30:0] zero31;
      wire  VnN;
      wire [3:0] flag;
      wire  cond;
      wire [1:0] flag2;
      wire  NnV;
      
      zero31 = "0000000000000000000000000000000";
      flag = ALU1.cmp(source0,source1);
      flag2 = flag[1:0];
      NnV = flag2 == "10";
      VnN = flag == "1001";
      cond = NnV | VnN;
      result = <zero31,cond>;
      null = FWUL0.forward1(rt,result);
      null = FWUL1.forward1(rt,result);
      null = FWUL2.forward1(rt,result);
      null = FWUL3.forward1(rt,result);
    };

    stage 4 :
    {
      null = FWUL0.forward3(rt,result);
      null = FWUL1.forward3(rt,result);
      null = FWUL2.forward3(rt,result);
      null = FWUL3.forward3(rt,result);
    };

    stage 5 :
    {
      null = FWUL0.forward5(rt,result);
      null = FWUL1.forward5(rt,result);
      null = FWUL2.forward5(rt,result);
      null = FWUL3.forward5(rt,result);
    };

    stage 6 :
    {
      null = GPR.write0(rt,result);
      null = FWUL0.forward7(rt,result);
      null = FWUL1.forward7(rt,result);
      null = FWUL2.forward7(rt,result);
      null = FWUL3.forward7(rt,result);
    };
  };
}
