+ASIPmesiter meta-data
In meister/ folder, there are two meta-data generated by
ASIPmeister compilation:

(1) .ppd file. This file contains all the operations 
including the implicit ones in datapath. 
Thus, this file can be used to generate computational model
such as dataflow graph. Look up string pattern "/* Instruction */".

This file also contains the instruction type definition. Look up
string pattern "/* Instruction Type */". Type definition provides
the operands, which are the reserved or implicit variables and
statements in instruction definition. Identifying those objects
is vital for creating/modifying instruction definitions in ppd file
(for passing through ASIPmeister ADL-to-HDL compiler).

(2) .mod file. This file contains user-defined explicit operations,
in datapath. Thus this file can be used to automate the process of
modifying micro-operation description. The flow can be like:
original pdb --> original mod --> new instructions --> new pdb.
One constraint is that the new instructions must be described with 
non-macro operations.

To find microoperation of instruction set, look up string pattern
"MOT{".

Note neither two files contain user-defined macros. The macros are
already replaced with operations.

(3) Major (most significant) difference between ppd and mod files is
ppd file has additional descriptions of global variables,
and local variables and statements at decoding stage:
    (a)global variables: 
    instruction (type) specific, operands 
    such as rs rt rd shamt in ADD.
    (b)local variables: 
    fixed, wire [63:0] tmp_ir
    (c)local statement: 
    fixed, "tmp_ir = IReg.read()" --> reads instruction code
    instruction specific, operands get values from code (decoding) 
    such as "rs = tmp_ir[28:24]", "rt = tmp_ir[20:16]", 
    "rd = tmp_ir[12:8]", "shamt = tmp_ir[7:0]" in ADD.


+Customizing .pdb file
.pdb file is the raw input containing all the descriptions about the
processor.
A few things to change at different segment in pdb file:

(1) add hardware resource. The segment is with the
string pattern "ResourceDecl{". Each resource is declared after
the string pattern "Instance{".

(2) add i/o ports (optional). The segment is with the 
string pattern "EntityDecl{". Each port is declared after
the string pattern "Entity{".

(3) add instruction type (optional). The segment is with the
string pattern "InstructionDecl{" Each type is declared after the
string pattern "InstructionType{".

(4) add instruction encoding. The segment is string pattern
"Instruction{". This segment is a sub-segment in "InstructionDecl{}".

(5) add interrupt and exception. The segment is with string pattern
"OperationDesc{". OperationDesc has sub-segments: 
    (a) InstBehavior{},
    (b) ExceptionBehavior{}.

(6) add C definition. This segment is with string pattern
"CdefinitionDecl{". It has sub-segments:
    (a) C_data_type{},
    (b) Data_macro{},
    (c) C_ckf_prototype{}.

(7) add microoperation description (MOD). This segment is with string pattern
"MOD{". It has sub-segments:
    (a) Instruction{},
    (b) Exception{},
    (c) Macro{}.

+The detailed information about .pdb file structure:

(1) Version segment is the first segment and can be recognized by "Version{".
No subsegments.

(2) File type segment is next to Version and by "FileType{".
No subsegments.

(3) Database segment is next to FileType and by "Database{".
Subsegments: path,"path{"; sufix,"sufix{";type,"type{".

(4) Preference segment is next to Database and by "Preference{".
Subsegments: version,"Version{".

(5) Abstract level architecture segment is next to Database and by "AbsLevelArch{".
Subsegments: 
    "Complete{",
    "CPUtype{":
        "midTitle{",
        "label{",
        "method{",
        "select{",
        "Pipeline{":
            "midTitle{",
            "StageNum{":
                "midTitle{","label{","method{","unit{","select{".
            "CommonStageNum{":
                "midTitle{","label{","method{","unit{","select{","enable{".
            "DecodeStage{":
                "midTitle{","label{","method{","unit{","select{".
            "StageDef{":
                "midTitle{",
                "method{",
                "stage{":
                    "midTitle{",
                    "1{":
                        "midTitle{","label{","method{","unit{","select{".
                    "2{":
                        same as above.
                    "n{":
                        same as above.
            "MultiscInterlock{":
                "midTitle{","label{","method{","select{","enable{".
            "DataHazInterlock{":
                "midTitle{","label{","method{","select{","enable{".
            "RegBypass{":
                "midTitle{","label{","method{","select{","enable{".
            "DlydBranch{":
                "midTitle{",
                "label{",
                "method{",
                "select{",
                "Yes{":
                    "midTitle{",
                    "DelayedSlot{":
                        "midTitle{",
                        "label{",
                        "method{",
                        "unit{",
                        "select{"
    "MAXInstBitWidth{":
        "midTitle{","label{","method{","unit{","select{".
    "Projectname{":
        "midTitle{","label{","method{","select{".
    "FhmWorkname{":
        "midTitle{","label{","method{","select{","enable{".
    "Revision{":
        "midTitle{","label{","method{","select{".
    "DesignConst{":
        "midTitle{",
        "method{",
        "Design_Goal{":
            "midTitle{",
            "Area{":
                "midTitle{","label{","method{","unit{","select{".
            "Delay{":
                "midTitle{","label{","method{","unit{","select{".
            "PowerS{":
                "midTitle{","label{","method{","unit{","select{".
    "Priority{":
        "midTitle{","label{","method{","select{".
    "MAXDataBitWidth{":
        "midTitle{","label{","method{","unit{","select{".
    "ProcessorDesign{":
        "midTitle{","label{","method{","select{".
    "UseCompiler{":
        "midTitle{","label{","method{","select{","enable{".

(6) Entity declaration segment is next to Abstract level architecture
and by "EntityDecl{".
Subsegments:
    "Complete{",
    "ComponentName{",
    "Entity{":
        "1{":
            "valid{","name{","type{","entity{","attribute{".
        "2{":
            "valid{","name{","type{","entity{","attribute{".
        "n{":
            "valid{","name{","type{","entity{","attribute{".
n is bounded by number of total entities.

(7) Resource declaration segment is next to Entity declaration
and by "ResourceDecl{".
Subsegments:
    "Complete{",
    "Instance{":
        "ALU1{":
            "valid{",
            "class{":
                "name{",
                "modelpath{",
                "use{",
                "parameter{":
                    "bit_width{","algorithm{".
            "Simulation{",
            "Synthesis{",
            "Comment{".
        "xxx{":
            same as above.

(8) Storage specification segment is next to Resource declaration
and by "StorageSpec{".
Subsegments:
    "Complete{",
    "RegisterFile{":
        "Before{":
            "0{":
                "Name{","Resource{","Width{","Usage{","Location{","Binary{".
        "After{":
            "0{":
                "Name{","Class{","Resource{","Width{","Num{","Usage{",
                "Location{","Binary{".
            "1{":
                "Name{","Class{","Resource{","Width{","Num{","Usage{",
                "Location{","Binary{".
            "n{":
                "Name{","Class{","Resource{","Width{","Num{","Usage{",
                "Location{","Binary{".
    "Register{":       
        "0{":
            "Name{","Resource{","Width{","Usage{","Location{".
        "m{":
            "Name{","Resource{","Width{","Usage{","Location{".
    "Memory{":
        "0{":
            "Name{","Resource{","Width{","Usage{","Access{".
        "m{":
            "Name{","Resource{","Width{","Usage{","Access{".
n is bounded by number of total registers in register-file.
m is bounded by number of the resource (register or memory).

(9) Instruction declaration segment is next to Storage specification
and by "InstructionDecl{".
Subsegments:
    "Complete{",
    "MaxInstId{",
    "InstructionType{":
        "R  #1{":
            "Valid{",
            "Name{",
            "Entity{":
                "1{":
                    "MSB{","LSB{","FieldType{","FieldAttr{","Value{",
                    "Addr_mode{","Operand_Name{","Element_Name{","Reg_class{".
                "2{":
                    "MSB{","LSB{","FieldType{","FieldAttr{","Value{",
                    "Addr_mode{","Operand_Name{","Element_Name{","Reg_class{".
                "n{":
                    "MSB{","LSB{","FieldType{","FieldAttr{","Value{",
                    "Addr_mode{","Operand_Name{","Element_Name{","Reg_class{".
            "BaseProcessor{".
        "I  #1{":
            "Valid{",
            "Name{",
            "Entity{":
                "1{":
                    "MSB{","LSB{","FieldType{","FieldAttr{","Value{",
                    "Addr_mode{","Operand_Name{","Element_Name{","Reg_class{".
                "2{":
                    "MSB{","LSB{","FieldType{","FieldAttr{","Value{",
                    "Addr_mode{","Operand_Name{","Element_Name{","Reg_class{".
                "n{":
                    "MSB{","LSB{","FieldType{","FieldAttr{","Value{",
                    "Addr_mode{","Operand_Name{","Element_Name{","Reg_class{".
            "BaseProcessor{".
        "X  #1{":
            same as above.
    "Instruction{":
        "LB  #1{":
            "Type{",
            "Valid{",
            "Name{",
            "Id{",
            "EditField{":
                "1{","2{","n{".
            "Format{",
            "BaseProcessor{".
        "XX  #1{":
            same as above.
n is bounded by number of instruction code fields.
X is type name given by user.
XX is instruction name given by user.

(10) Operation description segment is next to instruction delcaration
and by "OperationDesc{".
Subsegments:
    "Complete{",
    "InstBehavior{",
    "ExceptionBehavior{":
        "reset{":
            "valid{",
            "type{",
            "cycle{",
            "description{",
            "assertion{",
            "comment{",
            "condition{":
                "condition_type{",
                "Reset{":
                    "valid{",
                    "active_value{".
            "mask{":
                "maskable{","register_name{","position{","register_value{".
        "X{":
            same as above.
X is exception name given by user.

(11) C definition declaration segment is next to Operation description
and by "CdefinitionDecl{".
Subsegments:
    "Complete{",
    "C_data_type{":
        "0{":
            "type{","alignment{","size{".
        "n{":
            same as above.
    "Data_macro{",
    "C_ckf_prototype{".
n is bounded by total number of data types (char, short integer, etc.).

(12) Microoperation description is next to C definition declaration
and by "MOD{".
Subsegments:
    "Complete{",
    "Common{",
    "Instruction{":
        "LB  #1{":
            "id{","variable{","1{","2{","n{".
        "XX  #1{":
            same as above.
    "Exception{":
        "reset{":
            "variable{","1{".
        "XXX{":
            same as above.
    "Macro{":
        "xGPR1READEXT1DEST(arg1,arg2){":
            "variable{","1{","2{","m{","BaseProcessor{".
        "XXXX(@){":
            same as above.
n is bounded by stage number of the instruction.
XX is the instrution name given by user at previous segment.
XXX is the exception name given by user at previous segment.
m is varied macro by macro, and is bounded by pipeline stage number.
XXXX is the macro name given by user.
@ is the argument list given by user.

(13) Estimation segment is next to MOD segment and can be recognized by
string pattern "Estimation{".
Subsegments:
    "ArchLevel{":
        "Complete{".
    "BehaviorLevel{":
        "Complete{".
    "RTLevel{":
        "Complete{".

(14) Genertion segment is next to Estimation segment and can be recognized by
string pattern "Generation{".
Subsegments:
    "ISSmodel{":
        "Complete{".
    "Model{":
        "Complete{",
        "lang{":
            "0{","1{","2{".

(15) SW generation segment is next to Generation segment and can be recognized by
"SW_Generation{".
Subsegments:
    "SWmodel{":
        "Complete{".

(16) ASM generation segment is next to SW generation segment and can be recognized by
"ASM_Generation{".
Subsegments:
    "ASMmodel{":
        "Complete{".
